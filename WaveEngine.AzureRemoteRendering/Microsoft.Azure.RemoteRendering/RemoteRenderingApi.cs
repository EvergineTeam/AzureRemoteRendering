// <auto-generated/>
#pragma warning disable

//
// RemoteRenderingClient
// This file was auto-generated from AzureRemoteRenderingApiModel.cs.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace Microsoft.Azure.RemoteRendering
{
    internal enum status
    {
        /// <summary>
        /// Success
        /// </summary>
        OK = 0,
        /// <summary>
        /// Failed
        /// </summary>
        Failed = 1,
        /// <summary>
        /// Cannot access a disposed object.
        /// </summary>
        ObjectDisposed = 2,
        /// <summary>
        /// Out of memory.
        /// </summary>
        OutOfMemory = 12,
        /// <summary>
        /// Invalid argument.
        /// </summary>
        InvalidArgument = 22,
        /// <summary>
        /// The value is out of range.
        /// </summary>
        OutOfRange = 34,
        /// <summary>
        /// Not implemented.
        /// </summary>
        NotImplemented = 38,
        /// <summary>
        /// The key does not exist in the collection.
        /// </summary>
        KeyNotFound = 77,
        /// <summary>
        /// General return values start.
        /// </summary>
        CoreReturnValueStart = 78,
        Success = 79,
        Fail = 80,
        Cancelled = 81,
        InvalidParam = 82,
        InvalidType = 83,
        BufferTooSmall = 84,
        NoConnection = 85,
        ApiUnavailable = 86,
        AlreadyInitialized = 87,
        AlreadyDeinitialized = 88,
        StringTooLong = 89,
        IndexOutOfRange = 90,
        InProgress = 91,
        NotInitialized = 92,
        CoreReturnValueLast = 93,
        CoreReturnValueEnd = 94,
        LoadFileReturnValueStart = 95,
        FileNotFound = 96,
        InvalidVersion = 97,
        IncompatibleVersion = 98,
        FailedToOpenFile = 99,
        FileDownloadFailed = 100,
        ExceedsMemoryLimit = 101,
        LoadFileReturnValueLast = 102,
        LoadFileReturnValueEnd = 103,
        ObjectReturnValueStart = 104,
        InvalidId = 105,
        InvalidParentId = 106,
        AlreadyExists = 107,
        CyclicReference = 108,
        ObjectLocked = 109,
        ObjectReturnValueLast = 110,
        ObjectReturnValueEnd = 111,
        ConnectionReturnValueStart = 112,
        NoServerCertificate = 113,
        HandshakePortBusy = 114,
        HandshakeUnreachable = 115,
        HandshakeConnectionFailed = 116,
        AuthenticationFailed = 117,
        RemotingVersionMismatch = 118,
        IncompatibleTransportProtocols = 119,
        HandshakeFailed = 120,
        TransportPortBusy = 121,
        TransportUnreachable = 122,
        TransportConnectionFailed = 123,
        ProtocolVersionMismatch = 124,
        ProtocolError = 125,
        VideoCodecNotAvailable = 126,
        ConnectionLost = 127,
        DeviceLost = 128,
        DisconnectRequest = 129,
        Timeout = 130,
        AlreadyConnected = 131,
        ArrVersionMismatch = 132,
        HandshakeNetworkUnreachable = 133,
        HandshakeConnectionRefused = 134,
        VideoFormatNotAvailable = 135,
        PeerDisconnectRequest = 136,
        PeerDisconnectTimeout = 137,
        ConnectionReturnValueLast = 138,
        ConnectionReturnValueEnd = 139,
        ManagerReturnValueStart = 140,
        InvalidToolId = 141,
        ManagerAlreadyCreated = 142,
        ManagerNotCreatedYet = 143,
        OtherSessionConnected = 144,
        BadStateTransition = 145,
        ManagerReturnValueLast = 146,
        ManagerReturnValueEnd = 147,
        SessionReturnValueStart = 148,
        InvalidToken = 149,
        InvalidUrl = 150,
        SessionReturnValueLast = 151,
        SessionReturnValueEnd = 152,
    }

    internal static class NativeLibraryHelpers
    {
        internal static string[] IntPtrToStringArray(IntPtr result, int result_length)
        {
            // an empty list is returned as a single null character
            if (result_length == 1)
            {
                return Array.Empty<string>();
            }

            byte[] bytes = new byte[result_length - 1];
            System.Runtime.InteropServices.Marshal.Copy(result, bytes, 0, result_length - 1);
            System.Runtime.InteropServices.Marshal.FreeCoTaskMem(result);
            return System.Text.Encoding.UTF8.GetString(bytes).Split('\0');
        }

        internal static void CheckStatus(IntPtr handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string message;
            string requestCorrelationVector;
            string responseCorrelationVector;

            Microsoft.Azure.RemoteRendering.status code = Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_error_details(handle, out message, out requestCorrelationVector, out responseCorrelationVector);

            string fullMessage;
            if (code == status.Failed)
            {
                throw new InvalidOperationException("Unexpected error in exception handling.");
            }
            else if (code != status.OK)
            {
                fullMessage = "Exception thrown and an unexpected error in exception handling.";
            }
            else
            {
                fullMessage = message + ". Request CV: " + requestCorrelationVector + ". Response CV: " + responseCorrelationVector + ".";
            }

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
                case status.CoreReturnValueStart:
                    throw new RRException(Result.CoreReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.Success:
                    throw new RRException(Result.Success, message, requestCorrelationVector, responseCorrelationVector);
                case status.Fail:
                    throw new RRException(Result.Fail, message, requestCorrelationVector, responseCorrelationVector);
                case status.Cancelled:
                    throw new RRException(Result.Cancelled, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidParam:
                    throw new RRException(Result.InvalidParam, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidType:
                    throw new RRException(Result.InvalidType, message, requestCorrelationVector, responseCorrelationVector);
                case status.BufferTooSmall:
                    throw new RRException(Result.BufferTooSmall, message, requestCorrelationVector, responseCorrelationVector);
                case status.NoConnection:
                    throw new RRException(Result.NoConnection, message, requestCorrelationVector, responseCorrelationVector);
                case status.ApiUnavailable:
                    throw new RRException(Result.ApiUnavailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyInitialized:
                    throw new RRException(Result.AlreadyInitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyDeinitialized:
                    throw new RRException(Result.AlreadyDeinitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.StringTooLong:
                    throw new RRException(Result.StringTooLong, message, requestCorrelationVector, responseCorrelationVector);
                case status.IndexOutOfRange:
                    throw new RRException(Result.IndexOutOfRange, message, requestCorrelationVector, responseCorrelationVector);
                case status.InProgress:
                    throw new RRException(Result.InProgress, message, requestCorrelationVector, responseCorrelationVector);
                case status.NotInitialized:
                    throw new RRException(Result.NotInitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.CoreReturnValueLast:
                    throw new RRException(Result.CoreReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.CoreReturnValueEnd:
                    throw new RRException(Result.CoreReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueStart:
                    throw new RRException(Result.LoadFileReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileNotFound:
                    throw new RRException(Result.FileNotFound, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidVersion:
                    throw new RRException(Result.InvalidVersion, message, requestCorrelationVector, responseCorrelationVector);
                case status.IncompatibleVersion:
                    throw new RRException(Result.IncompatibleVersion, message, requestCorrelationVector, responseCorrelationVector);
                case status.FailedToOpenFile:
                    throw new RRException(Result.FailedToOpenFile, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileDownloadFailed:
                    throw new RRException(Result.FileDownloadFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.ExceedsMemoryLimit:
                    throw new RRException(Result.ExceedsMemoryLimit, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueLast:
                    throw new RRException(Result.LoadFileReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueEnd:
                    throw new RRException(Result.LoadFileReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueStart:
                    throw new RRException(Result.ObjectReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidId:
                    throw new RRException(Result.InvalidId, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidParentId:
                    throw new RRException(Result.InvalidParentId, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyExists:
                    throw new RRException(Result.AlreadyExists, message, requestCorrelationVector, responseCorrelationVector);
                case status.CyclicReference:
                    throw new RRException(Result.CyclicReference, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectLocked:
                    throw new RRException(Result.ObjectLocked, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueLast:
                    throw new RRException(Result.ObjectReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueEnd:
                    throw new RRException(Result.ObjectReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueStart:
                    throw new RRException(Result.ConnectionReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.NoServerCertificate:
                    throw new RRException(Result.NoServerCertificate, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakePortBusy:
                    throw new RRException(Result.HandshakePortBusy, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeUnreachable:
                    throw new RRException(Result.HandshakeUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeConnectionFailed:
                    throw new RRException(Result.HandshakeConnectionFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.AuthenticationFailed:
                    throw new RRException(Result.AuthenticationFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.RemotingVersionMismatch:
                    throw new RRException(Result.RemotingVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.IncompatibleTransportProtocols:
                    throw new RRException(Result.IncompatibleTransportProtocols, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeFailed:
                    throw new RRException(Result.HandshakeFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportPortBusy:
                    throw new RRException(Result.TransportPortBusy, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportUnreachable:
                    throw new RRException(Result.TransportUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportConnectionFailed:
                    throw new RRException(Result.TransportConnectionFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.ProtocolVersionMismatch:
                    throw new RRException(Result.ProtocolVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.ProtocolError:
                    throw new RRException(Result.ProtocolError, message, requestCorrelationVector, responseCorrelationVector);
                case status.VideoCodecNotAvailable:
                    throw new RRException(Result.VideoCodecNotAvailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionLost:
                    throw new RRException(Result.ConnectionLost, message, requestCorrelationVector, responseCorrelationVector);
                case status.DeviceLost:
                    throw new RRException(Result.DeviceLost, message, requestCorrelationVector, responseCorrelationVector);
                case status.DisconnectRequest:
                    throw new RRException(Result.DisconnectRequest, message, requestCorrelationVector, responseCorrelationVector);
                case status.Timeout:
                    throw new RRException(Result.Timeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyConnected:
                    throw new RRException(Result.AlreadyConnected, message, requestCorrelationVector, responseCorrelationVector);
                case status.ArrVersionMismatch:
                    throw new RRException(Result.ArrVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeNetworkUnreachable:
                    throw new RRException(Result.HandshakeNetworkUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeConnectionRefused:
                    throw new RRException(Result.HandshakeConnectionRefused, message, requestCorrelationVector, responseCorrelationVector);
                case status.VideoFormatNotAvailable:
                    throw new RRException(Result.VideoFormatNotAvailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.PeerDisconnectRequest:
                    throw new RRException(Result.PeerDisconnectRequest, message, requestCorrelationVector, responseCorrelationVector);
                case status.PeerDisconnectTimeout:
                    throw new RRException(Result.PeerDisconnectTimeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueLast:
                    throw new RRException(Result.ConnectionReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueEnd:
                    throw new RRException(Result.ConnectionReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueStart:
                    throw new RRException(Result.ManagerReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidToolId:
                    throw new RRException(Result.InvalidToolId, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerAlreadyCreated:
                    throw new RRException(Result.ManagerAlreadyCreated, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerNotCreatedYet:
                    throw new RRException(Result.ManagerNotCreatedYet, message, requestCorrelationVector, responseCorrelationVector);
                case status.OtherSessionConnected:
                    throw new RRException(Result.OtherSessionConnected, message, requestCorrelationVector, responseCorrelationVector);
                case status.BadStateTransition:
                    throw new RRException(Result.BadStateTransition, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueLast:
                    throw new RRException(Result.ManagerReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueEnd:
                    throw new RRException(Result.ManagerReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueStart:
                    throw new RRException(Result.SessionReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidToken:
                    throw new RRException(Result.InvalidToken, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidUrl:
                    throw new RRException(Result.InvalidUrl, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueLast:
                    throw new RRException(Result.SessionReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueEnd:
                    throw new RRException(Result.SessionReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
            }
        }

        internal static void CheckStatus(ulong handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string fullMessage = string.Format("An error occurred: {0} ({0:d})", value);

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
                case status.CoreReturnValueStart:
                    throw new RRException(Result.CoreReturnValueStart, fullMessage);
                case status.Success:
                    throw new RRException(Result.Success, fullMessage);
                case status.Fail:
                    throw new RRException(Result.Fail, fullMessage);
                case status.Cancelled:
                    throw new RRException(Result.Cancelled, fullMessage);
                case status.InvalidParam:
                    throw new RRException(Result.InvalidParam, fullMessage);
                case status.InvalidType:
                    throw new RRException(Result.InvalidType, fullMessage);
                case status.BufferTooSmall:
                    throw new RRException(Result.BufferTooSmall, fullMessage);
                case status.NoConnection:
                    throw new RRException(Result.NoConnection, fullMessage);
                case status.ApiUnavailable:
                    throw new RRException(Result.ApiUnavailable, fullMessage);
                case status.AlreadyInitialized:
                    throw new RRException(Result.AlreadyInitialized, fullMessage);
                case status.AlreadyDeinitialized:
                    throw new RRException(Result.AlreadyDeinitialized, fullMessage);
                case status.StringTooLong:
                    throw new RRException(Result.StringTooLong, fullMessage);
                case status.IndexOutOfRange:
                    throw new RRException(Result.IndexOutOfRange, fullMessage);
                case status.InProgress:
                    throw new RRException(Result.InProgress, fullMessage);
                case status.NotInitialized:
                    throw new RRException(Result.NotInitialized, fullMessage);
                case status.CoreReturnValueLast:
                    throw new RRException(Result.CoreReturnValueLast, fullMessage);
                case status.CoreReturnValueEnd:
                    throw new RRException(Result.CoreReturnValueEnd, fullMessage);
                case status.LoadFileReturnValueStart:
                    throw new RRException(Result.LoadFileReturnValueStart, fullMessage);
                case status.FileNotFound:
                    throw new RRException(Result.FileNotFound, fullMessage);
                case status.InvalidVersion:
                    throw new RRException(Result.InvalidVersion, fullMessage);
                case status.IncompatibleVersion:
                    throw new RRException(Result.IncompatibleVersion, fullMessage);
                case status.FailedToOpenFile:
                    throw new RRException(Result.FailedToOpenFile, fullMessage);
                case status.FileDownloadFailed:
                    throw new RRException(Result.FileDownloadFailed, fullMessage);
                case status.ExceedsMemoryLimit:
                    throw new RRException(Result.ExceedsMemoryLimit, fullMessage);
                case status.LoadFileReturnValueLast:
                    throw new RRException(Result.LoadFileReturnValueLast, fullMessage);
                case status.LoadFileReturnValueEnd:
                    throw new RRException(Result.LoadFileReturnValueEnd, fullMessage);
                case status.ObjectReturnValueStart:
                    throw new RRException(Result.ObjectReturnValueStart, fullMessage);
                case status.InvalidId:
                    throw new RRException(Result.InvalidId, fullMessage);
                case status.InvalidParentId:
                    throw new RRException(Result.InvalidParentId, fullMessage);
                case status.AlreadyExists:
                    throw new RRException(Result.AlreadyExists, fullMessage);
                case status.CyclicReference:
                    throw new RRException(Result.CyclicReference, fullMessage);
                case status.ObjectLocked:
                    throw new RRException(Result.ObjectLocked, fullMessage);
                case status.ObjectReturnValueLast:
                    throw new RRException(Result.ObjectReturnValueLast, fullMessage);
                case status.ObjectReturnValueEnd:
                    throw new RRException(Result.ObjectReturnValueEnd, fullMessage);
                case status.ConnectionReturnValueStart:
                    throw new RRException(Result.ConnectionReturnValueStart, fullMessage);
                case status.NoServerCertificate:
                    throw new RRException(Result.NoServerCertificate, fullMessage);
                case status.HandshakePortBusy:
                    throw new RRException(Result.HandshakePortBusy, fullMessage);
                case status.HandshakeUnreachable:
                    throw new RRException(Result.HandshakeUnreachable, fullMessage);
                case status.HandshakeConnectionFailed:
                    throw new RRException(Result.HandshakeConnectionFailed, fullMessage);
                case status.AuthenticationFailed:
                    throw new RRException(Result.AuthenticationFailed, fullMessage);
                case status.RemotingVersionMismatch:
                    throw new RRException(Result.RemotingVersionMismatch, fullMessage);
                case status.IncompatibleTransportProtocols:
                    throw new RRException(Result.IncompatibleTransportProtocols, fullMessage);
                case status.HandshakeFailed:
                    throw new RRException(Result.HandshakeFailed, fullMessage);
                case status.TransportPortBusy:
                    throw new RRException(Result.TransportPortBusy, fullMessage);
                case status.TransportUnreachable:
                    throw new RRException(Result.TransportUnreachable, fullMessage);
                case status.TransportConnectionFailed:
                    throw new RRException(Result.TransportConnectionFailed, fullMessage);
                case status.ProtocolVersionMismatch:
                    throw new RRException(Result.ProtocolVersionMismatch, fullMessage);
                case status.ProtocolError:
                    throw new RRException(Result.ProtocolError, fullMessage);
                case status.VideoCodecNotAvailable:
                    throw new RRException(Result.VideoCodecNotAvailable, fullMessage);
                case status.ConnectionLost:
                    throw new RRException(Result.ConnectionLost, fullMessage);
                case status.DeviceLost:
                    throw new RRException(Result.DeviceLost, fullMessage);
                case status.DisconnectRequest:
                    throw new RRException(Result.DisconnectRequest, fullMessage);
                case status.Timeout:
                    throw new RRException(Result.Timeout, fullMessage);
                case status.AlreadyConnected:
                    throw new RRException(Result.AlreadyConnected, fullMessage);
                case status.ArrVersionMismatch:
                    throw new RRException(Result.ArrVersionMismatch, fullMessage);
                case status.HandshakeNetworkUnreachable:
                    throw new RRException(Result.HandshakeNetworkUnreachable, fullMessage);
                case status.HandshakeConnectionRefused:
                    throw new RRException(Result.HandshakeConnectionRefused, fullMessage);
                case status.VideoFormatNotAvailable:
                    throw new RRException(Result.VideoFormatNotAvailable, fullMessage);
                case status.PeerDisconnectRequest:
                    throw new RRException(Result.PeerDisconnectRequest, fullMessage);
                case status.PeerDisconnectTimeout:
                    throw new RRException(Result.PeerDisconnectTimeout, fullMessage);
                case status.ConnectionReturnValueLast:
                    throw new RRException(Result.ConnectionReturnValueLast, fullMessage);
                case status.ConnectionReturnValueEnd:
                    throw new RRException(Result.ConnectionReturnValueEnd, fullMessage);
                case status.ManagerReturnValueStart:
                    throw new RRException(Result.ManagerReturnValueStart, fullMessage);
                case status.InvalidToolId:
                    throw new RRException(Result.InvalidToolId, fullMessage);
                case status.ManagerAlreadyCreated:
                    throw new RRException(Result.ManagerAlreadyCreated, fullMessage);
                case status.ManagerNotCreatedYet:
                    throw new RRException(Result.ManagerNotCreatedYet, fullMessage);
                case status.OtherSessionConnected:
                    throw new RRException(Result.OtherSessionConnected, fullMessage);
                case status.BadStateTransition:
                    throw new RRException(Result.BadStateTransition, fullMessage);
                case status.ManagerReturnValueLast:
                    throw new RRException(Result.ManagerReturnValueLast, fullMessage);
                case status.ManagerReturnValueEnd:
                    throw new RRException(Result.ManagerReturnValueEnd, fullMessage);
                case status.SessionReturnValueStart:
                    throw new RRException(Result.SessionReturnValueStart, fullMessage);
                case status.InvalidToken:
                    throw new RRException(Result.InvalidToken, fullMessage);
                case status.InvalidUrl:
                    throw new RRException(Result.InvalidUrl, fullMessage);
                case status.SessionReturnValueLast:
                    throw new RRException(Result.SessionReturnValueLast, fullMessage);
                case status.SessionReturnValueEnd:
                    throw new RRException(Result.SessionReturnValueEnd, fullMessage);
            }
        }
    }

    /// <summary>
    /// This interface is implemented by classes with events to help track callbacks.
    /// </summary>
    internal interface ICookie
    {
        /// <summary>
        /// Unique cookie value for callback identification.
        /// </summary>
        ulong Cookie { get; set; }
    }

    internal static class CookieTracker<T>
        where T : class, ICookie
    {
        private static ulong lastCookie;

        private static Dictionary<ulong, System.WeakReference<T>> tracked = new Dictionary<ulong, System.WeakReference<T>>();

        internal static void Add(T instance)
        {
            lock (tracked)
            {
                instance.Cookie = ++lastCookie;
                tracked[instance.Cookie] = new System.WeakReference<T>(instance);
            }
        }

        internal static T Lookup(ulong cookie)
        {
            T result;
            System.WeakReference<T> reference;
            bool found;

            lock (tracked)
            {
                found = tracked.TryGetValue(cookie, out reference);
            }

            if (!found)
            {
                return null;
            }

            found = reference.TryGetTarget(out result);

            if (!found)
            {
                lock (tracked)
                {
                    tracked.Remove(cookie);
                }
            }

            return result;
        }

        internal static void Remove(T instance)
        {
            lock (tracked)
            {
                tracked.Remove(instance.Cookie);
            }
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void DestructorHookDelegateNative(ulong cookie);

    /// <summary>
    /// Delegate for monitoring the progress of an asynchonrous operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="progress">
    /// Progress fraction between 0 and 1 for how close the operation is to finishing.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ProgressHandlerNative(ulong cookie, float progress);

    /// <summary>
    /// Delegate for receiving incoming log messages.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="level">
    /// Level of the log message.
    /// </param>
    /// <param name="message">
    /// Message as an IntPtr to the underlying utf8 char array.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void LogHandlerNative(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message);

    /// <summary>
    /// Delegate for receiving connection status updates.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="status">
    /// The new connection status.
    /// </param>
    /// <param name="error">
    /// Additional error information in the case of a spurious disconnect.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ConnectionStatusHandlerNative(ulong cookie, Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error);

    /// <summary>
    /// Delegate for receiving notification when an update tick has completed on a RemoteManager.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void UpdatedHandlerNative(ulong cookie);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void BoundsQueryHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void MetadataHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void LoadModelHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void LoadTextureHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void RaycastQueryHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void PerformanceAssessmentHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void SessionHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void CreateSessionHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Informs the application that a frontend requires an updated access token or authentication token.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="args">
    /// The callback handle.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void TokenRequiredDelegateNative(ulong cookie, IntPtr args);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void SessionPropertiesArrayHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void StartAssetConversionHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ConversionStatusHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ArrInspectorHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void SessionPropertiesHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="result">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ConnectToRuntimeHandlerNative(ulong cookie, IntPtr result);

    internal static partial class NativeLibrary
    {
        internal const string DllName = "RemoteRenderingClient";
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_name(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_type(IntPtr handle, out Microsoft.Azure.RemoteRendering.MetadataValueType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_bool(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_int(IntPtr handle, out int result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_int64(IntPtr handle, out long result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_uint64(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_double(IntPtr handle, out double result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_string(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_get_metadata_by_name(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string name, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_get_metadata(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out IntPtr[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_parent(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_parent(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_children(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_components(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_owner(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_destroy(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_find_component_of_type(ulong handle, Microsoft.Azure.RemoteRendering.ObjectType type, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_position(ulong handle, out Microsoft.Azure.RemoteRendering.Double3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_position(ulong handle, Microsoft.Azure.RemoteRendering.Double3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_rotation(ulong handle, out Microsoft.Azure.RemoteRendering.Quaternion result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_rotation(ulong handle, Microsoft.Azure.RemoteRendering.Quaternion value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_destroy(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_world_bounds_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_bounds_query_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.BoundsQueryHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_bounds_query_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.AABB3D result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_bounds_query_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_local_bounds_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_meta_data_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_metadata_query_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.MetadataHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_metadata_query_async_get_result(IntPtr handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_metadata_query_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_root(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_loaded_objects_of_type(IntPtr handle, Microsoft.Azure.RemoteRendering.ObjectType type, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_loaded_resource_of_type(IntPtr handle, Microsoft.Azure.RemoteRendering.ObjectType type, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_create(out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_status(IntPtr handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_is_completed(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_is_ran_to_completion(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_is_faulted(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_dispose(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.LoadModelHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_get_result(IntPtr handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_get_progress(IntPtr handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_set_progress_updated(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ProgressHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_texture_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.LoadTextureHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_texture_async_get_result(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_texture_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_raycast_query_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.RaycastQueryHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_raycast_query_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out Microsoft.Azure.RemoteRendering.RayCastHitAbi[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_raycast_query_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_performance_assessment_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_performance_assessment_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_performance_assessment_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_base_session_async_get_context(IntPtr handle, out Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.SessionHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_create_session_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.CreateSessionHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_create_session_async_get_result(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_azure_frontend(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_create_azure_frontend_account_info_init(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi init, out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_message_logged(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.LogHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_token_required(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.TokenRequiredDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_get_access_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_set_access_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_get_authentication_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_set_authentication_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_log_level(ulong handle, out Microsoft.Azure.RemoteRendering.LogLevel result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_log_level(ulong handle, Microsoft.Azure.RemoteRendering.LogLevel value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_configuration(ulong handle, out Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_current_rendering_sessions_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_array_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_array_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_array_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_open_rendering_session(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string session_id, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_create_new_rendering_session_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_create_new_rendering_session_unsafe_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_start_asset_conversion_async_deprecated(ulong handle, Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_start_asset_conversion_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.StartAssetConversionHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_start_asset_conversion_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_start_asset_conversion_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_start_asset_conversion_async(ulong handle, Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi input_location, Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi output_location, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_start_asset_conversion_sas_async(ulong handle, Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi input_location, Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi output_location, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_asset_conversion_status_async(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string conversion_id, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ConversionStatusHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.ConversionSessionStatus result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_get_message(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_dispose(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_connect_to_arr_inspector_async(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string hostname, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_arr_inspector_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ArrInspectorHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_arr_inspector_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_arr_inspector_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_properties_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.SessionPropertiesHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_stop_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_renew_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionUpdateParams update_params, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_session_uuid(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_connect_to_runtime(ulong handle, Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi input_params, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_connect_to_runtime_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_connect_to_runtime_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_connect_to_runtime_params(ulong handle, out Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_connection_status(ulong handle, out Microsoft.Azure.RemoteRendering.ConnectionStatus result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_is_connected(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_set_connection_status_changed(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.ConnectionStatusHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_disconnect_from_runtime(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_create_session_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_get_intensity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_set_intensity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_get_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_set_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_normal(ulong handle, out Microsoft.Azure.RemoteRendering.Axis result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_normal(ulong handle, Microsoft.Azure.RemoteRendering.Axis value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_fade_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_fade_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_fade_length(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_fade_length(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_flags(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalStates result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_flags(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_override_flags(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalStates result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_override_flags(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates feature, Microsoft.Azure.RemoteRendering.HierarchicalEnableState enabled_state);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates feature, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_tint_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_tint_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_hidden_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_hidden_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_selected_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_selected_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_see_through_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_see_through_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_use_tint_color_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_use_tint_color_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_disable_collision_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_disable_collision_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_radius(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_radius(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_length(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_length(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_attenuation_cutoff(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_attenuation_cutoff(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_projected_cube_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_projected_cube_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_radius(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_radius(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_falloff_exponent(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_falloff_exponent(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_attenuation_cutoff(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_attenuation_cutoff(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_spot_angle_deg(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_spot_angle_deg(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_projected2d_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_projected2d_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_set_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_material_sub_type(ulong handle, out Microsoft.Azure.RemoteRendering.MaterialType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_copy_from(ulong handle, ulong other);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_used_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_set_material(ulong handle, int idx, ulong material);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_mesh(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_bounds(ulong handle, out Microsoft.Azure.RemoteRendering.AABB3D result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_set_mesh(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_pbr_flags(ulong handle, out Microsoft.Azure.RemoteRendering.PbrMaterialFeatures result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_pbr_flags(ulong handle, Microsoft.Azure.RemoteRendering.PbrMaterialFeatures value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_tex_coord_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_tex_coord_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_tex_coord_offset(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_tex_coord_offset(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_albedo_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_albedo_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_albedo_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_albedo_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_pbr_vertex_alpha_mode(ulong handle, out Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_pbr_vertex_alpha_mode(ulong handle, Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_normal_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_normal_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_aoscale(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_aoscale(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_aomap(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_aomap(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_roughness(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_roughness(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_roughness_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_roughness_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_metalness(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_metalness(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_metalness_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_metalness_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_alpha_clip_threshold(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_alpha_clip_threshold(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_fade_out(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_fade_out(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_color_flags(ulong handle, out Microsoft.Azure.RemoteRendering.ColorMaterialFeatures result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_color_flags(ulong handle, Microsoft.Azure.RemoteRendering.ColorMaterialFeatures value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_albedo_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_albedo_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_albedo_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_albedo_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_tex_coord_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_tex_coord_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_tex_coord_offset(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_tex_coord_offset(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_color_transparency_mode(ulong handle, out Microsoft.Azure.RemoteRendering.ColorTransparencyMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_color_transparency_mode(ulong handle, Microsoft.Azure.RemoteRendering.ColorTransparencyMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_fade_out(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_fade_out(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_vertex_mix(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_vertex_mix(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_alpha_clip_threshold(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_alpha_clip_threshold(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_near_plane(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_near_plane(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_far_plane(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_far_plane(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_enable_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_enable_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_frame_count(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_frame_count(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_polygon_count(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_polygon_count(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_wireframe(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_wireframe(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_pulse_rate_hz(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_pulse_rate_hz(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_pulse_intensity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_pulse_intensity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_get_mode(ulong handle, out Microsoft.Azure.RemoteRendering.SingleSidedMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_set_mode(ulong handle, Microsoft.Azure.RemoteRendering.SingleSidedMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_get_sky_reflection_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_set_sky_reflection_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_highlighting(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_set_highlighting(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_api(ulong handle, out Microsoft.Azure.RemoteRendering.GraphicsApiType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_remote_focus_point(ulong handle, System.IntPtr coordinate_system, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity, out Microsoft.Azure.RemoteRendering.FocusPointResult result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_last_frame_statistics(ulong handle, out Microsoft.Azure.RemoteRendering.FrameStatistics stats, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_init_simulation(ulong handle, System.IntPtr d3d_device, System.IntPtr proxy_depth, System.IntPtr proxy_color, float refresh_rate, [MarshalAs(UnmanagedType.U1)] bool flip_blit_remote_frame_texture_vertically, [MarshalAs(UnmanagedType.U1)] bool flip_reproject_texture_vertically, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_deinit_simulation(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_update(ulong handle, Microsoft.Azure.RemoteRendering.SimulationUpdate update, out Microsoft.Azure.RemoteRendering.SimulationUpdate proxy_frame_update, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_blit_remote_frame_to_proxy(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_reproject_proxy(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_wmr_d3d11_blit_remote_frame(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_wmr_d3d11_update_user_coordinate_system(ulong handle, System.IntPtr coordinate_system, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_message_logged(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.LogHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_log_level(ulong handle, out Microsoft.Azure.RemoteRendering.LogLevel result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_log_level(ulong handle, Microsoft.Azure.RemoteRendering.LogLevel value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_model_from_sasasync(ulong handle, Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_model_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadModelParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_texture_from_sasasync(ulong handle, Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_texture_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_ray_cast_query_async(ulong handle, Microsoft.Azure.RemoteRendering.RayCastAbi cast, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_query_server_performance_assessment_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_create_entity(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_create_material(ulong handle, Microsoft.Azure.RemoteRendering.MaterialType type, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_create_component(ulong handle, Microsoft.Azure.RemoteRendering.ObjectType component_type, ulong owner, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_camera_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_sky_reflection_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_outline_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_zfighting_mitigation_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_single_sided_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_debug_rendering_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_update(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_updated(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.UpdatedHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_error_details(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result_message, [MarshalAs(UnmanagedType.LPStr)] out string result_requestCorrelationVector, [MarshalAs(UnmanagedType.LPStr)] out string result_responseCorrelationVector);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_handle_type(IntPtr handle, out Microsoft.Azure.RemoteRendering.HandleType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_handle_type_unsigned_long_long(ulong handle, out Microsoft.Azure.RemoteRendering.HandleType result);
    }

    // CODE STARTS HERE

    abstract class BasePrivateDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        protected abstract int InternalGetCount();
        protected abstract TKey InternalGetKey(int index);
        protected abstract TValue InternalGetItem(TKey key);
        protected abstract void InternalSetItem(TKey key, TValue value);
        protected abstract void InternalRemoveKey(TKey key);

        public TValue this[TKey key] { get { return InternalGetItem(key); } set { InternalSetItem(key, value); } }

        public ICollection<TKey> Keys { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).ToList().AsReadOnly(); } }

        public ICollection<TValue> Values { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).Select(k => InternalGetItem(k)).ToList().AsReadOnly(); } }

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public void Add(TKey key, TValue value)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                InternalSetItem(key, value);
                return;
            }
            throw new ArgumentException();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                TKey key = InternalGetKey(0);
                InternalRemoveKey(key);
            }
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            try
            {
                TValue value = InternalGetItem(item.Key);
                if (Comparer<TValue>.Default.Compare(value, item.Value) == 0)
                {
                    return true;
                }
                return false;
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
        }

        public bool ContainsKey(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            return true;
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public bool Remove(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            InternalRemoveKey(key);
            return true;
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            try
            {
                value = InternalGetItem(key);
                return true;
            }
            catch (KeyNotFoundException)
            {
                value = default(TValue);
                return false;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }
    }

    abstract class BasePrivateList<T> : IList<T>
    {
        protected abstract int InternalGetCount();
        protected abstract T InternalGetItem(int index);
        protected abstract void InternalSetItem(int index, T value);
        protected abstract void InternalRemoveItem(int index);

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public T this[int index] { get { return InternalGetItem(index); } set { InternalSetItem(index, value); } }

        public int IndexOf(T item)
        {
            int count = InternalGetCount();
            for (int i = 0; i < count; i++)
            {
                if (Comparer<T>.Default.Compare(item, InternalGetItem(i)) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        public void Insert(int index, T item)
        {
            InternalSetItem(index, item);
        }

        public void RemoveAt(int index)
        {
            InternalRemoveItem(index);
        }

        public void Add(T item)
        {
            InternalSetItem(InternalGetCount(), item);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                InternalRemoveItem(0);
            }
        }

        public bool Contains(T item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            for (int i = 0; i < Count; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public bool Remove(T item)
        {
            int index = IndexOf(item);
            if (index < 0) return false;
            InternalRemoveItem(index);
            return true;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }
    }

    static class Factories
    {
        internal static Microsoft.Azure.RemoteRendering.AsyncBase AsyncBaseFactory(IntPtr handle, bool transfer)
        {
            if (handle == IntPtr.Zero)
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type(handle, out result));
            Microsoft.Azure.RemoteRendering.AsyncBase result_object;
            switch (result)
            {
                case HandleType.BoundsQueryAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(handle, transfer);
                    break;
                case HandleType.AsyncBase:
                    result_object = new Microsoft.Azure.RemoteRendering.AsyncBase(handle, transfer);
                    break;
                case HandleType.MetadataQueryAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.MetadataQueryAsync(handle, transfer);
                    break;
                case HandleType.LoadModelAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.LoadModelAsync(handle, transfer);
                    break;
                case HandleType.LoadTextureAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.LoadTextureAsync(handle, transfer);
                    break;
                case HandleType.RaycastQueryAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.RaycastQueryAsync(handle, transfer);
                    break;
                case HandleType.PerformanceAssessmentAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync(handle, transfer);
                    break;
                case HandleType.BaseSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.BaseSessionAsync(handle, transfer);
                    break;
                case HandleType.SessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionAsync(handle, transfer);
                    break;
                case HandleType.CreateSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.CreateSessionAsync(handle, transfer);
                    break;
                case HandleType.ConnectToRuntimeAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync(handle, transfer);
                    break;
                case HandleType.ArrInspectorAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ArrInspectorAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesArrayAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(handle, transfer);
                    break;
                case HandleType.StartAssetConversionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(handle, transfer);
                    break;
                case HandleType.ConversionStatusAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.BaseSessionAsync BaseSessionAsyncFactory(IntPtr handle, bool transfer)
        {
            if (handle == IntPtr.Zero)
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type(handle, out result));
            Microsoft.Azure.RemoteRendering.BaseSessionAsync result_object;
            switch (result)
            {
                case HandleType.SessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionAsync(handle, transfer);
                    break;
                case HandleType.BaseSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.BaseSessionAsync(handle, transfer);
                    break;
                case HandleType.CreateSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.CreateSessionAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesArrayAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(handle, transfer);
                    break;
                case HandleType.StartAssetConversionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(handle, transfer);
                    break;
                case HandleType.ConversionStatusAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ObjectBase ObjectBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ObjectBase result_object;
            switch (result)
            {
                case HandleType.ComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ComponentBase(handle, transfer);
                    break;
                case HandleType.ObjectBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ObjectBase(handle, transfer);
                    break;
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.CutPlaneComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.CutPlaneComponent(handle, transfer);
                    break;
                case HandleType.HierarchicalStateOverrideComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent(handle, transfer);
                    break;
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                case HandleType.MeshComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.MeshComponent(handle, transfer);
                    break;
                case HandleType.Entity:
                    result_object = new Microsoft.Azure.RemoteRendering.Entity(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ComponentBase ComponentBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            switch (result)
            {
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.ComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ComponentBase(handle, transfer);
                    break;
                case HandleType.CutPlaneComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.CutPlaneComponent(handle, transfer);
                    break;
                case HandleType.HierarchicalStateOverrideComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent(handle, transfer);
                    break;
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                case HandleType.MeshComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.MeshComponent(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.LightComponentBase LightComponentBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.LightComponentBase result_object;
            switch (result)
            {
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ResourceBase ResourceBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ResourceBase result_object;
            switch (result)
            {
                case HandleType.Material:
                    result_object = new Microsoft.Azure.RemoteRendering.Material(handle, transfer);
                    break;
                case HandleType.ResourceBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ResourceBase(handle, transfer);
                    break;
                case HandleType.PbrMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.PbrMaterial(handle, transfer);
                    break;
                case HandleType.ColorMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.ColorMaterial(handle, transfer);
                    break;
                case HandleType.Mesh:
                    result_object = new Microsoft.Azure.RemoteRendering.Mesh(handle, transfer);
                    break;
                case HandleType.Texture:
                    result_object = new Microsoft.Azure.RemoteRendering.Texture(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.Material MaterialFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.Material result_object;
            switch (result)
            {
                case HandleType.PbrMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.PbrMaterial(handle, transfer);
                    break;
                case HandleType.Material:
                    result_object = new Microsoft.Azure.RemoteRendering.Material(handle, transfer);
                    break;
                case HandleType.ColorMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.ColorMaterial(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.GraphicsBinding GraphicsBindingFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.GraphicsBinding result_object;
            switch (result)
            {
                case HandleType.GraphicsBindingSimD3d11:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11(handle, transfer);
                    break;
                case HandleType.GraphicsBinding:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBinding(handle, transfer);
                    break;
                case HandleType.GraphicsBindingWmrD3d11:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBindingWmrD3d11(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

    }

    /// <summary>
    /// This struct is for platform specific utility functions.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PlatformUtils
    {
    }

    /// <summary>
    /// 2-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float2
    {
        public float x;

        public float y;

    }

    /// <summary>
    /// 3-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float3
    {
        public float x;

        public float y;

        public float z;

    }

    /// <summary>
    /// 4-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float4
    {
        public float x;

        public float y;

        public float z;

        public float w;

    }

    /// <summary>
    /// 3-component vector with double precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Double3
    {
        public double x;

        public double y;

        public double z;

    }

    /// <summary>
    /// 4-component color vector (red, green, blue, alpha) with single precision components.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Color4
    {
        public float r;

        public float g;

        public float b;

        public float a;

    }

    /// <summary>
    /// Single precision quaternion to describe an object rotation.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Quaternion
    {
        public float x;

        public float y;

        public float z;

        public float w;

    }

    /// <summary>
    /// 4x4 matrix based on single precision components.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Matrix4x4
    {
        public Microsoft.Azure.RemoteRendering.Float4 column0;

        public Microsoft.Azure.RemoteRendering.Float4 column1;

        public Microsoft.Azure.RemoteRendering.Float4 column2;

        public Microsoft.Azure.RemoteRendering.Float4 column3;

    }

    /// <summary>
    /// Axis aligned bounding box, based on double precision min and max position.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct AABB3D
    {
        /// <summary>
        /// Position of the minimum corner (double precision).
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 min;

        /// <summary>
        /// Position of the maximum corner (double precision).
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 max;

    }

    [StructLayout(LayoutKind.Sequential)]
    public partial struct Color4UbChannels
    {
        public byte r;

        public byte g;

        public byte b;

        public byte a;

    }

    /// <summary>
    /// 4-component color vector based on 8 bit components [0..255].
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public partial struct Color4Ub
    {
        [FieldOffset(0)]
        /// <summary>
        /// Interpret the color as r,g,b,a byte values.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4UbChannels channels;

        [FieldOffset(0)]
        /// <summary>
        /// Interpret the color as a single 32bit integer. Used for assignment or comparison.
        /// </summary>
        public int bytes;

    }

    /// <summary>
    /// Wrapper for a portable TimeSpan structure.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct ARRTimeSpan
    {
        /// <summary>
        /// Hour, 0 - 23
        /// </summary>
        public int hour;

        /// <summary>
        /// Minute 0 - 59
        /// </summary>
        public int minute;

        /// <summary>
        /// Second 0 - 59
        /// </summary>
        public int second;

    }

    /// <summary>
    /// Frame statistics to do client-side performance assessment. See GraphicsBinding.GetLastFrameStatistics.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct FrameStatistics
    {
        /// <summary>
        /// Time between the client's request for a new remote frame and the arrival of the requested frame.
        /// </summary>
        public float latencyPoseToReceive;

        /// <summary>
        /// Time between arrival of new frame and its actual usage.
        /// </summary>
        public float latencyReceiveToPresent;

        /// <summary>
        /// Gives the remaining latency until the finished frame is displayed.
        /// </summary>
        public float latencyPresentToDisplay;

        /// <summary>
        /// The time between subsequent calls to PresentFrame on the CPU. Values greater than the display duration (for example 16.6 ms on a 60-Hz client device) indicate issues caused by the client application not finishing its CPU workload in time.
        /// </summary>
        public float timeSinceLastPresent;

        /// <summary>
        /// Number of received frames in the last second that were used on the device more than once. Non-zero values indicate that frames had to be reprojected either due to network jitter or excessive server rendering time.
        /// </summary>
        public uint videoFrameReusedCount;

        /// <summary>
        /// Number of received frames in the last second that were decoded, but not shown on display because a newer frame has arrived. Non-zero values indicate that network jittering caused multiple frames to be delayed and then arrive on the client device together in a burst.
        /// </summary>
        public uint videoFramesSkipped;

        /// <summary>
        /// The number of frames received from the server in the last second.
        /// </summary>
        public uint videoFramesReceived;

        /// <summary>
        /// Very similar to videoFramesSkipped, but the reason for being discarded is that a frame came in so late that is cannot even be correlated with any pending pose anymore. If this happens, there is some severe network contention.
        /// </summary>
        public uint videoFramesDiscarded;

        /// <summary>
        /// Minimum amount of time between two consecutive frames arriving during the last second. Together with videoFrameMaxDelta, this range gives an indication of jitter caused either by the network or video codec.
        /// </summary>
        public float videoFrameMinDelta;

        /// <summary>
        /// Maximum amount of time between two consecutive frames arriving during the last second. Together with videoFrameMinDelta, this range gives an indication of jitter caused either by the network or video codec.
        /// </summary>
        public float videoFrameMaxDelta;

    }

    /// <summary>
    /// Helper struct for the PerformanceAssessment struct to describe a single performance value.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct PerformanceInformationAbi
    {
        /// <summary>
        /// Aggregated value to assess.
        /// </summary>
        public float aggregate;

        /// <summary>
        /// Rating value for the respective aggregate value.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceRating rating;

        public Microsoft.Azure.RemoteRendering.PerformanceInformation Convert()
        {
            return Microsoft.Azure.RemoteRendering.PerformanceInformationAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.PerformanceInformation Convert(Microsoft.Azure.RemoteRendering.PerformanceInformationAbi value)
        {
            Microsoft.Azure.RemoteRendering.PerformanceInformation result = new Microsoft.Azure.RemoteRendering.PerformanceInformation();

            result.aggregate = value.aggregate;
            result.rating = value.rating;

            return result;
        }
    }

    /// <summary>
    /// Helper struct for the PerformanceAssessment struct to describe a single performance value.
    /// </summary>
    public partial struct PerformanceInformation
    {
        /// <summary>
        /// Aggregated value to assess.
        /// </summary>
        public float aggregate;

        /// <summary>
        /// Rating value for the respective aggregate value.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceRating rating;

        internal Microsoft.Azure.RemoteRendering.PerformanceInformationAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.PerformanceInformation.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.PerformanceInformationAbi Convert(Microsoft.Azure.RemoteRendering.PerformanceInformation value)
        {
            Microsoft.Azure.RemoteRendering.PerformanceInformationAbi result = new Microsoft.Azure.RemoteRendering.PerformanceInformationAbi();

            result.aggregate = value.aggregate;
            result.rating = value.rating;

            return result;
        }
    }

    /// <summary>
    /// Performance assessment of Remote Rendering statistics, see GraphicsBinding::GetServerPerformanceAssessment.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct PerformanceAssessmentAbi
    {
        /// <summary>
        /// Average CPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi timeCPU;

        /// <summary>
        /// Average GPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi timeGPU;

        /// <summary>
        /// Total CPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi utilizationCPU;

        /// <summary>
        /// Total GPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi utilizationGPU;

        /// <summary>
        /// Total main memory utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi memoryCPU;

        /// <summary>
        /// Total dedicated video memory utilization in percent of the server GPU.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi memoryGPU;

        /// <summary>
        /// The approximate average roundtrip network latency in milliseconds. The value is computed by subtracting actual server rendering time from the latencyPoseToReceive value of FrameStatistics. While this approximation is not accurate, it gives some indication of the network latency isolated from the latency values computed on the client. See chapter "Server-side performance queries" in the general documentation for more detailed information.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi networkLatency;

        /// <summary>
        /// The number of triangles rendered in one frame. This number also includes the triangles that are culled later during rendering. That means, this number does not vary a lot across different camera positions, but the performance on the other hand may vary a lot, depending on the triangle culling rate.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformationAbi polygonsRendered;

        public Microsoft.Azure.RemoteRendering.PerformanceAssessment Convert()
        {
            return Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.PerformanceAssessment Convert(Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi value)
        {
            Microsoft.Azure.RemoteRendering.PerformanceAssessment result = new Microsoft.Azure.RemoteRendering.PerformanceAssessment();

            result.timeCPU = value.timeCPU.Convert();
            result.timeGPU = value.timeGPU.Convert();
            result.utilizationCPU = value.utilizationCPU.Convert();
            result.utilizationGPU = value.utilizationGPU.Convert();
            result.memoryCPU = value.memoryCPU.Convert();
            result.memoryGPU = value.memoryGPU.Convert();
            result.networkLatency = value.networkLatency.Convert();
            result.polygonsRendered = value.polygonsRendered.Convert();

            return result;
        }
    }

    /// <summary>
    /// Performance assessment of Remote Rendering statistics, see GraphicsBinding::GetServerPerformanceAssessment.
    /// </summary>
    public partial struct PerformanceAssessment
    {
        /// <summary>
        /// Average CPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation timeCPU;

        /// <summary>
        /// Average GPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation timeGPU;

        /// <summary>
        /// Total CPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation utilizationCPU;

        /// <summary>
        /// Total GPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation utilizationGPU;

        /// <summary>
        /// Total main memory utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation memoryCPU;

        /// <summary>
        /// Total dedicated video memory utilization in percent of the server GPU.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation memoryGPU;

        /// <summary>
        /// The approximate average roundtrip network latency in milliseconds. The value is computed by subtracting actual server rendering time from the latencyPoseToReceive value of FrameStatistics. While this approximation is not accurate, it gives some indication of the network latency isolated from the latency values computed on the client. See chapter "Server-side performance queries" in the general documentation for more detailed information.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation networkLatency;

        /// <summary>
        /// The number of triangles rendered in one frame. This number also includes the triangles that are culled later during rendering. That means, this number does not vary a lot across different camera positions, but the performance on the other hand may vary a lot, depending on the triangle culling rate.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation polygonsRendered;

        internal Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.PerformanceAssessment.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi Convert(Microsoft.Azure.RemoteRendering.PerformanceAssessment value)
        {
            Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi result = new Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi();

            result.timeCPU = value.timeCPU.Convert();
            result.timeGPU = value.timeGPU.Convert();
            result.utilizationCPU = value.utilizationCPU.Convert();
            result.utilizationGPU = value.utilizationGPU.Convert();
            result.memoryCPU = value.memoryCPU.Convert();
            result.memoryGPU = value.memoryGPU.Convert();
            result.networkLatency = value.networkLatency.Convert();
            result.polygonsRendered = value.polygonsRendered.Convert();

            return result;
        }
    }

    /// <summary>
    /// Update structure that must be filled out and passed to the Update function of the GraphicsBindingSimD3d11 graphics binding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SimulationUpdate
    {
        /// <summary>
        /// Frame counter, should be incremented every frame.
        /// </summary>
        public uint frameId;

        /// <summary>
        /// Distance (in units) to the camera's near clipping plane.
        /// </summary>
        public float nearPlaneDistance;

        /// <summary>
        /// Distance (in units) to the camera's far clipping plane.
        /// </summary>
        public float farPlaneDistance;

        /// <summary>
        /// Video resolution width.
        /// </summary>
        public int renderTargetWidth;

        /// <summary>
        /// Video resolution height.
        /// </summary>
        public int renderTargetHeight;

        /// <summary>
        /// Camera perspective projection matrix.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Matrix4x4 projection;

        /// <summary>
        /// Camera transform matrix (translation and rotation).
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Matrix4x4 viewTransform;

    }

    /// <summary>
    /// A raycast can be performed with RemoteManager.RayCastQueryAsync to query the server for objects along a line.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RayCastAbi
    {
        /// <summary>
        /// Start position for the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 StartPos;

        /// <summary>
        /// End position of the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 EndPos;

        /// <summary>
        /// Raycast hit collection type.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HitCollectionPolicy HitCollection;

        /// <summary>
        /// Maximum collected hits.
        /// </summary>
        public uint MaxHits;

        /// <summary>
        /// Reserved for future use.
        /// </summary>
        public uint CollisionMask;

        public Microsoft.Azure.RemoteRendering.RayCast Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCastAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RayCast Convert(Microsoft.Azure.RemoteRendering.RayCastAbi value)
        {
            Microsoft.Azure.RemoteRendering.RayCast result = new Microsoft.Azure.RemoteRendering.RayCast();

            result.StartPos = value.StartPos;
            result.EndPos = value.EndPos;
            result.HitCollection = value.HitCollection;
            result.MaxHits = value.MaxHits;
            result.CollisionMask = value.CollisionMask;

            return result;
        }
    }

    /// <summary>
    /// A raycast can be performed with RemoteManager.RayCastQueryAsync to query the server for objects along a line.
    /// </summary>
    public partial struct RayCast
    {
        /// <summary>
        /// Start position for the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 StartPos;

        /// <summary>
        /// End position of the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 EndPos;

        /// <summary>
        /// Raycast hit collection type.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HitCollectionPolicy HitCollection;

        /// <summary>
        /// Maximum collected hits.
        /// </summary>
        public uint MaxHits;

        /// <summary>
        /// Reserved for future use.
        /// </summary>
        public uint CollisionMask;

        internal Microsoft.Azure.RemoteRendering.RayCastAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCast.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RayCastAbi Convert(Microsoft.Azure.RemoteRendering.RayCast value)
        {
            Microsoft.Azure.RemoteRendering.RayCastAbi result = new Microsoft.Azure.RemoteRendering.RayCastAbi();

            result.StartPos = value.StartPos;
            result.EndPos = value.EndPos;
            result.HitCollection = value.HitCollection;
            result.MaxHits = value.MaxHits;
            result.CollisionMask = value.CollisionMask;

            return result;
        }
    }

    /// <summary>
    /// RayCastHit is generated by performing an RemoteManager.RayCastQueryAsync.  It contains information about an intersected object.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RayCastHitAbi
    {
        /// <summary>
        /// Intersected object.
        /// </summary>
        public ulong HitObject;

        /// <summary>
        /// Sub Part Id of intersected object. This can be used to get an intersected Material by querying for a MeshComponent on the intersected object and getting MeshComponent.UsedMaterials[SubPartId].
        /// </summary>
        public int SubPartId;

        /// <summary>
        /// Hit position on HitObject in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 HitPosition;

        /// <summary>
        /// Hit normal on HitObject in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float3 HitNormal;

        /// <summary>
        /// Distance along the ray to the hit. This is in world units such that Normalize(End - Start) * DistanceToHit == HitPosition.
        /// </summary>
        public double DistanceToHit;

        public Microsoft.Azure.RemoteRendering.RayCastHit Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCastHitAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RayCastHit Convert(Microsoft.Azure.RemoteRendering.RayCastHitAbi value)
        {
            Microsoft.Azure.RemoteRendering.RayCastHit result = new Microsoft.Azure.RemoteRendering.RayCastHit();

            result.HitObject = value.HitObject != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.HitObject, false) : null;
            result.SubPartId = value.SubPartId;
            result.HitPosition = value.HitPosition;
            result.HitNormal = value.HitNormal;
            result.DistanceToHit = value.DistanceToHit;

            return result;
        }
    }

    /// <summary>
    /// RayCastHit is generated by performing an RemoteManager.RayCastQueryAsync.  It contains information about an intersected object.
    /// </summary>
    public partial struct RayCastHit
    {
        /// <summary>
        /// Intersected object.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity HitObject;

        /// <summary>
        /// Sub Part Id of intersected object. This can be used to get an intersected Material by querying for a MeshComponent on the intersected object and getting MeshComponent.UsedMaterials[SubPartId].
        /// </summary>
        public int SubPartId;

        /// <summary>
        /// Hit position on HitObject in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 HitPosition;

        /// <summary>
        /// Hit normal on HitObject in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float3 HitNormal;

        /// <summary>
        /// Distance along the ray to the hit. This is in world units such that Normalize(End - Start) * DistanceToHit == HitPosition.
        /// </summary>
        public double DistanceToHit;

        internal Microsoft.Azure.RemoteRendering.RayCastHitAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCastHit.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RayCastHitAbi Convert(Microsoft.Azure.RemoteRendering.RayCastHit value)
        {
            Microsoft.Azure.RemoteRendering.RayCastHitAbi result = new Microsoft.Azure.RemoteRendering.RayCastHitAbi();

            result.HitObject = value.HitObject?.handle ?? default(ulong);
            result.SubPartId = value.SubPartId;
            result.HitPosition = value.HitPosition;
            result.HitNormal = value.HitNormal;
            result.DistanceToHit = value.DistanceToHit;

            return result;
        }
    }

    /// <summary>
    /// The account information and domain to associate an AzureFrontend instance with.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal class AzureFrontendAccountInfoAbi
    {
        /// <summary>
        /// Domain that will be used to generate sessions for the Azure Remote Rendering service. The domain is of the form [region].mixedreality.azure.com. Region should be selected based on the region currently closest to the user. For example, westus2.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountDomain;

        /// <summary>
        /// Account-level ID for the Azure Remote Rendering service.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountId;

        /// <summary>
        /// Account-level key for the Azure Remote Rendering service. Among AccountKey, AccessToken and AuthenticationToken, only one needs to be set.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountKey;

        /// <summary>
        /// Authentication token for Azure Active Directory (AAD). Among AccountKey, AccessToken and AuthenticationToken, only one needs to be set.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AuthenticationToken;

        /// <summary>
        /// Access token for the Azure Remote Rendering service. Among AccountKey, AccessToken and AuthenticationToken, only one needs to be set.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccessToken;

        public Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo Convert()
        {
            return Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo Convert(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi value)
        {
            Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo result = new Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo();

            result.AccountDomain = value.AccountDomain;
            result.AccountId = value.AccountId;
            result.AccountKey = value.AccountKey;
            result.AuthenticationToken = value.AuthenticationToken;
            result.AccessToken = value.AccessToken;

            return result;
        }
    }

    /// <summary>
    /// The account information and domain to associate an AzureFrontend instance with.
    /// </summary>
    public partial class AzureFrontendAccountInfo
    {
        /// <summary>
        /// Domain that will be used to generate sessions for the Azure Remote Rendering service. The domain is of the form [region].mixedreality.azure.com. Region should be selected based on the region currently closest to the user. For example, westus2.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// </summary>
        public string AccountDomain;

        /// <summary>
        /// Account-level ID for the Azure Remote Rendering service.
        /// </summary>
        public string AccountId;

        /// <summary>
        /// Account-level key for the Azure Remote Rendering service. Among AccountKey, AccessToken and AuthenticationToken, only one needs to be set.
        /// </summary>
        public string AccountKey;

        /// <summary>
        /// Authentication token for Azure Active Directory (AAD). Among AccountKey, AccessToken and AuthenticationToken, only one needs to be set.
        /// </summary>
        public string AuthenticationToken;

        /// <summary>
        /// Access token for the Azure Remote Rendering service. Among AccountKey, AccessToken and AuthenticationToken, only one needs to be set.
        /// </summary>
        public string AccessToken;

        internal Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi Convert(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo value)
        {
            Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi result = new Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi();

            result.AccountDomain = value.AccountDomain;
            result.AccountId = value.AccountId;
            result.AccountKey = value.AccountKey;
            result.AuthenticationToken = value.AuthenticationToken;
            result.AccessToken = value.AccessToken;

            return result;
        }
    }

    /// <summary>
    /// Parameters for connecting to a runtime session.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct ConnectToRuntimeParamsAbi
    {
        /// <summary>
        /// Mode for the rendering session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ServiceRenderMode mode;

        /// <summary>
        /// Internal flag used to ignore SSL certification. Should be set to false (default) for most applications.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)]
        public bool ignoreCertificateValidation;

        public Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams Convert(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams result = new Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams();

            result.mode = value.mode;
            result.ignoreCertificateValidation = value.ignoreCertificateValidation;

            return result;
        }
    }

    /// <summary>
    /// Parameters for connecting to a runtime session.
    /// </summary>
    public partial struct ConnectToRuntimeParams
    {
        /// <summary>
        /// Mode for the rendering session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ServiceRenderMode mode;

        /// <summary>
        /// Internal flag used to ignore SSL certification. Should be set to false (default) for most applications.
        /// </summary>
        public bool ignoreCertificateValidation;

        internal Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi Convert(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams value)
        {
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi result = new Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi();

            result.mode = value.mode;
            result.ignoreCertificateValidation = value.ignoreCertificateValidation;

            return result;
        }
    }

    /// <summary>
    /// Parameters for converting an asset.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionParamsAbi
    {
        /// <summary>
        /// Model name.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ModelName;

        /// <summary>
        /// Input container (public) URIs or URIs with embedded SAS token.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ModelUrl;

        /// <summary>
        /// Output container SAS url.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AssetContainerUrl;

        /// <summary>
        /// Optional
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string RenderingSettings;

        /// <summary>
        /// Optional
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string MaterialOverrides;

        public Microsoft.Azure.RemoteRendering.AssetConversionParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionParams result = new Microsoft.Azure.RemoteRendering.AssetConversionParams();

            result.ModelName = value.ModelName;
            result.ModelUrl = value.ModelUrl;
            result.AssetContainerUrl = value.AssetContainerUrl;
            result.RenderingSettings = value.RenderingSettings;
            result.MaterialOverrides = value.MaterialOverrides;

            return result;
        }
    }

    /// <summary>
    /// Parameters for converting an asset.
    /// </summary>
    public partial struct AssetConversionParams
    {
        /// <summary>
        /// Model name.
        /// </summary>
        public string ModelName;

        /// <summary>
        /// Input container (public) URIs or URIs with embedded SAS token.
        /// </summary>
        public string ModelUrl;

        /// <summary>
        /// Output container SAS url.
        /// </summary>
        public string AssetContainerUrl;

        /// <summary>
        /// Optional
        /// </summary>
        public string RenderingSettings;

        /// <summary>
        /// Optional
        /// </summary>
        public string MaterialOverrides;

        internal Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi();

            result.ModelName = value.ModelName;
            result.ModelUrl = value.ModelUrl;
            result.AssetContainerUrl = value.AssetContainerUrl;
            result.RenderingSettings = value.RenderingSettings;
            result.MaterialOverrides = value.MaterialOverrides;

            return result;
        }
    }

    /// <summary>
    /// Parameters for referencing a blob container for asset conversion.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionBlobContainerAbi
    {
        /// <summary>
        /// Storage account to load from.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageAccountName;

        /// <summary>
        /// Blob container in storage account to load from.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string BlobContainerName;

        /// <summary>
        /// Folder containing the asset in the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string FolderPath;

        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer Convert(Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer result = new Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.FolderPath = value.FolderPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for referencing a blob container for asset conversion.
    /// </summary>
    public partial struct AssetConversionBlobContainer
    {
        /// <summary>
        /// Storage account to load from.
        /// </summary>
        public string StorageAccountName;

        /// <summary>
        /// Blob container in storage account to load from.
        /// </summary>
        public string BlobContainerName;

        /// <summary>
        /// Folder containing the asset in the blob container.
        /// </summary>
        public string FolderPath;

        internal Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.FolderPath = value.FolderPath;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionInputParamsAbi
    {
        /// <summary>
        /// Location of the input container containing the asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Input asset path.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string InputAssetPath;

        public Microsoft.Azure.RemoteRendering.AssetConversionInputParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionInputParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputParams result = new Microsoft.Azure.RemoteRendering.AssetConversionInputParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    public partial struct AssetConversionInputParams
    {
        /// <summary>
        /// Location of the input container containing the asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Input asset path.
        /// </summary>
        public string InputAssetPath;

        internal Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionOutputParamsAbi
    {
        /// <summary>
        /// Location of the output container to place the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Output asset path.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputAssetPath;

        public Microsoft.Azure.RemoteRendering.AssetConversionOutputParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionOutputParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputParams result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    public partial struct AssetConversionOutputParams
    {
        /// <summary>
        /// Location of the output container to place the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Output asset path.
        /// </summary>
        public string OutputAssetPath;

        internal Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionInputSasParamsAbi
    {
        /// <summary>
        /// Location of the input container containing the asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Output asset path.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string InputAssetPath;

        /// <summary>
        /// SAS token for read access to the input container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ContainerReadListSas;

        public Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams result = new Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;
            result.ContainerReadListSas = value.ContainerReadListSas;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    public partial struct AssetConversionInputSasParams
    {
        /// <summary>
        /// Location of the input container containing the asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Output asset path.
        /// </summary>
        public string InputAssetPath;

        /// <summary>
        /// SAS token for read access to the input container.
        /// </summary>
        public string ContainerReadListSas;

        internal Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;
            result.ContainerReadListSas = value.ContainerReadListSas;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionOutputSasParamsAbi
    {
        /// <summary>
        /// Location of the output container to place the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Output asset path.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputAssetPath;

        /// <summary>
        /// SAS Token granting write access to the output container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ContainerWriteSas;

        public Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;
            result.ContainerWriteSas = value.ContainerWriteSas;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    public partial struct AssetConversionOutputSasParams
    {
        /// <summary>
        /// Location of the output container to place the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Output asset path.
        /// </summary>
        public string OutputAssetPath;

        /// <summary>
        /// SAS Token granting write access to the output container.
        /// </summary>
        public string ContainerWriteSas;

        internal Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;
            result.ContainerWriteSas = value.ContainerWriteSas;

            return result;
        }
    }

    /// <summary>
    /// Parameters for creating a rendering session.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionCreationParamsAbi
    {
        /// <summary>
        /// A timeout value when the VM will be decommissioned automatically. The expiration time is VM start time + MaxLease.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        /// <summary>
        /// The VM size.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        public Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams();

            result.MaxLease = value.MaxLease;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Parameters for creating a rendering session.
    /// </summary>
    public partial struct RenderingSessionCreationParams
    {
        /// <summary>
        /// A timeout value when the VM will be decommissioned automatically. The expiration time is VM start time + MaxLease.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        /// <summary>
        /// The VM size.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi();

            result.MaxLease = value.MaxLease;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Unsafe parameters for creating a rendering session. Internal dev use only.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionCreationParamsUnsafeAbi
    {
        /// <summary>
        /// A timeout value when the VM will be decommissioned automatically. The expiration time is VM start time + MaxLease.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        /// <summary>
        /// VM Size as it would be embedded into the json payload to the underlying RESTful API.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Size;

        public Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe();

            result.MaxLease = value.MaxLease;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Unsafe parameters for creating a rendering session. Internal dev use only.
    /// </summary>
    public partial struct RenderingSessionCreationParamsUnsafe
    {
        /// <summary>
        /// A timeout value when the VM will be decommissioned automatically. The expiration time is VM start time + MaxLease.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        /// <summary>
        /// VM Size as it would be embedded into the json payload to the underlying RESTful API.
        /// </summary>
        public string Size;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi();

            result.MaxLease = value.MaxLease;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Parameters for updating a rendering session.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct RenderingSessionUpdateParams
    {
        /// <summary>
        /// A timeout value when the VM will be decommissioned automatically. The expiration time is VM start time + MaxLease.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

    }

    /// <summary>
    /// Extended return value information for AzureSession and AzureFrontend async calls.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct SessionGeneralContextAbi
    {
        /// <summary>
        /// Error information if the session operation was unsuccessful.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Result;

        /// <summary>
        /// HTTP response code.
        /// </summary>
        public uint HttpResponseCode;

        /// <summary>
        /// Additional error information might be provided through this string, dependeing on the error code.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ErrorMessage;

        /// <summary>
        /// Request correlation vector, as reported by the service.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string RequestCorrelationVector;

        /// <summary>
        /// Response correlation vector, as reported by the service.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ResponseCorrelationVector;

        public Microsoft.Azure.RemoteRendering.SessionGeneralContext Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.SessionGeneralContext Convert(Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi value)
        {
            Microsoft.Azure.RemoteRendering.SessionGeneralContext result = new Microsoft.Azure.RemoteRendering.SessionGeneralContext();

            result.Result = value.Result;
            result.HttpResponseCode = value.HttpResponseCode;
            result.ErrorMessage = value.ErrorMessage;
            result.RequestCorrelationVector = value.RequestCorrelationVector;
            result.ResponseCorrelationVector = value.ResponseCorrelationVector;

            return result;
        }
    }

    /// <summary>
    /// Extended return value information for AzureSession and AzureFrontend async calls.
    /// </summary>
    public partial struct SessionGeneralContext
    {
        /// <summary>
        /// Error information if the session operation was unsuccessful.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Result;

        /// <summary>
        /// HTTP response code.
        /// </summary>
        public uint HttpResponseCode;

        /// <summary>
        /// Additional error information might be provided through this string, dependeing on the error code.
        /// </summary>
        public string ErrorMessage;

        /// <summary>
        /// Request correlation vector, as reported by the service.
        /// </summary>
        public string RequestCorrelationVector;

        /// <summary>
        /// Response correlation vector, as reported by the service.
        /// </summary>
        public string ResponseCorrelationVector;

        internal Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionGeneralContext.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi Convert(Microsoft.Azure.RemoteRendering.SessionGeneralContext value)
        {
            Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result = new Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi();

            result.Result = value.Result;
            result.HttpResponseCode = value.HttpResponseCode;
            result.ErrorMessage = value.ErrorMessage;
            result.RequestCorrelationVector = value.RequestCorrelationVector;
            result.ResponseCorrelationVector = value.ResponseCorrelationVector;

            return result;
        }
    }

    /// <summary>
    /// Properties for a rendering session, queried through AzureSession.GetRenderingSessionPropertiesAsync().
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionPropertiesAbi
    {
        /// <summary>
        /// Session status.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionStatus Status;

        /// <summary>
        /// Session size.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        /// <summary>
        /// Session hostname.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Hostname;

        /// <summary>
        /// Session message. If the Session Status is Error or Expired, the message will contain more information.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Message;

        /// <summary>
        /// String representation of the VM size. Used for internal prototyping.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string SizeString;

        /// <summary>
        /// Session UUID.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Id;

        /// <summary>
        /// Elapsed time.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan ElapsedTime;

        /// <summary>
        /// Maximum lease time for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionProperties Convert(Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionProperties result = new Microsoft.Azure.RemoteRendering.RenderingSessionProperties();

            result.Status = value.Status;
            result.Size = value.Size;
            result.Hostname = value.Hostname;
            result.Message = value.Message;
            result.SizeString = value.SizeString;
            result.Id = value.Id;
            result.ElapsedTime = value.ElapsedTime;
            result.MaxLease = value.MaxLease;

            return result;
        }
    }

    /// <summary>
    /// Properties for a rendering session, queried through AzureSession.GetRenderingSessionPropertiesAsync().
    /// </summary>
    public partial struct RenderingSessionProperties
    {
        /// <summary>
        /// Session status.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionStatus Status;

        /// <summary>
        /// Session size.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        /// <summary>
        /// Session hostname.
        /// </summary>
        public string Hostname;

        /// <summary>
        /// Session message. If the Session Status is Error or Expired, the message will contain more information.
        /// </summary>
        public string Message;

        /// <summary>
        /// String representation of the VM size. Used for internal prototyping.
        /// </summary>
        public string SizeString;

        /// <summary>
        /// Session UUID.
        /// </summary>
        public string Id;

        /// <summary>
        /// Elapsed time.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan ElapsedTime;

        /// <summary>
        /// Maximum lease time for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionProperties.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionProperties value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi();

            result.Status = value.Status;
            result.Size = value.Size;
            result.Hostname = value.Hostname;
            result.Message = value.Message;
            result.SizeString = value.SizeString;
            result.Id = value.Id;
            result.ElapsedTime = value.ElapsedTime;
            result.MaxLease = value.MaxLease;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading from blobstore.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadFromBlobParamsAbi
    {
        /// <summary>
        /// Storage account to load from.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageAccountName;

        /// <summary>
        /// Blob container in storage account to load from.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string BlobContainerName;

        /// <summary>
        /// Path to the asset in the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AssetPath;

        public Microsoft.Azure.RemoteRendering.LoadFromBlobParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadFromBlobParams Convert(Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadFromBlobParams result = new Microsoft.Azure.RemoteRendering.LoadFromBlobParams();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.AssetPath = value.AssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading from blobstore.
    /// </summary>
    public partial struct LoadFromBlobParams
    {
        /// <summary>
        /// Storage account to load from.
        /// </summary>
        public string StorageAccountName;

        /// <summary>
        /// Blob container in storage account to load from.
        /// </summary>
        public string BlobContainerName;

        /// <summary>
        /// Path to the asset in the blob container.
        /// </summary>
        public string AssetPath;

        internal Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadFromBlobParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadFromBlobParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.AssetPath = value.AssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadModelFromSASParamsAbi
    {
        /// <summary>
        /// URL for the model.  Either builtin:// or a URL pointing at a converted model. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ModelUrl;

        /// <summary>
        /// Optional parent of the model.  At initialization, the loaded model will either be parented to Parent or, if Parent is set to null, to the global scenegraph.
        /// </summary>
        public ulong Parent;

        public Microsoft.Azure.RemoteRendering.LoadModelFromSASParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadModelFromSASParams Convert(Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSASParams result = new Microsoft.Azure.RemoteRendering.LoadModelFromSASParams();

            result.ModelUrl = value.ModelUrl;
            result.Parent = value.Parent != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.Parent, false) : null;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model.
    /// </summary>
    public partial struct LoadModelFromSASParams
    {
        /// <summary>
        /// URL for the model.  Either builtin:// or a URL pointing at a converted model. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </summary>
        public string ModelUrl;

        /// <summary>
        /// Optional parent of the model.  At initialization, the loaded model will either be parented to Parent or, if Parent is set to null, to the global scenegraph.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity Parent;

        internal Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelFromSASParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi();

            result.ModelUrl = value.ModelUrl;
            result.Parent = value.Parent?.handle ?? default(ulong);

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model from blob storage.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadModelParamsAbi
    {
        /// <summary>
        /// Blob storage location of the model.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Blob;

        /// <summary>
        /// Optional parent of the model.  At initialization, the loaded model will either be parented to Parent or, if Parent is set to null, to the global scenegraph.
        /// </summary>
        public ulong Parent;

        public Microsoft.Azure.RemoteRendering.LoadModelParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadModelParams Convert(Microsoft.Azure.RemoteRendering.LoadModelParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelParams result = new Microsoft.Azure.RemoteRendering.LoadModelParams();

            result.Blob = value.Blob.Convert();
            result.Parent = value.Parent != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.Parent, false) : null;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model from blob storage.
    /// </summary>
    public partial struct LoadModelParams
    {
        /// <summary>
        /// Blob storage location of the model.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParams Blob;

        /// <summary>
        /// Optional parent of the model.  At initialization, the loaded model will either be parented to Parent or, if Parent is set to null, to the global scenegraph.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity Parent;

        internal Microsoft.Azure.RemoteRendering.LoadModelParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadModelParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadModelParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadModelParamsAbi();

            result.Blob = value.Blob.Convert();
            result.Parent = value.Parent?.handle ?? default(ulong);

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadTextureFromSASParamsAbi
    {
        /// <summary>
        /// URL for the texture.  Either builtin:// or a URL pointing at a converted texture. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string TextureUrl;

        /// <summary>
        /// Type of the texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        public Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams Convert(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams result = new Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams();

            result.TextureUrl = value.TextureUrl;
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    public partial struct LoadTextureFromSASParams
    {
        /// <summary>
        /// URL for the texture.  Either builtin:// or a URL pointing at a converted texture. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </summary>
        public string TextureUrl;

        /// <summary>
        /// Type of the texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        internal Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi();

            result.TextureUrl = value.TextureUrl;
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadTextureParamsAbi
    {
        /// <summary>
        /// Blob storage location of the texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Blob;

        /// <summary>
        /// Type of the texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        public Microsoft.Azure.RemoteRendering.LoadTextureParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadTextureParams Convert(Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureParams result = new Microsoft.Azure.RemoteRendering.LoadTextureParams();

            result.Blob = value.Blob.Convert();
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    public partial struct LoadTextureParams
    {
        /// <summary>
        /// Blob storage location of the texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParams Blob;

        /// <summary>
        /// Type of the texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        internal Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadTextureParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi();

            result.Blob = value.Blob.Convert();
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Initialization structure for remote rendering runtime.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RemoteRenderingInitializationAbi
    {
        /// <summary>
        /// Select the connection type for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectionType connectionType;

        /// <summary>
        /// Select the graphics binding to be used for rendering.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType graphicsApi;

        /// <summary>
        /// Right vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis right;

        /// <summary>
        /// Up vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis up;

        /// <summary>
        /// Forward vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis forward;

        /// <summary>
        /// How many units in the client's coordinate system make up one meter.
        /// </summary>
        public float unitsPerMeter;

        /// <summary>
        /// The name (and version) of the client tool.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string toolId;

        public Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization Convert()
        {
            return Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization Convert(Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi value)
        {
            Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization result = new Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization();

            result.connectionType = value.connectionType;
            result.graphicsApi = value.graphicsApi;
            result.right = value.right;
            result.up = value.up;
            result.forward = value.forward;
            result.unitsPerMeter = value.unitsPerMeter;
            result.toolId = value.toolId;

            return result;
        }
    }

    /// <summary>
    /// Initialization structure for remote rendering runtime.
    /// </summary>
    public partial struct RemoteRenderingInitialization
    {
        /// <summary>
        /// Select the connection type for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectionType connectionType;

        /// <summary>
        /// Select the graphics binding to be used for rendering.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType graphicsApi;

        /// <summary>
        /// Right vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis right;

        /// <summary>
        /// Up vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis up;

        /// <summary>
        /// Forward vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis forward;

        /// <summary>
        /// How many units in the client's coordinate system make up one meter.
        /// </summary>
        public float unitsPerMeter;

        /// <summary>
        /// The name (and version) of the client tool.
        /// </summary>
        public string toolId;

        internal Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi Convert(Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization value)
        {
            Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi result = new Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi();

            result.connectionType = value.connectionType;
            result.graphicsApi = value.graphicsApi;
            result.right = value.right;
            result.up = value.up;
            result.forward = value.forward;
            result.unitsPerMeter = value.unitsPerMeter;
            result.toolId = value.toolId;

            return result;
        }
    }

    public enum Result : int
    {
        /// <summary>
        /// General return values start.
        /// </summary>
        CoreReturnValueStart = -1,
        Success = 0,
        Fail = 1,
        Cancelled = 2,
        InvalidParam = 3,
        InvalidType = 4,
        BufferTooSmall = 5,
        NoConnection = 6,
        ApiUnavailable = 7,
        AlreadyInitialized = 8,
        AlreadyDeinitialized = 9,
        StringTooLong = 10,
        IndexOutOfRange = 11,
        InProgress = 12,
        NotInitialized = 13,
        CoreReturnValueLast = 14,
        CoreReturnValueEnd = 200,
        LoadFileReturnValueStart = 299,
        FileNotFound = 300,
        InvalidVersion = 301,
        IncompatibleVersion = 302,
        FailedToOpenFile = 303,
        FileDownloadFailed = 304,
        ExceedsMemoryLimit = 305,
        LoadFileReturnValueLast = 306,
        LoadFileReturnValueEnd = 500,
        ObjectReturnValueStart = 599,
        InvalidId = 600,
        InvalidParentId = 601,
        AlreadyExists = 602,
        CyclicReference = 603,
        ObjectLocked = 604,
        ObjectReturnValueLast = 605,
        ObjectReturnValueEnd = 800,
        ConnectionReturnValueStart = 899,
        NoServerCertificate = 900,
        HandshakePortBusy = 901,
        HandshakeUnreachable = 902,
        HandshakeConnectionFailed = 903,
        AuthenticationFailed = 904,
        RemotingVersionMismatch = 905,
        IncompatibleTransportProtocols = 906,
        HandshakeFailed = 907,
        TransportPortBusy = 908,
        TransportUnreachable = 909,
        TransportConnectionFailed = 910,
        ProtocolVersionMismatch = 911,
        ProtocolError = 912,
        VideoCodecNotAvailable = 913,
        ConnectionLost = 914,
        DeviceLost = 915,
        DisconnectRequest = 916,
        Timeout = 917,
        AlreadyConnected = 918,
        ArrVersionMismatch = 919,
        HandshakeNetworkUnreachable = 920,
        HandshakeConnectionRefused = 921,
        VideoFormatNotAvailable = 922,
        PeerDisconnectRequest = 923,
        PeerDisconnectTimeout = 924,
        ConnectionReturnValueLast = 925,
        ConnectionReturnValueEnd = 1100,
        ManagerReturnValueStart = 1199,
        InvalidToolId = 1200,
        ManagerAlreadyCreated = 1201,
        ManagerNotCreatedYet = 1202,
        OtherSessionConnected = 1203,
        BadStateTransition = 1204,
        ManagerReturnValueLast = 1205,
        ManagerReturnValueEnd = 1400,
        SessionReturnValueStart = 1499,
        InvalidToken = 1500,
        InvalidUrl = 1501,
        SessionReturnValueLast = 1502,
        SessionReturnValueEnd = 1700,
    }

    public enum GraphicsApiType : int
    {
        Headless = 0,
        SimD3D11 = 1,
        WmrD3D11 = 2,
        Count = 3,
    }

    public enum MaterialType : int
    {
        Pbr = 0,
        Color = 1,
    }

    public enum LogLevel : int
    {
        None = 0,
        Error = 1,
        Warning = 2,
        Information = 3,
        Debug = 4,
        Count = 5,
    }

    public enum Axis : int
    {
        X = 0,
        X_Neg = 1,
        Y = 2,
        Y_Neg = 3,
        Z = 4,
        Z_Neg = 5,
    }

    public enum FocusPointResult : int
    {
        Invalid = 0,
        Fallback = 1,
        Valid = 2,
    }

    public enum SingleSidedMode : int
    {
        Normal = 0,
        DynamicDoubleSiding = 1,
        AlwaysDoubleSided = 2,
    }

    public enum HierarchicalEnableState : int
    {
        /// <summary>
        /// The feature is disabled on this hierarchy level.
        /// </summary>
        ForceOff = 0,
        /// <summary>
        /// The feature is enabled on this hierarchy level.
        /// </summary>
        ForceOn = 1,
        /// <summary>
        /// The feature's enabled state is inherited from the parent.
        /// </summary>
        InheritFromParent = 2,
    }

    public enum ConnectionStatus : int
    {
        /// <summary>
        /// The server is disconnected.
        /// </summary>
        Disconnected = 0,
        /// <summary>
        /// The client is currently connecting to the server.
        /// </summary>
        Connecting = 1,
        /// <summary>
        /// The server is connected.
        /// </summary>
        Connected = 2,
    }

    public enum ConversionSessionStatus : int
    {
        /// <summary>
        /// The session is in unknown state.
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// The session has been successfully created.
        /// </summary>
        Created = 1,
        /// <summary>
        /// The conversion is running.
        /// </summary>
        Running = 2,
        /// <summary>
        /// The conversion has been aborted.
        /// </summary>
        Aborted = 3,
        /// <summary>
        /// The conversion has ended with an error.
        /// </summary>
        Failure = 4,
        /// <summary>
        /// The conversion has ended with success.
        /// </summary>
        Success = 5,
    }

    public enum RenderingSessionStatus : int
    {
        /// <summary>
        /// The session is in unknown state.
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// The session is starting.
        /// </summary>
        Starting = 1,
        /// <summary>
        /// The session is ready for rendering.
        /// </summary>
        Ready = 2,
        /// <summary>
        /// The session has stopped.
        /// </summary>
        Stopped = 3,
        /// <summary>
        /// The session has expired, e.g. through its lease time.
        /// </summary>
        Expired = 4,
        /// <summary>
        /// The session has aborted and is in error state.
        /// </summary>
        Error = 5,
    }

    public enum ObjectType : int
    {
        /// <summary>
        /// Invalid object type.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// Internal use
        /// </summary>
        FirstBasicObject = 1,
        /// <summary>
        /// Object is an entity.
        /// </summary>
        Entity = 1,
        /// <summary>
        /// Object is a mesh resource.
        /// </summary>
        Mesh = 2,
        /// <summary>
        /// Object is a material resource.
        /// </summary>
        Material = 3,
        /// <summary>
        /// Object is a texture resource.
        /// </summary>
        Texture = 4,
        /// <summary>
        /// Internal use
        /// </summary>
        LastBasicObject = 4,
        /// <summary>
        /// Internal use
        /// </summary>
        FirstComponent = 200,
        /// <summary>
        /// Object is a mesh component.
        /// </summary>
        MeshComponent = 200,
        /// <summary>
        /// Object is a cut plane component.
        /// </summary>
        CutPlaneComponent = 201,
        /// <summary>
        /// Object is a hierarchical state override component.
        /// </summary>
        HierarchicalStateOverrideComponent = 202,
        /// <summary>
        /// Object is a point light component.
        /// </summary>
        PointLightComponent = 203,
        /// <summary>
        /// Object is a spot light component.
        /// </summary>
        SpotLightComponent = 204,
        /// <summary>
        /// Object is a directional light component.
        /// </summary>
        DirectionalLightComponent = 205,
        /// <summary>
        /// Internal use
        /// </summary>
        LastComponent = 205,
    }

    public enum RenderingSessionVmSize : int
    {
        None = 0,
        Premium = 1,
        Standard = 2,
    }

    public enum ConnectionType : int
    {
        /// <summary>
        /// General purpose connection.
        /// </summary>
        General = 0,
        /// <summary>
        /// Game engine specific connection.
        /// </summary>
        Engine = 1,
        /// <summary>
        /// Used internally
        /// </summary>
        Count = 2,
    }

    public enum PbrVertexAlphaMode : int
    {
        Occlusion = 0,
        LightMask = 1,
        Opacity = 2,
    }

    public enum ColorTransparencyMode : int
    {
        Opaque = 0,
        AlphaBlend = 1,
        Additive = 2,
    }

    public enum TextureType : int
    {
        /// <summary>
        /// Texture is a 2d texture.
        /// </summary>
        Texture2D = 0,
        /// <summary>
        /// Texture is a cubemap.
        /// </summary>
        CubeMap = 1,
    }

    public enum ServiceRenderMode : int
    {
        /// <summary>
        /// Multi-GPU result is composed from distinct meshes by merging depth buffers. Suitable for most scene types, balances rendering quality with resource consumption. Does not support dynamic transparency such as see-through effect via hierarchical state override component.
        /// </summary>
        DepthBasedComposition = 0,
        /// <summary>
        /// Multi-GPU result is composed from tiles. Improved rendering quality but also higher server resource consumption, not suitable for large scenes.
        /// </summary>
        TileBasedComposition = 1,
        /// <summary>
        /// Default, recommended render mode.
        /// </summary>
        Default = 0,
    }

    public enum PerformanceRating : int
    {
        Great = 0,
        Good = 1,
        Mediocre = 2,
        Bad = 3,
    }

    public enum HierarchicalStates : int
    {
        /// <summary>
        /// No state is overridden.
        /// </summary>
        None = 0,
        /// <summary>
        /// The visible flag is overridden.
        /// </summary>
        Hidden = 1,
        /// <summary>
        /// The selected state is overridden.
        /// </summary>
        Selected = 2,
        /// <summary>
        /// The see-through opacity is overridden.
        /// </summary>
        SeeThrough = 4,
        /// <summary>
        /// The use tint color state is overridden. This flag enables individual tint color per obejct.
        /// </summary>
        UseTintColor = 8,
        /// <summary>
        /// The disable collision flag is overridden. This flag makes a part invisible to ray cast queries.
        /// </summary>
        DisableCollision = 16,
        /// <summary>
        /// Combination of all flags.
        /// </summary>
        AllValidFlags = 31,
    }

    public enum PbrMaterialFeatures : int
    {
        /// <summary>
        /// None of the flags below.
        /// </summary>
        None = 0,
        /// <summary>
        /// The material is transparent (alpha-blended), where the level of transparency is defined by albedo colors' alpha and optionally vertex colors' alpha.
        /// </summary>
        TransparentMaterial = 1,
        /// <summary>
        /// Use/ignore the vertex color (if provided by the mesh). Needs to be enabled so that PbrMaterial.PbrVertexAlphaMode has any effect.
        /// </summary>
        UseVertexColor = 2,
        /// <summary>
        /// The material is rendered double-sided, otherwise back faces are culled.
        /// </summary>
        DoubleSided = 4,
        /// <summary>
        /// Enables specular highlights for this material.
        /// </summary>
        SpecularHighlights = 8,
        /// <summary>
        /// Enables hard cut-outs on a per-pixel basis based on the alpha value being below a PbrMaterial.AlphaClipThreshold. This works for opaque materials as well.
        /// </summary>
        AlphaClipped = 16,
        /// <summary>
        /// If enabled, this material fades to black as opposed to fading to transparent when used with SetFadeOut. Fading to black has the same effect on see-through devices like Hololens but has less GPU cost associated with it.
        /// </summary>
        FadeToBlack = 32,
    }

    public enum ColorMaterialFeatures : int
    {
        /// <summary>
        /// None of the flags below.
        /// </summary>
        None = 0,
        /// <summary>
        /// Use/ignore the vertex color if provided by the mesh.
        /// </summary>
        UseVertexColor = 1,
        /// <summary>
        /// The material is rendered double-sided, otherwise back faces are culled.
        /// </summary>
        DoubleSided = 2,
        /// <summary>
        /// If enabled, this material fades to black as opposed to fading to transparent when used with SetFadeOut. Fading to black has the same effect on see-through devices like Hololens but has less GPU cost associated with it.
        /// </summary>
        FadeToBlack = 4,
        /// <summary>
        /// Enables hard cut-outs on a per-pixel basis based on the alpha value being below a threshold. This works for opaque materials as well.
        /// </summary>
        AlphaClipped = 8,
    }

    public enum MetadataValueType : int
    {
        /// <summary>
        /// Invalid type.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// Value is a boolean.
        /// </summary>
        Bool = 1,
        /// <summary>
        /// Value is a 32 bit signed integer.
        /// </summary>
        Int32 = 2,
        /// <summary>
        /// Value is a 64 bit signed integer.
        /// </summary>
        Int64 = 3,
        /// <summary>
        /// Value is a 64 bit unsigned integer.
        /// </summary>
        UInt64 = 4,
        /// <summary>
        /// Value is a double precision floating point value.
        /// </summary>
        Double = 5,
        /// <summary>
        /// Value is a string.
        /// </summary>
        String = 6,
        /// <summary>
        /// Internal use
        /// </summary>
        MetadataValueTypeCount = 7,
    }

    public enum HitCollectionPolicy : int
    {
        /// <summary>
        /// Return all hits along the ray, sorted by distance.
        /// </summary>
        AllHits = 0,
        /// <summary>
        /// Return the closest hit along the ray from the start point.
        /// </summary>
        ClosestHit = 1,
        /// <summary>
        /// Return any hit along the ray. AnyHit is an optimal query to answer 'is B visible from A'?
        /// </summary>
        AnyHit = 2,
    }

    public enum HandleType : int
    {
        Unknown = 0,
        AsyncBase = 1,
        BoundsQueryAsync = 2,
        MetadataQueryAsync = 3,
        LoadModelAsync = 4,
        LoadTextureAsync = 5,
        RaycastQueryAsync = 6,
        PerformanceAssessmentAsync = 7,
        BaseSessionAsync = 8,
        SessionAsync = 9,
        CreateSessionAsync = 10,
        ConnectToRuntimeAsync = 11,
        ArrInspectorAsync = 12,
        SessionPropertiesAsync = 13,
        SessionPropertiesArrayAsync = 14,
        StartAssetConversionAsync = 15,
        ConversionStatusAsync = 16,
        ObjectBase = 17,
        ComponentBase = 18,
        LightComponentBase = 19,
        CutPlaneComponent = 20,
        HierarchicalStateOverrideComponent = 21,
        PointLightComponent = 22,
        SpotLightComponent = 23,
        DirectionalLightComponent = 24,
        MeshComponent = 25,
        ResourceBase = 26,
        Material = 27,
        PbrMaterial = 28,
        ColorMaterial = 29,
        Mesh = 30,
        Texture = 31,
        Entity = 32,
        GraphicsBinding = 33,
        GraphicsBindingSimD3d11 = 34,
        GraphicsBindingWmrD3d11 = 35,
    }

    public delegate void DestructorHookDelegate();

    /// <summary>
    /// Delegate for monitoring the progress of an asynchonrous operation.
    /// </summary>
    /// <param name="progress">
    /// Progress fraction between 0 and 1 for how close the operation is to finishing.
    /// </param>
    public delegate void ProgressHandler(float progress);

    /// <summary>
    /// Delegate for receiving incoming log messages.
    /// </summary>
    /// <param name="level">
    /// Level of the log message.
    /// </param>
    /// <param name="message">
    /// Message as an IntPtr to the underlying utf8 char array.
    /// </param>
    public delegate void LogHandler(Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message);

    /// <summary>
    /// Delegate for receiving connection status updates.
    /// </summary>
    /// <param name="status">
    /// The new connection status.
    /// </param>
    /// <param name="error">
    /// Additional error information in the case of a spurious disconnect.
    /// </param>
    public delegate void ConnectionStatusHandler(Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error);

    /// <summary>
    /// Delegate for receiving notification when an update tick has completed on a RemoteManager.
    /// </summary>
    public delegate void UpdatedHandler();

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void BoundsQueryHandler(Microsoft.Azure.RemoteRendering.BoundsQueryAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void MetadataHandler(Microsoft.Azure.RemoteRendering.MetadataQueryAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void LoadModelHandler(Microsoft.Azure.RemoteRendering.LoadModelAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void LoadTextureHandler(Microsoft.Azure.RemoteRendering.LoadTextureAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void RaycastQueryHandler(Microsoft.Azure.RemoteRendering.RaycastQueryAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void PerformanceAssessmentHandler(Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void SessionHandler(Microsoft.Azure.RemoteRendering.SessionAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void CreateSessionHandler(Microsoft.Azure.RemoteRendering.CreateSessionAsync async);

    /// <summary>
    /// Informs the application that a frontend requires an updated access token or authentication token.
    /// </summary>
    /// <param name="sender">
    /// The frontend that requires an updated access token or authentication token.
    /// </param>
    /// <param name="args">
    /// The event arguments that require an AccessToken property or an AuthenticationToken property to be set.
    /// </param>
    public delegate void TokenRequiredDelegate(object sender, Microsoft.Azure.RemoteRendering.TokenRequiredEventArgs args);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void SessionPropertiesArrayHandler(Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void StartAssetConversionHandler(Microsoft.Azure.RemoteRendering.StartAssetConversionAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void ConversionStatusHandler(Microsoft.Azure.RemoteRendering.ConversionStatusAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void ArrInspectorHandler(Microsoft.Azure.RemoteRendering.ArrInspectorAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void SessionPropertiesHandler(Microsoft.Azure.RemoteRendering.SessionPropertiesAsync async);

    /// <summary>
    /// Event handler for the completion of an async.
    /// </summary>
    public delegate void ConnectToRuntimeHandler(Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync result);

    /// <summary>
    /// Base class for all remote rendering exceptions.
    /// </summary>
    public class RRException : Exception
    {
        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        public RRException()
        {
            this.ErrorCode = default(Result);
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        public RRException(Result code)
        {
            this.ErrorCode = code;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        public RRException(Result code, string message) : base(message)
        {
            this.ErrorCode = code;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        /// <param name='requestCorrelationVector'>Request correlation vector for this exception.</param>
        /// <param name='responseCorrelationVector'>Response correlation vector for this exception.</param>
        public RRException(Result code, string message, string requestCorrelationVector, string responseCorrelationVector) : base(message)
        {
            this.ErrorCode = code;
            this.RequestCorrelationVector = requestCorrelationVector;
            this.ResponseCorrelationVector = responseCorrelationVector;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        /// <param name='requestCorrelationVector'>Request correlation vector for this exception.</param>
        /// <param name='responseCorrelationVector'>Response correlation vector for this exception.</param>
        /// <param name='inner'>Exception that caused this exception to be thrown.</param>
        public RRException(Result code, string message, string requestCorrelationVector, string responseCorrelationVector, Exception inner) : base(message, inner)
        {
            this.ErrorCode = code;
            this.RequestCorrelationVector = requestCorrelationVector;
            this.ResponseCorrelationVector = responseCorrelationVector;
        }

        public Result ErrorCode { get; }

        public string RequestCorrelationVector { get; }

        public string ResponseCorrelationVector { get; }

    }

    /// <summary>
    /// Return value of async inspector website query functions.
    /// </summary>
    public partial class ArrInspectorAsync : AsyncBase, ICookie
    {
        internal ArrInspectorAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ArrInspectorAsync>.Add(this);
        }
        /// <summary>
        /// Get the URI of the generated webpage. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public string Result
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_arr_inspector_async_get_result(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ArrInspectorHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ArrInspectorAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ArrInspectorHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.ArrInspectorAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ArrInspectorHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ArrInspectorHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_arr_inspector_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Base class for asynchronous results.
    /// </summary>
    public partial class AsyncBase : IDisposable
    {
        internal IntPtr handle;
        internal AsyncBase(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_addref(ahandle);
        }
        protected AsyncBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        #region IDisposable Support

        /// <summary>
        /// Whether the implementation has been disposed or not.
        /// </summary>
        private bool isDisposed = false;

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!this.isDisposed)
            {
                if (disposing)
                {
                    NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_async_base_dispose(this.handle));
                }

                NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_async_base_release(this.handle));
                this.handle = IntPtr.Zero;

                this.isDisposed = true;
            }
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="AsyncBase"/> class.
        /// </summary>
        ~AsyncBase()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion IDisposable Support

        /// <summary>
        /// Get the current status of operation. Success if finished successfully, InProgress if in progress, otherwise error code of the operation if failed.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Status
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Result result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_status(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// True when the task is in one of the two final states: Faulted or RanToCompletion.
        /// </summary>
        public bool IsCompleted
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_is_completed(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// True when task is in Success state.
        /// </summary>
        public bool IsRanToCompletion
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_is_ran_to_completion(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// True when task is not in Success or InProgress states.
        /// </summary>
        public bool IsFaulted
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_is_faulted(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// AzureFrontend is an authorized connection to the Azure APIs for Remote Rendering. Use the AzureFrontend to create AzureSessions and convert assets. AzureSession keep a reference to the frontend, meaning all rendering sessions must be freed before the frontend will be free'd.
    /// </summary>
    public partial class AzureFrontend : IDisposable, ICookie
    {
        internal ulong handle;
        internal AzureFrontend(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_addref(ahandle);
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Add(this);
        }
        public AzureFrontend(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo init)
        {
            Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi init_converted = init.Convert();
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_create_azure_frontend_account_info_init(init_converted, out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Add(this);
        }

        #region IDisposable Support

        /// <summary>
        /// Whether the implementation has been disposed or not.
        /// </summary>
        private bool isDisposed = false;

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!this.isDisposed)
            {
                if (disposing)
                {
                    NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_azure_frontend_dispose(this.handle));
                }

                NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_azure_frontend_release(this.handle));
                this.handle = default(ulong);

                this.isDisposed = true;
            }
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="AzureFrontend"/> class.
        /// </summary>
        ~AzureFrontend()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion IDisposable Support

        /// <summary>
        /// Log level to enable. Only messages at this log level or below will be emitted.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LogLevel LogLevel
        {
            get
            {
                Microsoft.Azure.RemoteRendering.LogLevel result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_log_level(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_set_log_level(this.handle, value));
            }
        }

        /// <summary>
        /// Parameters used to construct this AzureFrontend.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo Configuration
        {
            get
            {
                Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_configuration(this.handle, out result));
                return result.Convert();
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LogHandler _MessageLogged;
        /// <summary>Static handler.</summary>
        private static void MessageLoggedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LogHandler handler = (instance == null) ? null : instance._MessageLogged;
            if (handler != null)
            {
                handler(level, message);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LogHandlerNative MessageLoggedStaticHandlerDelegate = MessageLoggedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LogHandler MessageLogged
        {
            add
            {
                this._MessageLogged += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_set_message_logged(this.handle, this.cookie, MessageLoggedStaticHandlerDelegate));
            }
            remove
            {
                this._MessageLogged -= value;
            }
        }

        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.TokenRequiredDelegate _TokenRequired;
        /// <summary>Static handler.</summary>
        private static void TokenRequiredStaticHandler(ulong cookie, IntPtr args)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.TokenRequiredDelegate handler = (instance == null) ? null : instance._TokenRequired;
            if (handler != null)
            {
                handler(instance, new Microsoft.Azure.RemoteRendering.TokenRequiredEventArgs(args, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.TokenRequiredDelegateNative TokenRequiredStaticHandlerDelegate = TokenRequiredStaticHandler;
        public event Microsoft.Azure.RemoteRendering.TokenRequiredDelegate TokenRequired
        {
            add
            {
                this._TokenRequired += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_set_token_required(this.handle, this.cookie, TokenRequiredStaticHandlerDelegate));
            }
            remove
            {
                this._TokenRequired -= value;
            }
        }

        /// <summary>
        /// Query the full set of existing rendering sessions for the account associated with the frontend.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync GetCurrentRenderingSessionsAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_current_rendering_sessions_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Open an existing rendering session.
        /// </summary>
        /// <param name="sessionId">
        /// Rendering Session UUID.
        /// </param>
        public Microsoft.Azure.RemoteRendering.AzureSession OpenRenderingSession(string sessionId)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.AzureSession result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_open_rendering_session(this.handle, sessionId, out result_handle));
            result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.AzureSession(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Create a new rendering session on the cloud. CreateNewRenderingSessionAsync will spin up a new VM on the Azure cloud. When the VM is available to query, CreateSessionAsync will return the created AzureSession object or an error context.
        /// </summary>
        /// <param name="paramsIn">
        /// Session creation parameters
        /// </param>
        public Microsoft.Azure.RemoteRendering.CreateSessionAsync CreateNewRenderingSessionAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.CreateSessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_create_new_rendering_session_async(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.CreateSessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Internal API using unsafe parameters to create a rendering session.
        /// </summary>
        /// <param name="paramsIn">
        /// 
        /// </param>
        public Microsoft.Azure.RemoteRendering.CreateSessionAsync CreateNewRenderingSessionUnsafeAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe paramsIn)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.CreateSessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_create_new_rendering_session_unsafe_async(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.CreateSessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Start converting an asset.
        /// </summary>
        /// <param name="paramsIn">
        /// The asset to convert.
        /// </param>
        public Microsoft.Azure.RemoteRendering.StartAssetConversionAsync StartAssetConversionAsync_Deprecated(Microsoft.Azure.RemoteRendering.AssetConversionParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.StartAssetConversionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_start_asset_conversion_async_deprecated(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Start converting an asset.
        /// </summary>
        /// <param name="inputLocation">
        /// Where to find the asset.
        /// </param>
        /// <param name="outputLocation">
        /// Where to place the converted asset.
        /// </param>
        public Microsoft.Azure.RemoteRendering.StartAssetConversionAsync StartAssetConversionAsync(Microsoft.Azure.RemoteRendering.AssetConversionInputParams inputLocation, Microsoft.Azure.RemoteRendering.AssetConversionOutputParams outputLocation)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi inputLocation_converted = inputLocation.Convert();
            Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi outputLocation_converted = outputLocation.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.StartAssetConversionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_start_asset_conversion_async(this.handle, inputLocation_converted, outputLocation_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Start converting an asset using SAS access to the input and output containers.
        /// </summary>
        /// <param name="inputLocation">
        /// Where to find the asset.
        /// </param>
        /// <param name="outputLocation">
        /// Where to place the converted asset.
        /// </param>
        public Microsoft.Azure.RemoteRendering.StartAssetConversionAsync StartAssetConversionSasAsync(Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams inputLocation, Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams outputLocation)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi inputLocation_converted = inputLocation.Convert();
            Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi outputLocation_converted = outputLocation.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.StartAssetConversionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_start_asset_conversion_sas_async(this.handle, inputLocation_converted, outputLocation_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Query state of current asset conversion.
        /// </summary>
        /// <param name="paramsIn">
        /// The conversion token returned by StartAssetConversionAsync.
        /// </param>
        public Microsoft.Azure.RemoteRendering.ConversionStatusAsync GetAssetConversionStatusAsync(string conversionId)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ConversionStatusAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_asset_conversion_status_async(this.handle, conversionId, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(result_handle, transfer:true) : null;
            return result_object;
        }

    }

    /// <summary>
    /// An azure session is a single VM with a remote rendering runtime instance running on it. For a given application, one AzureSession can connect to a remote rendering instance. It is not currently possible to connect two AzureSessions at the same time.
    /// </summary>
    public partial class AzureSession : ICookie
    {
        internal ulong handle;
        internal AzureSession(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_addref(ahandle);
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureSession>.Add(this);
        }
        ~AzureSession()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_release(this.handle));
            this.handle = default(ulong);
        }

        /// <summary>
        /// Get associated azure frontend.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AzureFrontend AzureFrontend
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.AzureFrontend result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_azure_frontend(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.AzureFrontend(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// String UUID for session. This can be used to connect to the session later or perform independent restful calls with powershell.
        /// </summary>
        public string SessionUUID
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_session_uuid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Last connection params used in a call to ConnectToRuntime.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams ConnectToRuntimeParams
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_connect_to_runtime_params(this.handle, out result));
                return result.Convert();
            }
        }

        /// <summary>
        /// Connection status of this Session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectionStatus ConnectionStatus
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConnectionStatus result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_connection_status(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Utility function to query if session is connected.
        /// </summary>
        public bool IsConnected
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_is_connected(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ConnectionStatusHandler _ConnectionStatusChanged;
        /// <summary>Static handler.</summary>
        private static void ConnectionStatusChangedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureSession>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ConnectionStatusHandler handler = (instance == null) ? null : instance._ConnectionStatusChanged;
            if (handler != null)
            {
                handler(status, error);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ConnectionStatusHandlerNative ConnectionStatusChangedStaticHandlerDelegate = ConnectionStatusChangedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ConnectionStatusHandler ConnectionStatusChanged
        {
            add
            {
                this._ConnectionStatusChanged += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_set_connection_status_changed(this.handle, this.cookie, ConnectionStatusChangedStaticHandlerDelegate));
            }
            remove
            {
                this._ConnectionStatusChanged -= value;
            }
        }

        /// <summary>
        /// Get a filepath pointing to a html file to connect to the arr inspector website. The arr inspector provides introspection and service status updates.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ArrInspectorAsync ConnectToArrInspectorAsync(string hostname)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ArrInspectorAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_connect_to_arr_inspector_async(this.handle, hostname, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ArrInspectorAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Query the properties of the session (hostname, lease time, size, etc.).
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SessionPropertiesAsync GetPropertiesAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionPropertiesAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_properties_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Stop a VM. This will decomission the rendering session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SessionAsync StopAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_stop_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Renew a VM. This will update the lease of the VM to a new time. Time is absolute since starting time of the VM: expiration = start_time + lease_time.
        /// </summary>
        /// <param name="updateParams">
        /// 
        /// </param>
        public Microsoft.Azure.RemoteRendering.SessionAsync RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateParams updateParams)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_renew_async(this.handle, updateParams, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Connect to the runtime on the virtual machine associated with this session. If another session in the same process is already connected then this function will throw.
        /// </summary>
        /// <param name="inputParams">
        /// Connection Parameters.
        /// </param>
        public Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync ConnectToRuntime(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams inputParams)
        {
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi inputParams_converted = inputParams.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_connect_to_runtime(this.handle, inputParams_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Disconnect this session if connected to the runtime.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result DisconnectFromRuntime()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_disconnect_from_runtime(this.handle, out result));
            return result;
        }

    }

    /// <summary>
    /// Base class for session related async query functions.
    /// </summary>
    public partial class BaseSessionAsync : AsyncBase
    {
        internal BaseSessionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Get the context of the call result. This call will throw if the call is not yet finished.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SessionGeneralContext Context
        {
            get
            {
                Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_base_session_async_get_context(this.handle, out result));
                return result.Convert();
            }
        }

    }

    /// <summary>
    /// Return value of async object bounds query functions.
    /// </summary>
    public partial class BoundsQueryAsync : AsyncBase, ICookie
    {
        internal BoundsQueryAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.BoundsQueryAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AABB3D Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.AABB3D result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_bounds_query_async_get_result(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.BoundsQueryHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.BoundsQueryAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.BoundsQueryHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.BoundsQueryHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.BoundsQueryHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_bounds_query_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Class that wraps camera settings.
    /// </summary>
    public partial class CameraSettings
    {
        internal ulong handle;
        internal CameraSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Camera near plane.
        /// </summary>
        public float NearPlane
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_near_plane(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_near_plane(this.handle, value));
            }
        }

        /// <summary>
        /// Camera far plane.
        /// </summary>
        public float FarPlane
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_far_plane(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_far_plane(this.handle, value));
            }
        }

        /// <summary>
        /// Enable depth composition with locally rendered content.
        /// </summary>
        public bool EnableDepth
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_enable_depth(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_enable_depth(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Color material.
    /// </summary>
    public partial class ColorMaterial : Material
    {
        internal ColorMaterial(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Gets/sets the flags for this color material. See ColorFlags.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ColorMaterialFeatures ColorFlags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ColorMaterialFeatures result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_color_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_color_flags(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the constant albedo color. The albedo color of a material defines the unlit diffuse color. It can originate from a constant color, from a texture or both. In the latter case the texture color is modulated with the constant color, so in order to use the unmodified texture color, this albedo color should be left to white. The alpha component of this color is used for the opacity level in case the material is flagged as transparent.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4 AlbedoColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_albedo_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_albedo_color(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/Sets the albedo texture for this material. Use constant null for 'no texture'.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture AlbedoTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_albedo_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_albedo_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Gets/sets the scaling factor applied to texture coordinates. A two-component value to scale U and V independently. For instance, passing (4,4) will apply 4x4 tiling to the texture. Tiling is applied likewise to all defined material textures.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordScale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_tex_coord_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_tex_coord_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the offset applied to texture coordinates. An offset is normalized to [0..1] range regardless of texture size, so (0.5, 0.5) points to the middle of a texture. The offset can be changed over frames to scroll a texture. The offset is applied likewise to all defined material textures. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordOffset
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_tex_coord_offset(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_tex_coord_offset(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the transparency mode for this material. See enum ColorTransparencyMode.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ColorTransparencyMode ColorTransparencyMode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ColorTransparencyMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_color_transparency_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_color_transparency_mode(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the fade-out value in the [0..1] range, where 0.0 means fully faded out and 1.0 means fully opaque. This is very similar to changing the albedo's alpha on a transparent material, however this function internally manages the transparent flag for values of 1.0 (fully opaque) and smaller than 1.0 (semi-transparent) respectively. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float FadeOut
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_fade_out(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_fade_out(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the vertex color mix amount in scalar [0..1] range. This scalar defines how much the mesh's vertex color mixes into the final color. If 0.0, the vertex color does not contribute at all, if 1.0 it will be fully multiplied with the albedo color. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float VertexMix
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_vertex_mix(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_vertex_mix(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets a threshold value that is used for alpha cutout. If a pixel's final alpha value [0..1] falls below the threshold value, the pixel is clipped thus causing a hard cutout. Note that the material's ColorFlags.AlphaClipped flag has to be set, otherwise this threshold has no effect. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float AlphaClipThreshold
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_alpha_clip_threshold(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_alpha_clip_threshold(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Base class for all components. Components are isolated functionalities that can be attached to an entity to give that functionality to that particular entity. For example, adding a cut plane at the location of an Entity or adding a MeshComponent to render. ComponentBase serves as the base class for all components, it cannot be instantiated directly. An Entity can only have one component instance of a component type attached at a time.
    /// </summary>
    public partial class ComponentBase : ObjectBase
    {
        internal ComponentBase(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The entity that this component is attached to.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity Owner
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_owner(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Indicates whether this component is enabled. The enabled state can be changed during runtime.
        /// </summary>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// The component type.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Indicates whether this component is valid.
        /// </summary>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Destroy will destroy the component in the runtime. IsValid() will return false on subsequent queries.
        /// </summary>
        public void Destroy()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_destroy(this.handle));
        }

    }

    /// <summary>
    /// Return value of async runtime conection query functions. Result of the connection can be queried from AsyncBase.Status.
    /// </summary>
    public partial class ConnectToRuntimeAsync : AsyncBase, ICookie
    {
        internal ConnectToRuntimeAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync>.Add(this);
        }
        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr result)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync(result, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_connect_to_runtime_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Return value of async asset conversion status query functions.
    /// </summary>
    public partial class ConversionStatusAsync : BaseSessionAsync, ICookie
    {
        internal ConversionStatusAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConversionStatusAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConversionSessionStatus Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConversionSessionStatus result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_status_async_get_result(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get additional information about the result.
        /// </summary>
        public string Message
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_status_async_get_message(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ConversionStatusHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConversionStatusAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ConversionStatusHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ConversionStatusHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ConversionStatusHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_status_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Return value of async session creation query functions.
    /// </summary>
    public partial class CreateSessionAsync : BaseSessionAsync, ICookie
    {
        internal CreateSessionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.CreateSessionAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AzureSession Result
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.AzureSession result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_create_session_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.AzureSession(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.CreateSessionHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.CreateSessionAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.CreateSessionHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.CreateSessionAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.CreateSessionHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.CreateSessionHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_create_session_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Cut planes are used to cut away parts of meshes to be able to peek inside. Once a cut plane is part of the scene, all rendered pixels that are on the back side of the plane will be discarded. By moving the cut plane around or changing its orientation, one can adjust which parts of the scene are visible. The position of the cut plane is specified through the position of the owning Entity. The orientation is specified through the . Only axis aligned cut planes are supported, however, to get the effect of a rotated cut plane, one can instead rotate the object that is supposed to be cut open.
    /// </summary>
    public partial class CutPlaneComponent : ComponentBase
    {
        internal CutPlaneComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Set the normal axis of the cut plane. Pixels that fall behind the cut plane will be discarded by the renderer.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis Normal
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Axis result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_normal(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_normal(this.handle, value));
            }
        }

        /// <summary>
        /// Set the color towards which pixels closer than  will be faded.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4Ub FadeColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_fade_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_fade_color(this.handle, value));
            }
        }

        /// <summary>
        /// Sets the distance in local units over which the cut plane will fade the original pixel color towards the .
        /// </summary>
        public float FadeLength
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_fade_length(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_fade_length(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Class that holds the settings for server side debug rendering features
    /// </summary>
    public partial class DebugRenderingSettings
    {
        internal ulong handle;
        internal DebugRenderingSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Enables or disables server side rendering of frame count overlay.
        /// </summary>
        public bool RenderFrameCount
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_frame_count(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_frame_count(this.handle, value));
            }
        }

        /// <summary>
        /// Enables or disables server side rendering of polygon count overlay.
        /// </summary>
        public bool RenderPolygonCount
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_polygon_count(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_polygon_count(this.handle, value));
            }
        }

        /// <summary>
        /// Enables or disables wireframe rendering of object geometry.
        /// </summary>
        public bool RenderWireframe
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_wireframe(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_wireframe(this.handle, value));
            }
        }

    }

    /// <summary>
    /// A directional light simulates a light source that is infinitely far away. Accordingly, unlike point lights and spot lights, the position of a directional light is ignored. The direction of the parallel light rays is defined by the negative z-axis of the owner object. There are no additional directional light-specific properties.
    /// </summary>
    public partial class DirectionalLightComponent : LightComponentBase
    {
        internal DirectionalLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
    }

    /// <summary>
    /// An entity represents an object in space. Entities have a transform, ie. a position, rotation and scale. By themselves entities do not have any observable functionality. Instead behavior is added through components (see ), which are attached to entities. For instance attaching a MeshComponent will make a mesh appear at the position of the entity. The most important aspect of the Entity itself is the hierarchy and the resulting hierarchical transform. For example when multiple entities are attached as children to a shared parent entity, all of these entities can be moved, rotated and scaled in unison by changing the transform of the parent entity.
    /// </summary>
    public partial class Entity : ObjectBase
    {
        internal Entity(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Returns ObjectType.Entity.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Check validity of entity. This will be false if Destroy() has been called on the entity or if the session for this entity has been disconnected from.
        /// </summary>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get/set parent of the entity. null is used for 'no parent'.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity Parent
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_parent(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_parent(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Get the list of children. To re-parent entities, rather use the Parent setter on the child entity.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Entity> Children
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Entity> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_children(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => new Microsoft.Azure.RemoteRendering.Entity(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Get the list of components attached to this entity.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ComponentBase> Components
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ComponentBase> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_components(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.ComponentBaseFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Relative position from its parent.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 Position
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Double3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_position(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_position(this.handle, value));
            }
        }

        /// <summary>
        /// Relative rotation from its parent.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Quaternion Rotation
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Quaternion result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_rotation(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_rotation(this.handle, value));
            }
        }

        /// <summary>
        /// Relative scale from its parent.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float3 Scale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Optional entity name.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_name(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_name(this.handle, value));
            }
        }

        /// <summary>
        /// Try to find a component of given type.
        /// </summary>
        /// <param name="type">
        /// Type of component to search for.
        /// </param>
        public Microsoft.Azure.RemoteRendering.ComponentBase FindComponentOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_find_component_of_type(this.handle, type, out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.ComponentBaseFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Destroy the entity. Destroying an entity will also destroy all of its components and child entities.
        /// </summary>
        public void Destroy()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_destroy(this.handle));
        }

        /// <summary>
        /// Query the world bounds for an entity inclusive its children from the server.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.BoundsQueryAsync QueryWorldBoundsAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.BoundsQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_world_bounds_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Query the local bounds for an entity inclusive its children from the server.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.BoundsQueryAsync QueryLocalBoundsAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.BoundsQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_local_bounds_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Query for any available metadata information on the entity.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.MetadataQueryAsync QueryMetaDataAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.MetadataQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_meta_data_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.MetadataQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

    }

    /// <summary>
    /// Binding for the graphics API.
    /// </summary>
    public partial class GraphicsBinding
    {
        internal ulong handle;
        internal GraphicsBinding(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        protected GraphicsBinding()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// Defines the derived graphics binding this instance can be cast to.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType Api
        {
            get
            {
                Microsoft.Azure.RemoteRendering.GraphicsApiType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_api(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Retrieves the remote focus point. This focus point must be explicitly set as the focus point to be used.
        /// </summary>
        /// <param name="coordinateSystem">
        /// The coordinate frame in which the focus point should be expressed. Passing an invalid coordinate system will result in invalid focus points.
        /// </param>
        /// <param name="position">
        /// Position in world space of the remote focus point. Only valid if return value != FocusPointResult.Invalid.
        /// </param>
        /// <param name="normal">
        /// Normal in world space of the remote focus point. Only valid if return value != FocusPointResult.Invalid.
        /// </param>
        /// <param name="velocity">
        /// Velocity in world space of the remote focus point. Only valid if return value != FocusPointResult.Invalid.
        /// </param>
        public Microsoft.Azure.RemoteRendering.FocusPointResult GetRemoteFocusPoint(System.IntPtr coordinateSystem, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity)
        {
            Microsoft.Azure.RemoteRendering.FocusPointResult result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_remote_focus_point(this.handle, coordinateSystem, out position, out normal, out velocity, out result));
            return result;
        }

        /// <summary>
        /// Retrieves the last frame's statistics.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result GetLastFrameStatistics(out Microsoft.Azure.RemoteRendering.FrameStatistics stats)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_last_frame_statistics(this.handle, out stats, out result));
            return result;
        }

    }

    /// <summary>
    /// Simulation binding. Used to simulate head movement. This graphics binding is used to render a monoscopic remote image on a normal desktop application. With no sensors to provide head movement available, this binding requires the user to provide a current camera update each frame. The basic setup works as follow: 1. Remote and local content is rendered onto an offscreen color / depth render target called 'proxy' using the proxy camera provided by the Update function. The proxy needs to be created matching the resolution of the backbuffer. Before any rendering takes place, InitSimulation needs to be called with the proxy texture handles as well a d3d device to fully initialize the simulation. 2. Each frame, before any rendering takes place, Update is called with the current camera transform and the returned proxy transform is applied to the proxy camera. 3. At the start of rendering into the proxy, BlitRemoteFrameToProxy needs to be called, this will fill the remote color and depth information into the proxy render targets. Any local content can now be rendered onto the proxy using the proxy camera. 4. Once the backbuffer is bound, only ReprojectProxy needs to be called and no other rendering should take place. 5. Repeat with step 2 until session ends. 6. Call DeinitSimulation after the remote session has ended.
    /// </summary>
    public partial class GraphicsBindingSimD3d11 : GraphicsBinding
    {
        internal GraphicsBindingSimD3d11(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Initialize the simulation. Needs to be called before each remote rendering session is started.
        /// </summary>
        /// <param name="d3dDevice">
        /// The d3d device that will be used to render the remote image.
        /// </param>
        /// <param name="proxyDepth">
        /// Color texture of the proxy render target.
        /// </param>
        /// <param name="proxyColor">
        /// Depth texture of the proxy render target.
        /// </param>
        /// <param name="refreshRate">
        /// Target refresh rate at which the remote runtime should render.
        /// </param>
        /// <param name="flipBlitRemoteFrameTextureVertically">
        /// If set, BlitRemoteFrameToProxy will flip the rendered image vertically.
        /// </param>
        /// <param name="flipReprojectTextureVertically">
        /// If set, ReprojectProxy will flip the rendered image vertically.
        /// </param>
        public Microsoft.Azure.RemoteRendering.Result InitSimulation(System.IntPtr d3dDevice, System.IntPtr proxyDepth, System.IntPtr proxyColor, float refreshRate, bool flipBlitRemoteFrameTextureVertically, bool flipReprojectTextureVertically)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_init_simulation(this.handle, d3dDevice, proxyDepth, proxyColor, refreshRate, flipBlitRemoteFrameTextureVertically, flipReprojectTextureVertically, out result));
            return result;
        }

        /// <summary>
        /// Deinitialize the simulation. Needs to be called after each remote rendering session has ended.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result DeinitSimulation()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_deinit_simulation(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Needs to be called each frame to inform the server to render a certain frame.
        /// </summary>
        /// <param name="update">
        /// The camera update of the main camera. This information will be sent to the server to be rendered.
        /// </param>
        /// <param name="proxyFrameUpdate">
        /// The camera update for the proxy. Matches the current remote frame and needs to be applied
        /// </param>
        public Microsoft.Azure.RemoteRendering.Result Update(Microsoft.Azure.RemoteRendering.SimulationUpdate update, out Microsoft.Azure.RemoteRendering.SimulationUpdate proxyFrameUpdate)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_update(this.handle, update, out proxyFrameUpdate, out result));
            return result;
        }

        /// <summary>
        /// Blits the current remote frame to the currently bound render target. When this function is executed it is assumed that the proxy color and depth buffers are bound as the current render target. This should be done as the very first thing in each frame as this function will overwrite all content in the target buffers.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result BlitRemoteFrameToProxy()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_blit_remote_frame_to_proxy(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Reprojects the proxy color texture onto the backbuffer. When this function is executed it is assumed that the backbuffer color and depth buffers are bound as the current render target.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result ReprojectProxy()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_reproject_proxy(this.handle, out result));
            return result;
        }

    }

    /// <summary>
    /// D3D11 binding for Windows Mixed Reality. If this graphics binding is used it is important that RemoteManagerStatic.StartupRemoteRendering is called before any HolographicSpace is created or any other mirage API is called to bind remote rendering to mirage. Once this is done, the only thing that needs to be done by the user is to call BlitRemoteFrame to render the remote frame to the current render target.
    /// </summary>
    public partial class GraphicsBindingWmrD3d11 : GraphicsBinding
    {
        internal GraphicsBindingWmrD3d11(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Blits the oldest remote frame to the currently bound render target. When this function is executed it is assumed that the mirage provided color and depth buffers are bound as the current render target. This should be done as the very first thing in each frame as this function will overwrite all content in the target buffers.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result BlitRemoteFrame()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_wmr_d3d11_blit_remote_frame(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Whenever a new frame of reference is created and used as the new user coordinate system of the world, ARR needs to be informed of the change.
        /// </summary>
        /// <param name="coordinateSystem">
        /// Pointer to ABI::Windows::Perception::Spatial::ISpatialCoordinateSystem.
        /// </param>
        public Microsoft.Azure.RemoteRendering.Result UpdateUserCoordinateSystem(System.IntPtr coordinateSystem)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_wmr_d3d11_update_user_coordinate_system(this.handle, coordinateSystem, out result));
            return result;
        }

    }

    /// <summary>
    /// Controls the visualization of sub-hierarchies of entities.
    /// </summary>
    public partial class HierarchicalStateOverrideComponent : ComponentBase
    {
        internal HierarchicalStateOverrideComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The render property flags of this component.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalStates Flags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalStates result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_flags(this.handle, value));
            }
        }

        /// <summary>
        /// The render property flags to override on this component.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalStates OverrideFlags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalStates result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_override_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_override_flags(this.handle, value));
            }
        }

        /// <summary>
        /// The tint color of this component.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4Ub TintColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_tint_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_tint_color(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the HierarchicalStateFlags.Hidden feature
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState HiddenState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_hidden_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_hidden_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the HierarchicalStateFlags.Selected feature
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState SelectedState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_selected_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_selected_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the HierarchicalStateFlags.SeeThrough feature
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState SeeThroughState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_see_through_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_see_through_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the HierarchicalStateFlags.UseTintColor feature
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState UseTintColorState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_use_tint_color_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_use_tint_color_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the HierarchicalStateFlags.DisableCollision feature
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState DisableCollisionState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_disable_collision_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_disable_collision_state(this.handle, value));
            }
        }

        /// <summary>
        /// Sets specific features to a new state of type HierarchicalEnableState.
        /// </summary>
        /// <param name="feature">
        /// The feature(s) to modify. A bitwise combination of features can be passed here to modify multiple features simultaneously.
        /// </param>
        /// <param name="enabledState">
        /// The new feature state.
        /// </param>
        public void SetState(Microsoft.Azure.RemoteRendering.HierarchicalStates feature, Microsoft.Azure.RemoteRendering.HierarchicalEnableState enabledState)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_state(this.handle, feature, enabledState));
        }

        /// <summary>
        /// Returns the current enabled state (of type HierarchicalEnableState) of the passed feature.
        /// </summary>
        /// <param name="feature">
        /// A single feature to query the current status on. Unlike SetState, multiple feature bits cannot be combined here.
        /// </param>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState GetState(Microsoft.Azure.RemoteRendering.HierarchicalStates feature)
        {
            Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_state(this.handle, feature, out result));
            return result;
        }

    }

    /// <summary>
    /// Base class for all light components. Lights are added to the scene as components of respective type attached to a game object. Lights are considered as dynamic lights that contribute to the scene's lighting conditions on top of the global sky light. The game object serves as the spatial transform of the light source. This base class cannot be instantiated directly, instead one of the specific light types (Point/Spot/Directional) has to be used.
    /// </summary>
    public partial class LightComponentBase : ComponentBase
    {
        internal LightComponentBase(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The intensity of the light. This value has no physical measure however it can be considered to be proportional to the physical power of the light source. If the light has a fall-off (point and spotlight) this value also defines the maximum range of light influence. An intensity of 1000 roughly has a range of 100 world units, but note this does not scale linearly.
        /// </summary>
        public float Intensity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_get_intensity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_set_intensity(this.handle, value));
            }
        }

        /// <summary>
        /// The color of the light in gamma color space. The alpha portion is ignored.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4Ub Color
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_get_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_set_color(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Return value of async model loading functions.
    /// </summary>
    public partial class LoadModelAsync : AsyncBase, ICookie
    {
        internal LoadModelAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadModelAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the loading operation. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadModelResult Result
        {
            get
            {
                IntPtr result_handle;
                Microsoft.Azure.RemoteRendering.LoadModelResult result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadModelResult(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Current progress fraction in (0..1) range.
        /// </summary>
        public float Progress
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_get_progress(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LoadModelHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadModelAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LoadModelHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.LoadModelAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LoadModelHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LoadModelHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ProgressHandler _ProgressUpdated;
        /// <summary>Static handler.</summary>
        private static void ProgressUpdatedStaticHandler(ulong cookie, float progress)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadModelAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ProgressHandler handler = (instance == null) ? null : instance._ProgressUpdated;
            if (handler != null)
            {
                handler(progress);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ProgressHandlerNative ProgressUpdatedStaticHandlerDelegate = ProgressUpdatedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ProgressHandler ProgressUpdated
        {
            add
            {
                this._ProgressUpdated += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_set_progress_updated(this.handle, this.cookie, ProgressUpdatedStaticHandlerDelegate));
            }
            remove
            {
                this._ProgressUpdated -= value;
            }
        }

    }

    /// <summary>
    /// Return result from LoadModel.
    /// </summary>
    public partial class LoadModelResult
    {
        internal IntPtr handle;
        internal LoadModelResult(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_addref(ahandle);
        }
        ~LoadModelResult()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Root entity of the loaded model.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity Root
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_root(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Retrieve all loaded objects of given object type. The requested ObjectType must specify a valid object type such as entity or a component.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectBase> GetLoadedObjectsOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectBase> result;
            ulong[] result_array;
            int result_length;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_loaded_objects_of_type(this.handle, type, out result_array, out result_length));
            result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.ObjectBaseFactory(handle, transfer:true)).ToArray();
            return result;
        }

        /// <summary>
        /// Retrieve all loaded resources of given resource type. The requested ObjectType must specify a valid resource type such as mesh or material.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ResourceBase> GetLoadedResourceOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ResourceBase> result;
            ulong[] result_array;
            int result_length;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_loaded_resource_of_type(this.handle, type, out result_array, out result_length));
            result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.ResourceBaseFactory(handle, transfer:true)).ToArray();
            return result;
        }

    }

    /// <summary>
    /// Return value of async texture loading functions.
    /// </summary>
    public partial class LoadTextureAsync : AsyncBase, ICookie
    {
        internal LoadTextureAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadTextureAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the loading operation. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture Result
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_texture_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LoadTextureHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadTextureAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LoadTextureHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.LoadTextureAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LoadTextureHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LoadTextureHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_texture_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Materials are shared resources used to describe the rendering properties of a Mesh. If a material is modified, all meshes that reference the material will be affected. To modify only the material of a specific object you need to create a dedicated material and replace the material reference on the MeshComponent to point to the custom material.
    /// </summary>
    public partial class Material : ResourceBase
    {
        internal Material(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Returns ObjectType.Material.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Indicates whether this material is still valid.
        /// </summary>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Material name.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_name(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_set_name(this.handle, value));
            }
        }

        /// <summary>
        /// Material subtype enum value.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.MaterialType MaterialSubType
        {
            get
            {
                Microsoft.Azure.RemoteRendering.MaterialType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_material_sub_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Copy material properties from another material instance. If the material types do not match, common properties such as albedo color / -texture are copied.
        /// </summary>
        /// <param name="other">
        /// 
        /// </param>
        public void CopyFrom(Microsoft.Azure.RemoteRendering.Material other)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_copy_from(this.handle, other != null ? other.handle : default(ulong)));
        }

    }

    /// <summary>
    /// MeshComponents attach a Mesh to an Entity so that the mesh is rendered in the scene. Changing the material on the mesh component through SetMaterial will update the visual characteristics of the mesh.
    /// </summary>
    public partial class MeshComponent : ComponentBase
    {
        internal MeshComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Get the materials of the mesh component. These are materials specifically set to override the default mesh materials. If no material override has been set the material will be null. The material array will always be the same size as Mesh.Materials.Count.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> Materials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_materials(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Query for a list of the used materials of the rendered mesh. The array will either contain the override material of the MeshComponent or, if no override has been set then the default material of the underlying mesh.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> UsedMaterials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_used_materials(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// The Mesh used for rendering.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Mesh Mesh
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Mesh result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_mesh(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Mesh(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_set_mesh(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Set an override material for this rendered mesh.
        /// </summary>
        /// <param name="idx">
        /// Index into the 'Materials' array. Index must be inside the range of the current materials array.
        /// </param>
        /// <param name="material">
        /// Material to set, null to return to default material on the mesh.
        /// </param>
        public void SetMaterial(int idx, Microsoft.Azure.RemoteRendering.Material material)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_set_material(this.handle, idx, material != null ? material.handle : default(ulong)));
        }

    }

    /// <summary>
    /// Meshes are an immutable shared resource. They describe the shape and which materials to be used by default for rendering. Meshes cannot be modified at runtime. To change rendering properties, it is possible to modify their materials. However, the preferred method is to specify override Material references in a MeshComponent to change which Material to use for rendering each part of the mesh.
    /// </summary>
    public partial class Mesh : ResourceBase
    {
        internal Mesh(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Returns ObjectType.Mesh.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Indicates whether this mesh is still valid.
        /// </summary>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The list of materials used for rendering the mesh unless overridden by a MeshComponent.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> Materials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_materials(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Get the localspace bounds for the mesh.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AABB3D Bounds
        {
            get
            {
                Microsoft.Azure.RemoteRendering.AABB3D result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_bounds(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Return value of async metadata query functions.
    /// </summary>
    public partial class MetadataQueryAsync : AsyncBase, ICookie
    {
        internal MetadataQueryAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.MetadataQueryAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectMetaData Result
        {
            get
            {
                IntPtr result_handle;
                Microsoft.Azure.RemoteRendering.ObjectMetaData result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_metadata_query_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ObjectMetaData(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.MetadataHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.MetadataQueryAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.MetadataHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.MetadataQueryAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.MetadataHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.MetadataHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_metadata_query_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Base class for all instanceable objects (entities, components).
    /// </summary>
    public partial class ObjectBase
    {
        internal ulong handle;
        internal ObjectBase(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        protected ObjectBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// Indicates whether this object is valid. An object is invalid if it has been destroyed or if the connection has been lost.
        /// </summary>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The type of the object.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_get_type(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// An individual metadata entry on an object. Lifetime is managed by the object metadata container.
    /// </summary>
    public partial class ObjectMetaDataEntry
    {
        internal IntPtr handle;
        internal ObjectMetaDataEntry(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Name of this metadata entry.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_name(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Type of this metadata.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.MetadataValueType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.MetadataValueType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get the value of this metadata as boolean.
        /// </summary>
        public bool AsBool
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_bool(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get the value of this metadata as Int32.
        /// </summary>
        public int AsInt
        {
            get
            {
                int result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_int(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get the value of this metadata as Int64.
        /// </summary>
        public long AsInt64
        {
            get
            {
                long result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_int64(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get the bool value of this metadata as UInt64.
        /// </summary>
        public ulong AsUInt64
        {
            get
            {
                ulong result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_uint64(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get the value of this metadata as double.
        /// </summary>
        public double AsDouble
        {
            get
            {
                double result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_double(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get the value of this metadata as string.
        /// </summary>
        public string AsString
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_string(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Class that stores the metadata value collection for an object.
    /// </summary>
    public partial class ObjectMetaData
    {
        internal IntPtr handle;
        internal ObjectMetaData(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_addref(ahandle);
        }
        ~ObjectMetaData()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Get a read-only array of all metadata on an object.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry> Metadata
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry> result;
                IntPtr[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_get_metadata(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<IntPtr>()).Select(handle => new Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Query a metadata entry by name.
        /// </summary>
        /// <param name="name">
        /// Metadata name
        /// </param>
        public Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry GetMetadataByName(string name)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_get_metadata_by_name(this.handle, name, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry(result_handle, transfer:true) : null;
            return result_object;
        }

    }

    /// <summary>
    /// Global settings for selection outline rendering.
    /// </summary>
    public partial class OutlineSettings
    {
        internal ulong handle;
        internal OutlineSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// The color of the outlines.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4Ub Color
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_color(this.handle, value));
            }
        }

        /// <summary>
        /// The rate (in Hz) at which the outline intensity oscillates.
        /// </summary>
        public float PulseRateHz
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_pulse_rate_hz(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_pulse_rate_hz(this.handle, value));
            }
        }

        /// <summary>
        /// The intensity with which the outline pulses. This value must be in (0..1) range with 0=no pulsing effect and 1=full amplitude.
        /// </summary>
        public float PulseIntensity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_pulse_intensity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_pulse_intensity(this.handle, value));
            }
        }

    }

    /// <summary>
    /// PBR material.
    /// </summary>
    public partial class PbrMaterial : Material
    {
        internal PbrMaterial(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Gets/sets the material flags. See enum PbrFlags.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PbrMaterialFeatures PbrFlags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PbrMaterialFeatures result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_pbr_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_pbr_flags(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the scaling factor applied to texture coordinates. A two-component value to scale U and V independently. For instance, passing (4,4) will apply 4x4 tiling to the texture. Tiling is applied likewise to all defined material textures.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordScale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_tex_coord_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_tex_coord_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the offset applied to texture coordinates. An offset is normalized to [0..1] range regardless of texture size, so (0.5, 0.5) points to the middle of a texture. The offset can be changed over frames to scroll a texture. The offset is applied likewise to all defined material textures.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordOffset
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_tex_coord_offset(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_tex_coord_offset(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the constant albedo color. The albedo color of a material defines the unlit diffuse color. It can originate from a constant color, from a texture or both. In the latter case the texture color is modulated with the constant color, so in order to use the unmodified texture color, this albedo color should be left to white. The alpha component of this color is used for the opacity level in case the material is flagged as transparent (see PbrFlags.TransparentMaterial).
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4 AlbedoColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_albedo_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_albedo_color(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/Sets the albedo texture for this material. Use constant null for 'no texture'.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture AlbedoTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_albedo_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_albedo_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Gets/sets the vertex alpha mode. See enum PbrVertexAlphaMode. This function has no effect if the mesh does not provide vertex colors or if the PbrFlags.UseVertexColor flag is not set. The default value is PbrVertexAlphaMode.Occlusion.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode PbrVertexAlphaMode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_pbr_vertex_alpha_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_pbr_vertex_alpha_mode(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the normalmap texture for this material. This function accepts any texture but note that a valid normalmap encodes the normal vector into RGB portions rather than being a grayscale heightmap. null is used to denote 'no normalmap'.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture NormalMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_normal_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_normal_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Gets/sets the scalar amount for ambient occlusion in [0..1] range. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float AOScale
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_aoscale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_aoscale(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the ambient occlusion texture. A valid AO texture is a grayscale texture that defines scalars that are combined with the constant ambient occlusion value (AOScale). null is used to denote 'no ambient occlusion texture'.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture AOMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_aomap(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_aomap(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Gets/sets a constant roughness value on this material. Roughness is a scalar in the [0..1] range. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float Roughness
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_roughness(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_roughness(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the roughness texture for this material. A valid roughness texture is a grayscale texture that defines scalars that are combined with the constant roughness value (Roughness property). null is used to denote 'no roughness texture'.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture RoughnessMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_roughness_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_roughness_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Gets/sets a constant metalness value on this material. Metalness is a scalar in the [0..1] range, which in most of the use cases is either 0.0 (non-metallic) or 1.0 (metallic). This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float Metalness
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_metalness(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_metalness(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the metalness texture for this material. A valid metalness texture is a grayscale texture that defines scalars that are combined with the constant metalness value (Metalness properties). null is used to denote 'no metalness texture'.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture MetalnessMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_metalness_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_metalness_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Gets/sets a threshold value that is used for alpha cutout. If a pixel's final alpha value [0..1] falls below the threshold value, the pixel is clipped thus causing a hard cutout. Note that the material's PbrFlags.AlphaClipped flag has to be set, otherwise this threshold has no effect. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float AlphaClipThreshold
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_alpha_clip_threshold(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_alpha_clip_threshold(this.handle, value));
            }
        }

        /// <summary>
        /// Gets/sets the fade-out value in the [0..1] range, where 0.0 means fully faded out and 1.0 means fully opaque. This is very similar to changing the albedo's alpha on a transparent material, however this function internally manages the transparent flag for values of 1.0 (fully opaque) and smaller than 1.0 (semi-transparent) respectively. This call will fail with an InvalidParam exception if the range exceeds [0..1].
        /// </summary>
        public float FadeOut
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_fade_out(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_fade_out(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Return value of async performance assessment query functions.
    /// </summary>
    public partial class PerformanceAssessmentAsync : AsyncBase, ICookie
    {
        internal PerformanceAssessmentAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceAssessment Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PerformanceAssessmentAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_performance_assessment_async_get_result(this.handle, out result));
                return result.Convert();
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_performance_assessment_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// A point light simulates light emitted equally in all directions form a point (or small sphere/tube) in space. Point light components can be used to create local light effects such as light from bulbs.
    /// </summary>
    public partial class PointLightComponent : LightComponentBase
    {
        internal PointLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// If >0 the light emitting shape of the light source is a sphere of given radius as opposed to a point. This shape for instance affects the appearance of specular highlights.
        /// </summary>
        public float Radius
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_radius(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_radius(this.handle, value));
            }
        }

        /// <summary>
        /// If >0 (and also radius > 0) this value defines the length of a light emitting tube. Use case is a neon tube.
        /// </summary>
        public float Length
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_length(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_length(this.handle, value));
            }
        }

        /// <summary>
        /// Defines a custom interval of min/max distances over which the light's attenuated intensity is scaled linearly down to 0. This feature can be used to enforce a smaller range of influence of a specific light. If not defined (default), these values are implicitly derived from the light's intensity.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float2 AttenuationCutoff
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_attenuation_cutoff(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_attenuation_cutoff(this.handle, value));
            }
        }

        /// <summary>
        /// In case a valid cubemap texture is passed here, the cubemap is projected using the orientation of the light. The cubemap's color is modulated with the light's color.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture ProjectedCubeMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_projected_cube_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_projected_cube_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// Return value of async ray cast query functions.
    /// </summary>
    public partial class RaycastQueryAsync : AsyncBase, ICookie
    {
        internal RaycastQueryAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RaycastQueryAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RayCastHit[] Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RayCastHitAbi[] result;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_raycast_query_async_get_result(this.handle, out result, out result_length));
                return result?.Select(x => x.Convert()).ToArray() ?? null;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.RaycastQueryHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RaycastQueryAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.RaycastQueryHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.RaycastQueryAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.RaycastQueryHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.RaycastQueryHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_raycast_query_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Main entry point for remote rendering specific actions. See AzureSession.Actions.
    /// </summary>
    public partial class RemoteManager : ICookie
    {
        internal ulong handle;
        internal RemoteManager(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RemoteManager>.Add(this);
        }
        /// <summary>
        /// Log level to enable. Only messages at this log level or below will be emitted.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LogLevel LogLevel
        {
            get
            {
                Microsoft.Azure.RemoteRendering.LogLevel result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_log_level(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_set_log_level(this.handle, value));
            }
        }

        /// <summary>
        /// Returns global camera settings.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.CameraSettings CameraSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.CameraSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_camera_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.CameraSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Returns global sky reflection settings.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SkyReflectionSettings SkyReflectionSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.SkyReflectionSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_sky_reflection_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.SkyReflectionSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Returns global outline settings.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.OutlineSettings OutlineSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.OutlineSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_outline_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.OutlineSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Returns global z-fighting mitigation state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings ZFightingMitigationSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_zfighting_mitigation_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Returns global single sided rendering settings.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SingleSidedSettings SingleSidedSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.SingleSidedSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_single_sided_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.SingleSidedSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Returns global single sided rendering settings.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.DebugRenderingSettings DebugRenderingSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.DebugRenderingSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_debug_rendering_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.DebugRenderingSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LogHandler _MessageLogged;
        /// <summary>Static handler.</summary>
        private static void MessageLoggedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RemoteManager>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LogHandler handler = (instance == null) ? null : instance._MessageLogged;
            if (handler != null)
            {
                handler(level, message);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LogHandlerNative MessageLoggedStaticHandlerDelegate = MessageLoggedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LogHandler MessageLogged
        {
            add
            {
                this._MessageLogged += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_set_message_logged(this.handle, this.cookie, MessageLoggedStaticHandlerDelegate));
            }
            remove
            {
                this._MessageLogged -= value;
            }
        }

        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.UpdatedHandler _Updated;
        /// <summary>Static handler.</summary>
        private static void UpdatedStaticHandler(ulong cookie)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RemoteManager>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.UpdatedHandler handler = (instance == null) ? null : instance._Updated;
            if (handler != null)
            {
                handler();
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.UpdatedHandlerNative UpdatedStaticHandlerDelegate = UpdatedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.UpdatedHandler Updated
        {
            add
            {
                this._Updated += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_set_updated(this.handle, this.cookie, UpdatedStaticHandlerDelegate));
            }
            remove
            {
                this._Updated -= value;
            }
        }

        /// <summary>
        /// Asynchronously load a model. This call will return immediately with an object that will emit an event when the model load has completed on the server. The result contains all objects that were loaded with the model. \note Returned Async completes during RemoteManager.Update.
        /// </summary>
        /// <param name="paramsIn">
        /// Loading parameters for the model.
        /// </param>
        public Microsoft.Azure.RemoteRendering.LoadModelAsync LoadModelFromSASAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadModelAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_model_from_sasasync(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadModelAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Asynchronously load a model from blob store. This call will return immediately with an object that will emit an event when the model load has completed on the server. The result contains all objects that were loaded with the model. \note Returned Async completes during RemoteManager.Update.
        /// </summary>
        /// <param name="paramsIn">
        /// Loading parameters for the model.
        /// </param>
        public Microsoft.Azure.RemoteRendering.LoadModelAsync LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadModelParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadModelAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_model_async(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadModelAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Asynchronously load a texture. This call will return immediately with an object that will emit an event when the texture load has completed on the server. \note Async completes during RemoteManager.Update.
        /// </summary>
        /// <param name="paramsIn">
        /// Params to identify the texture.
        /// </param>
        public Microsoft.Azure.RemoteRendering.LoadTextureAsync LoadTextureFromSASAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadTextureAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_texture_from_sasasync(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadTextureAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Asynchronously load a texture from blob store. This call will return immediately with an object that will emit an event when the texture load has completed on the server. \note Async completes during RemoteManager.Update.
        /// </summary>
        /// <param name="paramsIn">
        /// Params to identify the texture.
        /// </param>
        public Microsoft.Azure.RemoteRendering.LoadTextureAsync LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadTextureAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_texture_async(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadTextureAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Asynchronously perform a raycast query on the remote scene.  This call will return immediately with an object that will emit an event when the raycast has returned from the server. The raycast will be performed on the server against the state of the world on the frame that the raycast was issued on.  Results will be sorted by distance, with the closest intersection to the user being the first item in the array. \note Async completes during RemoteManager.Update.
        /// </summary>
        /// <param name="cast">
        /// Outgoing RayCast.
        /// </param>
        public Microsoft.Azure.RemoteRendering.RaycastQueryAsync RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast cast)
        {
            Microsoft.Azure.RemoteRendering.RayCastAbi cast_converted = cast.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.RaycastQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_ray_cast_query_async(this.handle, cast_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.RaycastQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Asynchronously perform a performance assessment query on the server. This call will return immediately with an object that will emit an event when the query has returned from the server.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync QueryServerPerformanceAssessmentAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_query_server_performance_assessment_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Create a new entity on the server. Until the entity is assigned a parent, the entity will be parented to the root of the scenegraph on the server.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity CreateEntity()
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.Entity result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_create_entity(this.handle, out result_handle));
            result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Create a new material on the server. The new material can be set to mesh components.
        /// </summary>
        /// <param name="type">
        /// Type of created material.
        /// </param>
        public Microsoft.Azure.RemoteRendering.Material CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType type)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.Material result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_create_material(this.handle, type, out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.MaterialFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Create a new component locally and on the server. This call can fail if the entity already has a component of componentType on it or the client is currently disconnected from the server.
        /// </summary>
        /// <param name="componentType">
        /// Component type to create.
        /// </param>
        /// <param name="owner">
        /// Owner of the component.
        /// </param>
        public Microsoft.Azure.RemoteRendering.ComponentBase CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType componentType, Microsoft.Azure.RemoteRendering.Entity owner)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_create_component(this.handle, componentType, owner != null ? owner.handle : default(ulong), out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.ComponentBaseFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Update pushes all updates from the client to the server (entity state changes, raycast requests, etc.) and will dispatch any messages the client has received from the server (raycast responses, load model responses, etc.). Update must be called intermittently, for example, in the update loop of a game engine. Calls to Update() invoke the OnUpdate event.
        /// </summary>
        public void Update()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_update(this.handle));
        }

    }

    /// <summary>
    /// Base class for all resources (meshes, textures,...).
    /// </summary>
    public partial class ResourceBase
    {
        internal ulong handle;
        internal ResourceBase(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_addref(ahandle);
        }
        protected ResourceBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        ~ResourceBase()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_release(this.handle));
            this.handle = default(ulong);
        }

        /// <summary>
        /// Indicates whether this resource is valid. A resource is invalid if it has been destroyed or if the connection has been lost.
        /// </summary>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The type of the resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_get_type(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Return value of async session query functions.
    /// </summary>
    public partial class SessionAsync : BaseSessionAsync, ICookie
    {
        internal SessionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionAsync>.Add(this);
        }
        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.SessionHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.SessionHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.SessionAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.SessionHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.SessionHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Return value of async session proiperty array query functions.
    /// </summary>
    public partial class SessionPropertiesArrayAsync : BaseSessionAsync, ICookie
    {
        internal SessionPropertiesArrayAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties[] Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi[] result;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_array_async_get_result(this.handle, out result, out result_length));
                return result?.Select(x => x.Convert()).ToArray() ?? null;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_array_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Return value of async session properties query functions.
    /// </summary>
    public partial class SessionPropertiesAsync : BaseSessionAsync, ICookie
    {
        internal SessionPropertiesAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesAsync>.Add(this);
        }
        /// <summary>
        /// Get the result of the query. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_async_get_result(this.handle, out result));
                return result.Convert();
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.SessionPropertiesHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.SessionPropertiesHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.SessionPropertiesHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.SessionPropertiesHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Class that holds the settings for the single sided geometry rendering.
    /// </summary>
    public partial class SingleSidedSettings
    {
        internal ulong handle;
        internal SingleSidedSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Switches the single sided rendering mode.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SingleSidedMode Mode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.SingleSidedMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_get_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_set_mode(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Controls the global reflection texture used during server-side rendering.
    /// </summary>
    public partial class SkyReflectionSettings
    {
        internal ulong handle;
        internal SkyReflectionSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// The sky texture used for reflection. This must be either a cubemap or a 2d texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture SkyReflectionTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_get_sky_reflection_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_set_sky_reflection_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// Component that represents a dynamic spot light. In contrast to a point light, the light is not emitted in all directions but instead constrained to the shape of a cone. The orientation of the cone is defined by the owner object's negative z-axis. Typical use cases for spotlights are flashlights.
    /// </summary>
    public partial class SpotLightComponent : LightComponentBase
    {
        internal SpotLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        public float Radius
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_radius(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_radius(this.handle, value));
            }
        }

        /// <summary>
        /// Defines the characteristic of the falloff between the inner and the outer cone angle. A higher value results in a sharper transition between inner and outer cone angle. The default of 1.0 defines a linear falloff.
        /// </summary>
        public float FalloffExponent
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_falloff_exponent(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_falloff_exponent(this.handle, value));
            }
        }

        public Microsoft.Azure.RemoteRendering.Float2 AttenuationCutoff
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_attenuation_cutoff(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_attenuation_cutoff(this.handle, value));
            }
        }

        /// <summary>
        /// This interval defines the inner and outer angle of the spot light cone both measured in degree. Everything within the inner angle is illuminated by the full brightness of the spot light source and a falloff is applied towards the outer angle that generates a penumbra-like effect.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float2 SpotAngleDeg
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_spot_angle_deg(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_spot_angle_deg(this.handle, value));
            }
        }

        /// <summary>
        /// In case a valid 2d texture is passed here, the texture is projected. The texture's color is modulated with the light's color.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Texture Projected2dTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_projected2d_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_projected2d_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// Return value of async asset conversion query functions.
    /// </summary>
    public partial class StartAssetConversionAsync : BaseSessionAsync, ICookie
    {
        internal StartAssetConversionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.StartAssetConversionAsync>.Add(this);
        }
        /// <summary>
        /// Get the uuid for the ingestion operation. This will throw an error if the query is in progress or in an error state.
        /// </summary>
        public string Result
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_start_asset_conversion_async_get_result(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.StartAssetConversionHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.StartAssetConversionAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.StartAssetConversionHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.StartAssetConversionHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.StartAssetConversionHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_start_asset_conversion_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Textures are immutable shared resources.  They describe an image that can be applied to a surface via a Material. Textures cannot be modified at runtime.  A texture can be applied to a surface by setting it on the Material associated with a Mesh.
    /// </summary>
    public partial class Texture : ResourceBase
    {
        internal Texture(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Returns ObjectType.Texture.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Indicates whether this texture is still valid.
        /// </summary>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Texture name.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_name(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Informs the application that the service requires an updated access token or authentication token.
    /// </summary>
    public partial class TokenRequiredEventArgs : EventArgs
    {
        internal IntPtr handle;
        internal TokenRequiredEventArgs(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_addref(ahandle);
        }
        ~TokenRequiredEventArgs()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// The access token to be used by the operation that requires it.
        /// </summary>
        public string AccessToken
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_get_access_token(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_set_access_token(this.handle, value));
            }
        }

        /// <summary>
        /// The authentication token to be used by the operation that requires it.
        /// </summary>
        public string AuthenticationToken
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_get_authentication_token(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_set_authentication_token(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Class that holds the settings for global z-fighting mitigation.
    /// </summary>
    public partial class ZFightingMitigationSettings
    {
        internal ulong handle;
        internal ZFightingMitigationSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Enables or disables the mitigation. Refer to the general documentation for a description of how the mitigation works.
        /// </summary>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// Activates checkerboard highlighting of potential z-fighting. For debugging purposes.
        /// </summary>
        public bool Highlighting
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_highlighting(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_set_highlighting(this.handle, value));
            }
        }

    }

}
