// <auto-generated/>
#pragma warning disable

//
// RemoteRenderingClient
// This file was auto-generated from AzureRemoteRenderingApiModel.cs.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace Microsoft.Azure.RemoteRendering
{
    internal enum status
    {
        /// <summary>
        /// Success
        /// </summary>
        OK = 0,
        /// <summary>
        /// Failed
        /// </summary>
        Failed = 1,
        /// <summary>
        /// Cannot access a disposed object.
        /// </summary>
        ObjectDisposed = 2,
        /// <summary>
        /// Out of memory.
        /// </summary>
        OutOfMemory = 12,
        /// <summary>
        /// Invalid argument.
        /// </summary>
        InvalidArgument = 22,
        /// <summary>
        /// The value is out of range.
        /// </summary>
        OutOfRange = 34,
        /// <summary>
        /// Not implemented.
        /// </summary>
        NotImplemented = 38,
        /// <summary>
        /// The key does not exist in the collection.
        /// </summary>
        KeyNotFound = 77,
        /// <summary>
        /// Internal: Start of the range of core result values.
        /// </summary>
        CoreReturnValueStart = 78,
        /// <summary>
        /// Operation completed successfully.
        /// </summary>
        Success = 79,
        /// <summary>
        /// General failure.
        /// </summary>
        Fail = 80,
        /// <summary>
        /// The user canceled the operation.
        /// </summary>
        Cancelled = 81,
        /// <summary>
        /// Incorrect user input for the operation.
        /// </summary>
        InvalidParam = 82,
        /// <summary>
        /// An object with incorrect type was passed in.
        /// </summary>
        InvalidType = 83,
        /// <summary>
        /// Not used.
        /// </summary>
        BufferTooSmall_Deprecated = 84,
        /// <summary>
        /// Operation requires an active connection.
        /// </summary>
        /// <remarks>
        /// If the connection to the server has been lost, this error can occur for most operations,
        /// since only few operations are possible without a connection.
        /// </remarks>
        NoConnection = 85,
        /// <summary>
        /// Internal.
        /// </summary>
        ApiUnavailable = 86,
        /// <summary>
        /// Static initialization of remote rendering has been called multiple times.
        /// </summary>
        AlreadyInitialized = 87,
        /// <summary>
        /// Static de-initialization of remote rendering has already been performed.
        /// </summary>
        AlreadyDeinitialized = 88,
        /// <summary>
        /// The string passed into the API is longer than allowed.
        /// </summary>
        StringTooLong = 89,
        /// <summary>
        /// The index passed into the API is outside the valid range.
        /// </summary>
        IndexOutOfRange = 90,
        /// <summary>
        /// An async operation has not yet finished.
        /// </summary>
        InProgress = 91,
        /// <summary>
        /// Static initialization of remote rendering hasn't been done yet.
        /// </summary>
        NotInitialized = 92,
        /// <summary>
        /// Internal: Last used value of the range of core result values.
        /// </summary>
        CoreReturnValueLast = 93,
        /// <summary>
        /// Internal: Maximum value of the range of core result values.
        /// </summary>
        CoreReturnValueEnd = 94,
        /// <summary>
        /// Internal: Start of the range of file load result values.
        /// </summary>
        LoadFileReturnValueStart = 95,
        /// <summary>
        /// The requested file did not exist.
        /// </summary>
        FileNotFound = 96,
        /// <summary>
        /// The requested file is either corrupt or uses an old version that is not supported anymore.
        /// </summary>
        InvalidVersion = 97,
        /// <summary>
        /// Not used.
        /// </summary>
        IncompatibleVersion_Deprecated = 98,
        /// <summary>
        /// The requested file is either corrupt or not recognized.
        /// </summary>
        FailedToOpenFile = 99,
        /// <summary>
        /// Downloading the file from the provided URL failed.
        /// </summary>
        FileDownloadFailed = 100,
        /// <summary>
        /// Loading this model would exceed GPU memory limits. Request a larger server, or reduce the amount of loaded models.
        /// </summary>
        ExceedsMemoryLimit = 101,
        /// <summary>
        /// The target file cannot be written
        /// </summary>
        CannotWriteTargetFile = 102,
        /// <summary>
        /// The target file is corrupt or in an unsupported format
        /// </summary>
        FileCorrupt = 103,
        /// <summary>
        /// Internal: Last used value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueLast = 104,
        /// <summary>
        /// Internal: Maximum value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueEnd = 105,
        /// <summary>
        /// Internal: Start of the range of object result values.
        /// </summary>
        ObjectReturnValueStart = 106,
        /// <summary>
        /// The provided object ID is not valid (anymore).
        /// </summary>
        InvalidId = 107,
        /// <summary>
        /// The parent entity with the provided ID does not exist.
        /// </summary>
        InvalidParentId = 108,
        /// <summary>
        /// An object of the same type already exists on the target.
        /// </summary>
        AlreadyExists = 109,
        /// <summary>
        /// Re-parenting this entity to the target entity would create a cycle in the entity hierarchy.
        /// </summary>
        CyclicReference = 110,
        /// <summary>
        /// Not used.
        /// </summary>
        ObjectLocked_Deprecated = 111,
        /// <summary>
        /// Internal: Last used value of the range of object result values.
        /// </summary>
        ObjectReturnValueLast = 112,
        /// <summary>
        /// Internal: Maximum value of the range of object result values.
        /// </summary>
        ObjectReturnValueEnd = 113,
        /// <summary>
        /// Internal: Start of the range of connection result values.
        /// </summary>
        ConnectionReturnValueStart = 114,
        /// <summary>
        /// Internal: Secure connection enabled, but certificate was missing, invalid, or not usable.
        /// </summary>
        NoServerCertificate = 115,
        /// <summary>
        /// Internal: Handshake port could not be opened for accepting connections.
        /// </summary>
        HandshakePortBusy = 116,
        /// <summary>
        /// Handshake server is unreachable.
        /// </summary>
        HandshakeUnreachable = 117,
        /// <summary>
        /// Handshake server closed the connection prematurely; likely due to TLS/Plain mismatch or invalid certificate.
        /// </summary>
        HandshakeConnectionFailed = 118,
        /// <summary>
        /// Authentication with the handshake server failed.
        /// </summary>
        AuthenticationFailed = 119,
        /// <summary>
        /// No common compatible remoting version could be determined during handshake.
        /// </summary>
        RemotingVersionMismatch = 120,
        /// <summary>
        /// No common transport protocol could be determined during handshake.
        /// </summary>
        IncompatibleTransportProtocols = 121,
        /// <summary>
        /// Handshake failed. Reason not further specified.
        /// </summary>
        HandshakeFailed = 122,
        /// <summary>
        /// Internal: Transport port could not be opened for accepting connections.
        /// </summary>
        TransportPortBusy = 123,
        /// <summary>
        /// Transport server is unreachable.
        /// </summary>
        TransportUnreachable = 124,
        /// <summary>
        /// Transport connection was closed before all communication channels had been set up.
        /// </summary>
        TransportConnectionFailed = 125,
        /// <summary>
        /// Transport connection was closed due to protocol version mismatch.
        /// </summary>
        ProtocolVersionMismatch = 126,
        /// <summary>
        /// A protocol error occurred that was severe enough to invalidate the current connection or connection attempt.
        /// </summary>
        ProtocolError = 127,
        /// <summary>
        /// Transport connection was closed due to the requested video codec not being available.
        /// </summary>
        VideoCodecNotAvailable = 128,
        /// <summary>
        /// Connection has been closed by peer.
        /// </summary>
        ConnectionLost = 129,
        /// <summary>
        /// Connection has been closed due to graphics device loss.
        /// </summary>
        DeviceLost = 130,
        /// <summary>
        /// Connection has been closed by request.
        /// </summary>
        DisconnectRequest = 131,
        /// <summary>
        /// Internal.
        /// </summary>
        Timeout = 132,
        /// <summary>
        /// A connection has been established before.
        /// </summary>
        AlreadyConnected = 133,
        /// <summary>
        /// The client SDK version is not supported anymore. Please update.
        /// </summary>
        ArrVersionMismatch = 134,
        /// <summary>
        /// Network is unreachable. This usually means the client knows no route to reach the remote host.
        /// </summary>
        HandshakeNetworkUnreachable = 135,
        /// <summary>
        /// No connection could be made because the remote side actively refused it. Usually this means that no host application is running.
        /// </summary>
        HandshakeConnectionRefused = 136,
        /// <summary>
        /// Transport connection was closed due to the requested video format not being available.
        /// </summary>
        VideoFormatNotAvailable = 137,
        /// <summary>
        /// Disconnecting after receiving a disconnect request from the peer.
        /// </summary>
        PeerDisconnectRequest = 138,
        /// <summary>
        /// Timed out while waiting for peer to close connection.
        /// </summary>
        PeerDisconnectTimeout = 139,
        /// <summary>
        /// Internal: Last used value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueLast = 140,
        /// <summary>
        /// Internal: Maximum value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueEnd = 141,
        /// <summary>
        /// Internal: Start of the range of manager result values.
        /// </summary>
        ManagerReturnValueStart = 142,
        /// <summary>
        /// Internal: Invalid tool ID.
        /// </summary>
        InvalidToolId = 143,
        /// <summary>
        /// The remote rendering manager has already been created.
        /// </summary>
        ManagerAlreadyCreated = 144,
        /// <summary>
        /// The remote rendering manager has not been created yet.
        /// </summary>
        ManagerNotCreatedYet = 145,
        /// <summary>
        /// Another session is already connected to this runtime.
        /// </summary>
        OtherSessionConnected = 146,
        /// <summary>
        /// Internal.
        /// </summary>
        BadStateTransition = 147,
        /// <summary>
        /// An internal tool failed to start
        /// </summary>
        FailedToStartTool = 148,
        /// <summary>
        /// Internal: Last used value of the range of manager result values.
        /// </summary>
        ManagerReturnValueLast = 149,
        /// <summary>
        /// Internal: Maximum value of the range of manager result values.
        /// </summary>
        ManagerReturnValueEnd = 150,
        /// <summary>
        /// Internal: Start of the range of session result values.
        /// </summary>
        SessionReturnValueStart = 151,
        /// <summary>
        /// The secure connection failed. Check the account settings.
        /// </summary>
        InvalidToken = 152,
        /// <summary>
        /// The user provided URL is malformed.
        /// </summary>
        InvalidUrl = 153,
        /// <summary>
        /// Internal: Last used value of the range of session result values.
        /// </summary>
        SessionReturnValueLast = 154,
        /// <summary>
        /// Internal: Maximum value of the range of session result values.
        /// </summary>
        SessionReturnValueEnd = 155,
    }

    internal static class NativeLibraryHelpers
    {
        internal static string[] IntPtrToStringArray(IntPtr result, int result_length)
        {
            // an empty list is returned as a single null character
            if (result_length == 1)
            {
                return Array.Empty<string>();
            }

            byte[] bytes = new byte[result_length - 1];
            System.Runtime.InteropServices.Marshal.Copy(result, bytes, 0, result_length - 1);
            System.Runtime.InteropServices.Marshal.FreeCoTaskMem(result);
            return System.Text.Encoding.UTF8.GetString(bytes).Split('\0');
        }

        internal static void CheckStatus(IntPtr handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string message;
            string requestCorrelationVector;
            string responseCorrelationVector;

            Microsoft.Azure.RemoteRendering.status code = Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_error_details(handle, out message, out requestCorrelationVector, out responseCorrelationVector);

            string fullMessage;
            if (code == status.Failed)
            {
                throw new InvalidOperationException("Unexpected error in exception handling.");
            }
            else if (code != status.OK)
            {
                fullMessage = "Exception thrown and an unexpected error in exception handling.";
            }
            else
            {
                fullMessage = message + ". Request CV: " + requestCorrelationVector + ". Response CV: " + responseCorrelationVector + ".";
            }

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
                case status.CoreReturnValueStart:
                    throw new RRException(Result.CoreReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.Success:
                    throw new RRException(Result.Success, message, requestCorrelationVector, responseCorrelationVector);
                case status.Fail:
                    throw new RRException(Result.Fail, message, requestCorrelationVector, responseCorrelationVector);
                case status.Cancelled:
                    throw new RRException(Result.Cancelled, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidParam:
                    throw new RRException(Result.InvalidParam, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidType:
                    throw new RRException(Result.InvalidType, message, requestCorrelationVector, responseCorrelationVector);
                case status.BufferTooSmall_Deprecated:
                    throw new RRException(Result.BufferTooSmall_Deprecated, message, requestCorrelationVector, responseCorrelationVector);
                case status.NoConnection:
                    throw new RRException(Result.NoConnection, message, requestCorrelationVector, responseCorrelationVector);
                case status.ApiUnavailable:
                    throw new RRException(Result.ApiUnavailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyInitialized:
                    throw new RRException(Result.AlreadyInitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyDeinitialized:
                    throw new RRException(Result.AlreadyDeinitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.StringTooLong:
                    throw new RRException(Result.StringTooLong, message, requestCorrelationVector, responseCorrelationVector);
                case status.IndexOutOfRange:
                    throw new RRException(Result.IndexOutOfRange, message, requestCorrelationVector, responseCorrelationVector);
                case status.InProgress:
                    throw new RRException(Result.InProgress, message, requestCorrelationVector, responseCorrelationVector);
                case status.NotInitialized:
                    throw new RRException(Result.NotInitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.CoreReturnValueLast:
                    throw new RRException(Result.CoreReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.CoreReturnValueEnd:
                    throw new RRException(Result.CoreReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueStart:
                    throw new RRException(Result.LoadFileReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileNotFound:
                    throw new RRException(Result.FileNotFound, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidVersion:
                    throw new RRException(Result.InvalidVersion, message, requestCorrelationVector, responseCorrelationVector);
                case status.IncompatibleVersion_Deprecated:
                    throw new RRException(Result.IncompatibleVersion_Deprecated, message, requestCorrelationVector, responseCorrelationVector);
                case status.FailedToOpenFile:
                    throw new RRException(Result.FailedToOpenFile, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileDownloadFailed:
                    throw new RRException(Result.FileDownloadFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.ExceedsMemoryLimit:
                    throw new RRException(Result.ExceedsMemoryLimit, message, requestCorrelationVector, responseCorrelationVector);
                case status.CannotWriteTargetFile:
                    throw new RRException(Result.CannotWriteTargetFile, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileCorrupt:
                    throw new RRException(Result.FileCorrupt, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueLast:
                    throw new RRException(Result.LoadFileReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueEnd:
                    throw new RRException(Result.LoadFileReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueStart:
                    throw new RRException(Result.ObjectReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidId:
                    throw new RRException(Result.InvalidId, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidParentId:
                    throw new RRException(Result.InvalidParentId, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyExists:
                    throw new RRException(Result.AlreadyExists, message, requestCorrelationVector, responseCorrelationVector);
                case status.CyclicReference:
                    throw new RRException(Result.CyclicReference, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectLocked_Deprecated:
                    throw new RRException(Result.ObjectLocked_Deprecated, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueLast:
                    throw new RRException(Result.ObjectReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueEnd:
                    throw new RRException(Result.ObjectReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueStart:
                    throw new RRException(Result.ConnectionReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.NoServerCertificate:
                    throw new RRException(Result.NoServerCertificate, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakePortBusy:
                    throw new RRException(Result.HandshakePortBusy, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeUnreachable:
                    throw new RRException(Result.HandshakeUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeConnectionFailed:
                    throw new RRException(Result.HandshakeConnectionFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.AuthenticationFailed:
                    throw new RRException(Result.AuthenticationFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.RemotingVersionMismatch:
                    throw new RRException(Result.RemotingVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.IncompatibleTransportProtocols:
                    throw new RRException(Result.IncompatibleTransportProtocols, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeFailed:
                    throw new RRException(Result.HandshakeFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportPortBusy:
                    throw new RRException(Result.TransportPortBusy, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportUnreachable:
                    throw new RRException(Result.TransportUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportConnectionFailed:
                    throw new RRException(Result.TransportConnectionFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.ProtocolVersionMismatch:
                    throw new RRException(Result.ProtocolVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.ProtocolError:
                    throw new RRException(Result.ProtocolError, message, requestCorrelationVector, responseCorrelationVector);
                case status.VideoCodecNotAvailable:
                    throw new RRException(Result.VideoCodecNotAvailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionLost:
                    throw new RRException(Result.ConnectionLost, message, requestCorrelationVector, responseCorrelationVector);
                case status.DeviceLost:
                    throw new RRException(Result.DeviceLost, message, requestCorrelationVector, responseCorrelationVector);
                case status.DisconnectRequest:
                    throw new RRException(Result.DisconnectRequest, message, requestCorrelationVector, responseCorrelationVector);
                case status.Timeout:
                    throw new RRException(Result.Timeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyConnected:
                    throw new RRException(Result.AlreadyConnected, message, requestCorrelationVector, responseCorrelationVector);
                case status.ArrVersionMismatch:
                    throw new RRException(Result.ArrVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeNetworkUnreachable:
                    throw new RRException(Result.HandshakeNetworkUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeConnectionRefused:
                    throw new RRException(Result.HandshakeConnectionRefused, message, requestCorrelationVector, responseCorrelationVector);
                case status.VideoFormatNotAvailable:
                    throw new RRException(Result.VideoFormatNotAvailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.PeerDisconnectRequest:
                    throw new RRException(Result.PeerDisconnectRequest, message, requestCorrelationVector, responseCorrelationVector);
                case status.PeerDisconnectTimeout:
                    throw new RRException(Result.PeerDisconnectTimeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueLast:
                    throw new RRException(Result.ConnectionReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueEnd:
                    throw new RRException(Result.ConnectionReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueStart:
                    throw new RRException(Result.ManagerReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidToolId:
                    throw new RRException(Result.InvalidToolId, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerAlreadyCreated:
                    throw new RRException(Result.ManagerAlreadyCreated, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerNotCreatedYet:
                    throw new RRException(Result.ManagerNotCreatedYet, message, requestCorrelationVector, responseCorrelationVector);
                case status.OtherSessionConnected:
                    throw new RRException(Result.OtherSessionConnected, message, requestCorrelationVector, responseCorrelationVector);
                case status.BadStateTransition:
                    throw new RRException(Result.BadStateTransition, message, requestCorrelationVector, responseCorrelationVector);
                case status.FailedToStartTool:
                    throw new RRException(Result.FailedToStartTool, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueLast:
                    throw new RRException(Result.ManagerReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueEnd:
                    throw new RRException(Result.ManagerReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueStart:
                    throw new RRException(Result.SessionReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidToken:
                    throw new RRException(Result.InvalidToken, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidUrl:
                    throw new RRException(Result.InvalidUrl, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueLast:
                    throw new RRException(Result.SessionReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueEnd:
                    throw new RRException(Result.SessionReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
            }
        }

        internal static void CheckStatus(ulong handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string fullMessage = string.Format("An error occurred: {0} ({0:d})", value);

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
                case status.CoreReturnValueStart:
                    throw new RRException(Result.CoreReturnValueStart, fullMessage);
                case status.Success:
                    throw new RRException(Result.Success, fullMessage);
                case status.Fail:
                    throw new RRException(Result.Fail, fullMessage);
                case status.Cancelled:
                    throw new RRException(Result.Cancelled, fullMessage);
                case status.InvalidParam:
                    throw new RRException(Result.InvalidParam, fullMessage);
                case status.InvalidType:
                    throw new RRException(Result.InvalidType, fullMessage);
                case status.BufferTooSmall_Deprecated:
                    throw new RRException(Result.BufferTooSmall_Deprecated, fullMessage);
                case status.NoConnection:
                    throw new RRException(Result.NoConnection, fullMessage);
                case status.ApiUnavailable:
                    throw new RRException(Result.ApiUnavailable, fullMessage);
                case status.AlreadyInitialized:
                    throw new RRException(Result.AlreadyInitialized, fullMessage);
                case status.AlreadyDeinitialized:
                    throw new RRException(Result.AlreadyDeinitialized, fullMessage);
                case status.StringTooLong:
                    throw new RRException(Result.StringTooLong, fullMessage);
                case status.IndexOutOfRange:
                    throw new RRException(Result.IndexOutOfRange, fullMessage);
                case status.InProgress:
                    throw new RRException(Result.InProgress, fullMessage);
                case status.NotInitialized:
                    throw new RRException(Result.NotInitialized, fullMessage);
                case status.CoreReturnValueLast:
                    throw new RRException(Result.CoreReturnValueLast, fullMessage);
                case status.CoreReturnValueEnd:
                    throw new RRException(Result.CoreReturnValueEnd, fullMessage);
                case status.LoadFileReturnValueStart:
                    throw new RRException(Result.LoadFileReturnValueStart, fullMessage);
                case status.FileNotFound:
                    throw new RRException(Result.FileNotFound, fullMessage);
                case status.InvalidVersion:
                    throw new RRException(Result.InvalidVersion, fullMessage);
                case status.IncompatibleVersion_Deprecated:
                    throw new RRException(Result.IncompatibleVersion_Deprecated, fullMessage);
                case status.FailedToOpenFile:
                    throw new RRException(Result.FailedToOpenFile, fullMessage);
                case status.FileDownloadFailed:
                    throw new RRException(Result.FileDownloadFailed, fullMessage);
                case status.ExceedsMemoryLimit:
                    throw new RRException(Result.ExceedsMemoryLimit, fullMessage);
                case status.CannotWriteTargetFile:
                    throw new RRException(Result.CannotWriteTargetFile, fullMessage);
                case status.FileCorrupt:
                    throw new RRException(Result.FileCorrupt, fullMessage);
                case status.LoadFileReturnValueLast:
                    throw new RRException(Result.LoadFileReturnValueLast, fullMessage);
                case status.LoadFileReturnValueEnd:
                    throw new RRException(Result.LoadFileReturnValueEnd, fullMessage);
                case status.ObjectReturnValueStart:
                    throw new RRException(Result.ObjectReturnValueStart, fullMessage);
                case status.InvalidId:
                    throw new RRException(Result.InvalidId, fullMessage);
                case status.InvalidParentId:
                    throw new RRException(Result.InvalidParentId, fullMessage);
                case status.AlreadyExists:
                    throw new RRException(Result.AlreadyExists, fullMessage);
                case status.CyclicReference:
                    throw new RRException(Result.CyclicReference, fullMessage);
                case status.ObjectLocked_Deprecated:
                    throw new RRException(Result.ObjectLocked_Deprecated, fullMessage);
                case status.ObjectReturnValueLast:
                    throw new RRException(Result.ObjectReturnValueLast, fullMessage);
                case status.ObjectReturnValueEnd:
                    throw new RRException(Result.ObjectReturnValueEnd, fullMessage);
                case status.ConnectionReturnValueStart:
                    throw new RRException(Result.ConnectionReturnValueStart, fullMessage);
                case status.NoServerCertificate:
                    throw new RRException(Result.NoServerCertificate, fullMessage);
                case status.HandshakePortBusy:
                    throw new RRException(Result.HandshakePortBusy, fullMessage);
                case status.HandshakeUnreachable:
                    throw new RRException(Result.HandshakeUnreachable, fullMessage);
                case status.HandshakeConnectionFailed:
                    throw new RRException(Result.HandshakeConnectionFailed, fullMessage);
                case status.AuthenticationFailed:
                    throw new RRException(Result.AuthenticationFailed, fullMessage);
                case status.RemotingVersionMismatch:
                    throw new RRException(Result.RemotingVersionMismatch, fullMessage);
                case status.IncompatibleTransportProtocols:
                    throw new RRException(Result.IncompatibleTransportProtocols, fullMessage);
                case status.HandshakeFailed:
                    throw new RRException(Result.HandshakeFailed, fullMessage);
                case status.TransportPortBusy:
                    throw new RRException(Result.TransportPortBusy, fullMessage);
                case status.TransportUnreachable:
                    throw new RRException(Result.TransportUnreachable, fullMessage);
                case status.TransportConnectionFailed:
                    throw new RRException(Result.TransportConnectionFailed, fullMessage);
                case status.ProtocolVersionMismatch:
                    throw new RRException(Result.ProtocolVersionMismatch, fullMessage);
                case status.ProtocolError:
                    throw new RRException(Result.ProtocolError, fullMessage);
                case status.VideoCodecNotAvailable:
                    throw new RRException(Result.VideoCodecNotAvailable, fullMessage);
                case status.ConnectionLost:
                    throw new RRException(Result.ConnectionLost, fullMessage);
                case status.DeviceLost:
                    throw new RRException(Result.DeviceLost, fullMessage);
                case status.DisconnectRequest:
                    throw new RRException(Result.DisconnectRequest, fullMessage);
                case status.Timeout:
                    throw new RRException(Result.Timeout, fullMessage);
                case status.AlreadyConnected:
                    throw new RRException(Result.AlreadyConnected, fullMessage);
                case status.ArrVersionMismatch:
                    throw new RRException(Result.ArrVersionMismatch, fullMessage);
                case status.HandshakeNetworkUnreachable:
                    throw new RRException(Result.HandshakeNetworkUnreachable, fullMessage);
                case status.HandshakeConnectionRefused:
                    throw new RRException(Result.HandshakeConnectionRefused, fullMessage);
                case status.VideoFormatNotAvailable:
                    throw new RRException(Result.VideoFormatNotAvailable, fullMessage);
                case status.PeerDisconnectRequest:
                    throw new RRException(Result.PeerDisconnectRequest, fullMessage);
                case status.PeerDisconnectTimeout:
                    throw new RRException(Result.PeerDisconnectTimeout, fullMessage);
                case status.ConnectionReturnValueLast:
                    throw new RRException(Result.ConnectionReturnValueLast, fullMessage);
                case status.ConnectionReturnValueEnd:
                    throw new RRException(Result.ConnectionReturnValueEnd, fullMessage);
                case status.ManagerReturnValueStart:
                    throw new RRException(Result.ManagerReturnValueStart, fullMessage);
                case status.InvalidToolId:
                    throw new RRException(Result.InvalidToolId, fullMessage);
                case status.ManagerAlreadyCreated:
                    throw new RRException(Result.ManagerAlreadyCreated, fullMessage);
                case status.ManagerNotCreatedYet:
                    throw new RRException(Result.ManagerNotCreatedYet, fullMessage);
                case status.OtherSessionConnected:
                    throw new RRException(Result.OtherSessionConnected, fullMessage);
                case status.BadStateTransition:
                    throw new RRException(Result.BadStateTransition, fullMessage);
                case status.FailedToStartTool:
                    throw new RRException(Result.FailedToStartTool, fullMessage);
                case status.ManagerReturnValueLast:
                    throw new RRException(Result.ManagerReturnValueLast, fullMessage);
                case status.ManagerReturnValueEnd:
                    throw new RRException(Result.ManagerReturnValueEnd, fullMessage);
                case status.SessionReturnValueStart:
                    throw new RRException(Result.SessionReturnValueStart, fullMessage);
                case status.InvalidToken:
                    throw new RRException(Result.InvalidToken, fullMessage);
                case status.InvalidUrl:
                    throw new RRException(Result.InvalidUrl, fullMessage);
                case status.SessionReturnValueLast:
                    throw new RRException(Result.SessionReturnValueLast, fullMessage);
                case status.SessionReturnValueEnd:
                    throw new RRException(Result.SessionReturnValueEnd, fullMessage);
            }
        }
    }

    /// <summary>
    /// This interface is implemented by classes with events to help track callbacks.
    /// </summary>
    internal interface ICookie
    {
        /// <summary>
        /// Unique cookie value for callback identification.
        /// </summary>
        ulong Cookie { get; set; }
    }

    internal static class CookieTracker<T>
        where T : class, ICookie
    {
        private static ulong lastCookie;

        private static Dictionary<ulong, System.WeakReference<T>> tracked = new Dictionary<ulong, System.WeakReference<T>>();

        internal static void Add(T instance)
        {
            lock (tracked)
            {
                instance.Cookie = ++lastCookie;
                tracked[instance.Cookie] = new System.WeakReference<T>(instance);
            }
        }

        internal static T Lookup(ulong cookie)
        {
            T result;
            System.WeakReference<T> reference;
            bool found;

            lock (tracked)
            {
                found = tracked.TryGetValue(cookie, out reference);
            }

            if (!found)
            {
                return null;
            }

            found = reference.TryGetTarget(out result);

            if (!found)
            {
                lock (tracked)
                {
                    tracked.Remove(cookie);
                }
            }

            return result;
        }

        internal static void Remove(T instance)
        {
            lock (tracked)
            {
                tracked.Remove(instance.Cookie);
            }
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void DestructorHookDelegateNative(ulong cookie);

    /// <summary>
    /// Delegate for monitoring the progress of an asynchronous operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="progress">
    /// Progress fraction between 0 and 1 for how close the operation is to finishing.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LoadModelAsync"/>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ProgressHandlerNative(ulong cookie, float progress);

    /// <summary>
    /// Delegate for receiving log messages.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="level">
    /// Level of the log message.
    /// </param>
    /// <param name="message">
    /// Message as an IntPtr to the underlying UTF-8 char array.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager"/>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void LogHandlerNative(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message);

    /// <summary>
    /// Delegate for receiving connection status updates.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="status">
    /// The new connection status.
    /// </param>
    /// <param name="error">
    /// Additional error information in case of an unintended disconnect.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession"/>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ConnectionStatusHandlerNative(ulong cookie, Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error);

    /// <summary>
    /// Delegate for receiving notification when an update tick has completed on a <see cref="RemoteManager"/>.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void UpdatedHandlerNative(ulong cookie);

    /// <summary>
    /// Event handler for the completion of a <see cref="BoundsQueryAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void BoundsQueryHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="MetadataQueryAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void MetadataHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="LoadModelAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void LoadModelHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="LoadTextureAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void LoadTextureHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of <see cref="RaycastQueryAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void RaycastQueryHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="PerformanceAssessmentAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void PerformanceAssessmentHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="SessionAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void SessionHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a async <see cref="CreateSessionAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void CreateSessionHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Informs the application that a frontend requires an updated access token or authentication token.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="args">
    /// The callback handle.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend.TokenRequired"/>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void TokenRequiredDelegateNative(ulong cookie, IntPtr args);

    /// <summary>
    /// Event handler for the completion of a <see cref="SessionPropertiesArrayAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void SessionPropertiesArrayHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="StartAssetConversionAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void StartAssetConversionHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="ConversionStatusAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ConversionStatusHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of an <see cref="ArrInspectorAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ArrInspectorHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="SessionPropertiesAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="async">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void SessionPropertiesHandlerNative(ulong cookie, IntPtr async);

    /// <summary>
    /// Event handler for the completion of a <see cref="ConnectToRuntimeAsync"/> operation.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="result">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ConnectToRuntimeHandlerNative(ulong cookie, IntPtr result);

    internal static partial class NativeLibrary
    {
        internal const string DllName = "RemoteRenderingClient";
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_name(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_type(IntPtr handle, out Microsoft.Azure.RemoteRendering.MetadataValueType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_bool(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_int(IntPtr handle, out int result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_int64(IntPtr handle, out long result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_uint64(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_double(IntPtr handle, out double result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_entry_get_as_string(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_get_valid(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_get_metadata_by_name(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string name, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_get_metadata(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out IntPtr[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_meta_data_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_parent(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_parent(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_children(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_components(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_owner(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_destroy(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_find_component_of_type(ulong handle, Microsoft.Azure.RemoteRendering.ObjectType type, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_position(ulong handle, out Microsoft.Azure.RemoteRendering.Double3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_position(ulong handle, Microsoft.Azure.RemoteRendering.Double3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_rotation(ulong handle, out Microsoft.Azure.RemoteRendering.Quaternion result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_rotation(ulong handle, Microsoft.Azure.RemoteRendering.Quaternion value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_destroy(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_world_bounds_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_bounds_query_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.BoundsQueryHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_bounds_query_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.AABB3D result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_bounds_query_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_local_bounds_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_meta_data_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_metadata_query_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.MetadataHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_metadata_query_async_get_result(IntPtr handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_metadata_query_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_root(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_loaded_objects_of_type(IntPtr handle, Microsoft.Azure.RemoteRendering.ObjectType type, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_loaded_resource_of_type(IntPtr handle, Microsoft.Azure.RemoteRendering.ObjectType type, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_create(out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_valid(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_status(IntPtr handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_is_completed(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_is_ran_to_completion(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_get_is_faulted(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_async_base_dispose(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.LoadModelHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_get_result(IntPtr handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_get_progress(IntPtr handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_set_progress_updated(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ProgressHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_texture_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.LoadTextureHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_texture_async_get_result(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_texture_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_raycast_query_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.RaycastQueryHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_raycast_query_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out Microsoft.Azure.RemoteRendering.RayCastHitAbi[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_raycast_query_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_performance_assessment_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_performance_assessment_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.PerformanceAssessment result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_performance_assessment_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_base_session_async_get_context(IntPtr handle, out Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.SessionHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_create_session_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.CreateSessionHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_create_session_async_get_result(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_azure_frontend(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_create_azure_frontend_account_info_init(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi init, out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_message_logged(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.LogHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_token_required(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.TokenRequiredDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_get_access_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_set_access_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_get_authentication_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_set_authentication_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_log_level(ulong handle, out Microsoft.Azure.RemoteRendering.LogLevel result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_log_level(ulong handle, Microsoft.Azure.RemoteRendering.LogLevel value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_configuration(ulong handle, out Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_current_rendering_sessions_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_array_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_array_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_array_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_open_rendering_session(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string session_id, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_create_new_rendering_session_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_create_new_rendering_session_unsafe_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_start_asset_conversion_async_deprecated(ulong handle, Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_start_asset_conversion_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.StartAssetConversionHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_start_asset_conversion_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_start_asset_conversion_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_start_asset_conversion_async(ulong handle, Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi input_location, Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi output_location, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_start_asset_conversion_sas_async(ulong handle, Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi input_location, Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi output_location, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_get_asset_conversion_status_async(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string conversion_id, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ConversionStatusHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.ConversionSessionStatus result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_get_error_message(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_status_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_dispose(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_frontend_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_connect_to_arr_inspector_async(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string hostname, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_arr_inspector_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ArrInspectorHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_arr_inspector_async_get_result(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_arr_inspector_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_properties_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.SessionPropertiesHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_async_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_properties_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_stop_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_renew_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionUpdateParams update_params, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_session_uuid(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_connect_to_runtime(ulong handle, Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi input_params, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_connect_to_runtime_async_set_completed(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_connect_to_runtime_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_connect_to_runtime_params(ulong handle, out Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_connection_status(ulong handle, out Microsoft.Azure.RemoteRendering.ConnectionStatus result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_get_is_connected(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_set_connection_status_changed(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.ConnectionStatusHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_disconnect_from_runtime(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_azure_session_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_create_session_async_set_destructor_hook(IntPtr handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_get_intensity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_set_intensity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_get_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_set_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_normal(ulong handle, out Microsoft.Azure.RemoteRendering.Axis result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_normal(ulong handle, Microsoft.Azure.RemoteRendering.Axis value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_fade_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_fade_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_fade_length(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_fade_length(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_cut_plane_filter_mask(ulong handle, out byte result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_cut_plane_filter_mask(ulong handle, byte value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates feature, Microsoft.Azure.RemoteRendering.HierarchicalEnableState enabled_state);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates feature, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_tint_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_tint_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_cut_plane_filter_mask(ulong handle, out byte result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_cut_plane_filter_mask(ulong handle, byte value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_hidden_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_hidden_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_selected_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_selected_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_see_through_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_see_through_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_use_tint_color_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_use_tint_color_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_use_cut_plane_filter_mask_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_use_cut_plane_filter_mask_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_disable_collision_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_disable_collision_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_shell_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_shell_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_radius(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_radius(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_length(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_length(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_attenuation_cutoff(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_attenuation_cutoff(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_projected_cube_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_projected_cube_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_radius(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_radius(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_spot_angle_deg(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_spot_angle_deg(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_falloff_exponent(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_falloff_exponent(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_attenuation_cutoff(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_attenuation_cutoff(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_projected2d_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_projected2d_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_set_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_material_sub_type(ulong handle, out Microsoft.Azure.RemoteRendering.MaterialType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_copy_from(ulong handle, ulong other);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_used_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_set_material(ulong handle, int idx, ulong material);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_mesh(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_bounds(ulong handle, out Microsoft.Azure.RemoteRendering.AABB3D result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_set_mesh(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_pbr_flags(ulong handle, out Microsoft.Azure.RemoteRendering.PbrMaterialFeatures result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_pbr_flags(ulong handle, Microsoft.Azure.RemoteRendering.PbrMaterialFeatures value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_tex_coord_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_tex_coord_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_tex_coord_offset(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_tex_coord_offset(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_albedo_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_albedo_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_albedo_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_albedo_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_pbr_vertex_alpha_mode(ulong handle, out Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_pbr_vertex_alpha_mode(ulong handle, Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_normal_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_normal_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_aoscale(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_aoscale(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_aomap(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_aomap(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_roughness(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_roughness(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_roughness_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_roughness_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_metalness(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_metalness(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_metalness_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_metalness_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_alpha_clip_threshold(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_alpha_clip_threshold(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_fade_out(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_fade_out(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_fresnel_effect_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_fresnel_effect_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_fresnel_effect_exponent(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_fresnel_effect_exponent(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_color_flags(ulong handle, out Microsoft.Azure.RemoteRendering.ColorMaterialFeatures result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_color_flags(ulong handle, Microsoft.Azure.RemoteRendering.ColorMaterialFeatures value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_albedo_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_albedo_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_albedo_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_albedo_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_tex_coord_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_tex_coord_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_tex_coord_offset(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_tex_coord_offset(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_color_transparency_mode(ulong handle, out Microsoft.Azure.RemoteRendering.ColorTransparencyMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_color_transparency_mode(ulong handle, Microsoft.Azure.RemoteRendering.ColorTransparencyMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_fade_out(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_fade_out(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_vertex_mix(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_vertex_mix(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_alpha_clip_threshold(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_alpha_clip_threshold(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_fresnel_effect_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_fresnel_effect_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_fresnel_effect_exponent(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_fresnel_effect_exponent(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_near_plane(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_far_plane(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_near_and_far_plane(ulong handle, float near_plane, float far_plane);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_enable_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_enable_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_get_position(ulong handle, out Microsoft.Azure.RemoteRendering.Double3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_set_position(ulong handle, Microsoft.Azure.RemoteRendering.Double3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_get_rotation(ulong handle, out Microsoft.Azure.RemoteRendering.Quaternion result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_set_rotation(ulong handle, Microsoft.Azure.RemoteRendering.Quaternion value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_frame_count(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_frame_count(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_polygon_count(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_polygon_count(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_wireframe(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_wireframe(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_pulse_rate_hz(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_pulse_rate_hz(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_pulse_intensity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_pulse_intensity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_get_opacity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_set_opacity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_get_desaturation(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_set_desaturation(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_get_mode(ulong handle, out Microsoft.Azure.RemoteRendering.SingleSidedMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_set_mode(ulong handle, Microsoft.Azure.RemoteRendering.SingleSidedMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_get_sky_reflection_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_set_sky_reflection_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_highlighting(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_set_highlighting(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_api(ulong handle, out Microsoft.Azure.RemoteRendering.GraphicsApiType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_remote_focus_point(ulong handle, System.IntPtr coordinate_system, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity, out Microsoft.Azure.RemoteRendering.FocusPointResult result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_last_frame_statistics(ulong handle, out Microsoft.Azure.RemoteRendering.FrameStatistics stats, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_init_simulation(ulong handle, System.IntPtr d3d_device, System.IntPtr proxy_depth, System.IntPtr proxy_color, float refresh_rate, [MarshalAs(UnmanagedType.U1)] bool flip_blit_remote_frame_texture_vertically, [MarshalAs(UnmanagedType.U1)] bool flip_reproject_texture_vertically, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_deinit_simulation(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_update(ulong handle, Microsoft.Azure.RemoteRendering.SimulationUpdate update, out Microsoft.Azure.RemoteRendering.SimulationUpdate proxy_frame_update, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_blit_remote_frame_to_proxy(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_reproject_proxy(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_wmr_d3d11_blit_remote_frame(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_wmr_d3d11_update_user_coordinate_system(ulong handle, System.IntPtr coordinate_system, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_message_logged(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.LogHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_log_level(ulong handle, out Microsoft.Azure.RemoteRendering.LogLevel result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_log_level(ulong handle, Microsoft.Azure.RemoteRendering.LogLevel value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_model_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadModelParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_model_from_sasasync(ulong handle, Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_texture_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_load_texture_from_sasasync(ulong handle, Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi params_in, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_ray_cast_query_async(ulong handle, Microsoft.Azure.RemoteRendering.RayCast cast, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_query_server_performance_assessment_async(ulong handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_create_entity(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_create_material(ulong handle, Microsoft.Azure.RemoteRendering.MaterialType type, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_create_component(ulong handle, Microsoft.Azure.RemoteRendering.ObjectType component_type, ulong owner, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_camera_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_stage_space_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_sky_reflection_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_outline_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_zfighting_mitigation_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_shell_rendering_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_single_sided_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_get_debug_rendering_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_update(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_updated(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.UpdatedHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_manager_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_error_details(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result_message, [MarshalAs(UnmanagedType.LPStr)] out string result_requestCorrelationVector, [MarshalAs(UnmanagedType.LPStr)] out string result_responseCorrelationVector);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_handle_type(IntPtr handle, out Microsoft.Azure.RemoteRendering.HandleType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_handle_type_unsigned_long_long(ulong handle, out Microsoft.Azure.RemoteRendering.HandleType result);
    }

    // CODE STARTS HERE

    abstract class BasePrivateDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        protected abstract int InternalGetCount();
        protected abstract TKey InternalGetKey(int index);
        protected abstract TValue InternalGetItem(TKey key);
        protected abstract void InternalSetItem(TKey key, TValue value);
        protected abstract void InternalRemoveKey(TKey key);

        public TValue this[TKey key] { get { return InternalGetItem(key); } set { InternalSetItem(key, value); } }

        public ICollection<TKey> Keys { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).ToList().AsReadOnly(); } }

        public ICollection<TValue> Values { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).Select(k => InternalGetItem(k)).ToList().AsReadOnly(); } }

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public void Add(TKey key, TValue value)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                InternalSetItem(key, value);
                return;
            }
            throw new ArgumentException();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                TKey key = InternalGetKey(0);
                InternalRemoveKey(key);
            }
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            try
            {
                TValue value = InternalGetItem(item.Key);
                if (Comparer<TValue>.Default.Compare(value, item.Value) == 0)
                {
                    return true;
                }
                return false;
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
        }

        public bool ContainsKey(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            return true;
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public bool Remove(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            InternalRemoveKey(key);
            return true;
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            try
            {
                value = InternalGetItem(key);
                return true;
            }
            catch (KeyNotFoundException)
            {
                value = default(TValue);
                return false;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }
    }

    abstract class BasePrivateList<T> : IList<T>
    {
        protected abstract int InternalGetCount();
        protected abstract T InternalGetItem(int index);
        protected abstract void InternalSetItem(int index, T value);
        protected abstract void InternalRemoveItem(int index);

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public T this[int index] { get { return InternalGetItem(index); } set { InternalSetItem(index, value); } }

        public int IndexOf(T item)
        {
            int count = InternalGetCount();
            for (int i = 0; i < count; i++)
            {
                if (Comparer<T>.Default.Compare(item, InternalGetItem(i)) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        public void Insert(int index, T item)
        {
            InternalSetItem(index, item);
        }

        public void RemoveAt(int index)
        {
            InternalRemoveItem(index);
        }

        public void Add(T item)
        {
            InternalSetItem(InternalGetCount(), item);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                InternalRemoveItem(0);
            }
        }

        public bool Contains(T item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            for (int i = 0; i < Count; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public bool Remove(T item)
        {
            int index = IndexOf(item);
            if (index < 0) return false;
            InternalRemoveItem(index);
            return true;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }
    }

    static class Factories
    {
        internal static Microsoft.Azure.RemoteRendering.AsyncBase AsyncBaseFactory(IntPtr handle, bool transfer)
        {
            if (handle == IntPtr.Zero)
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type(handle, out result));
            Microsoft.Azure.RemoteRendering.AsyncBase result_object;
            switch (result)
            {
                case HandleType.BoundsQueryAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(handle, transfer);
                    break;
                case HandleType.AsyncBase:
                    result_object = new Microsoft.Azure.RemoteRendering.AsyncBase(handle, transfer);
                    break;
                case HandleType.MetadataQueryAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.MetadataQueryAsync(handle, transfer);
                    break;
                case HandleType.LoadModelAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.LoadModelAsync(handle, transfer);
                    break;
                case HandleType.LoadTextureAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.LoadTextureAsync(handle, transfer);
                    break;
                case HandleType.RaycastQueryAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.RaycastQueryAsync(handle, transfer);
                    break;
                case HandleType.PerformanceAssessmentAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync(handle, transfer);
                    break;
                case HandleType.BaseSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.BaseSessionAsync(handle, transfer);
                    break;
                case HandleType.SessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionAsync(handle, transfer);
                    break;
                case HandleType.CreateSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.CreateSessionAsync(handle, transfer);
                    break;
                case HandleType.ConnectToRuntimeAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync(handle, transfer);
                    break;
                case HandleType.ArrInspectorAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ArrInspectorAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesArrayAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(handle, transfer);
                    break;
                case HandleType.StartAssetConversionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(handle, transfer);
                    break;
                case HandleType.ConversionStatusAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.BaseSessionAsync BaseSessionAsyncFactory(IntPtr handle, bool transfer)
        {
            if (handle == IntPtr.Zero)
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type(handle, out result));
            Microsoft.Azure.RemoteRendering.BaseSessionAsync result_object;
            switch (result)
            {
                case HandleType.SessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionAsync(handle, transfer);
                    break;
                case HandleType.BaseSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.BaseSessionAsync(handle, transfer);
                    break;
                case HandleType.CreateSessionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.CreateSessionAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(handle, transfer);
                    break;
                case HandleType.SessionPropertiesArrayAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(handle, transfer);
                    break;
                case HandleType.StartAssetConversionAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(handle, transfer);
                    break;
                case HandleType.ConversionStatusAsync:
                    result_object = new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ObjectBase ObjectBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ObjectBase result_object;
            switch (result)
            {
                case HandleType.ComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ComponentBase(handle, transfer);
                    break;
                case HandleType.ObjectBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ObjectBase(handle, transfer);
                    break;
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.CutPlaneComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.CutPlaneComponent(handle, transfer);
                    break;
                case HandleType.HierarchicalStateOverrideComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent(handle, transfer);
                    break;
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                case HandleType.MeshComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.MeshComponent(handle, transfer);
                    break;
                case HandleType.Entity:
                    result_object = new Microsoft.Azure.RemoteRendering.Entity(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ComponentBase ComponentBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            switch (result)
            {
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.ComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ComponentBase(handle, transfer);
                    break;
                case HandleType.CutPlaneComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.CutPlaneComponent(handle, transfer);
                    break;
                case HandleType.HierarchicalStateOverrideComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent(handle, transfer);
                    break;
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                case HandleType.MeshComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.MeshComponent(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.LightComponentBase LightComponentBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.LightComponentBase result_object;
            switch (result)
            {
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ResourceBase ResourceBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ResourceBase result_object;
            switch (result)
            {
                case HandleType.Material:
                    result_object = new Microsoft.Azure.RemoteRendering.Material(handle, transfer);
                    break;
                case HandleType.ResourceBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ResourceBase(handle, transfer);
                    break;
                case HandleType.PbrMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.PbrMaterial(handle, transfer);
                    break;
                case HandleType.ColorMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.ColorMaterial(handle, transfer);
                    break;
                case HandleType.Mesh:
                    result_object = new Microsoft.Azure.RemoteRendering.Mesh(handle, transfer);
                    break;
                case HandleType.Texture:
                    result_object = new Microsoft.Azure.RemoteRendering.Texture(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.Material MaterialFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.Material result_object;
            switch (result)
            {
                case HandleType.PbrMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.PbrMaterial(handle, transfer);
                    break;
                case HandleType.Material:
                    result_object = new Microsoft.Azure.RemoteRendering.Material(handle, transfer);
                    break;
                case HandleType.ColorMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.ColorMaterial(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.GraphicsBinding GraphicsBindingFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.GraphicsBinding result_object;
            switch (result)
            {
                case HandleType.GraphicsBindingSimD3d11:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11(handle, transfer);
                    break;
                case HandleType.GraphicsBinding:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBinding(handle, transfer);
                    break;
                case HandleType.GraphicsBindingWmrD3d11:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBindingWmrD3d11(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

    }

    /// <summary>
    /// This struct is for platform specific utility functions.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PlatformUtils
    {
    }

    /// <summary>
    /// 2-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float2
    {
        public float x;

        public float y;

    }

    /// <summary>
    /// 3-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float3
    {
        public float x;

        public float y;

        public float z;

    }

    /// <summary>
    /// 4-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float4
    {
        public float x;

        public float y;

        public float z;

        public float w;

    }

    /// <summary>
    /// 3-component vector with double precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Double3
    {
        public double x;

        public double y;

        public double z;

    }

    /// <summary>
    /// 4-component color (red, green, blue, alpha) with single precision.
    /// </summary>
    /// <remarks>
    /// Values are in 0..1 range, but can go above that range to represent high-dynamic range (HDR) colors.
    /// The color values are assumed to be in 'linear space', not in 'Gamma space'.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Color4
    {
        public float r;

        public float g;

        public float b;

        public float a;

    }

    /// <summary>
    /// 4 component color (red, green, blue, alpha) based on 8 bit components [0..255].
    /// </summary>
    /// <remarks>
    /// Values are in 0..255 range and represent low-dynamic range (LDR) colors.
    /// The color values are assumed to be in 'Gamma space'.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Color4UbChannels
    {
        public byte r;

        public byte g;

        public byte b;

        public byte a;

    }

    /// <summary>
    /// 4 component color (red, green, blue, alpha) based on 8 bit components [0..255].
    /// </summary>
    /// <remarks>
    /// Values are in 0..255 range and represent low-dynamic range (LDR) colors.
    /// The color values are assumed to be in 'Gamma space'.
    /// </remarks>
    [StructLayout(LayoutKind.Explicit)]
    public partial struct Color4Ub
    {
        [FieldOffset(0)]
        /// <summary>
        /// Interprets the color as r,g,b,a byte values.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4UbChannels channels;

        [FieldOffset(0)]
        /// <summary>
        /// Interprets the color as a single 32bit integer. Used for assignments and comparisons.
        /// </summary>
        public int bytes;

    }

    /// <summary>
    /// Single precision quaternion to describe an object rotation.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Quaternion
    {
        public float x;

        public float y;

        public float z;

        public float w;

    }

    /// <summary>
    /// 4x4 matrix based on single precision components.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Matrix4x4
    {
        public Microsoft.Azure.RemoteRendering.Float4 column0;

        public Microsoft.Azure.RemoteRendering.Float4 column1;

        public Microsoft.Azure.RemoteRendering.Float4 column2;

        public Microsoft.Azure.RemoteRendering.Float4 column3;

    }

    /// <summary>
    /// Axis-aligned bounding box, based on double precision min and max position.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct AABB3D
    {
        /// <summary>
        /// Position of the minimum corner.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 min;

        /// <summary>
        /// Position of the maximum corner.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 max;

    }

    /// <summary>
    /// Wrapper for a portable TimeSpan structure.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct ARRTimeSpan
    {
        /// <summary>
        /// Hour: 0 - 23
        /// </summary>
        public int hour;

        /// <summary>
        /// Minute: 0 - 59
        /// </summary>
        public int minute;

        /// <summary>
        /// Second: 0 - 59
        /// </summary>
        public int second;

    }

    /// <summary>
    /// Frame statistics to do client-side performance assessment. See <see cref="GraphicsBinding.GetLastFrameStatistics(FrameStatistics)"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding.GetLastFrameStatistics(Microsoft.Azure.RemoteRendering.FrameStatistics)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct FrameStatistics
    {
        /// <summary>
        /// Time between the client's request for a new remote frame and the arrival of the requested frame.
        /// </summary>
        /// <remarks>
        /// This includes, but is not limited to, the network round-trip latency and delays caused by operations necessary
        /// on the server side before sending, and on the client side after receiving (rendering, video encoding/decoding, etc).
        /// </remarks>
        public float latencyPoseToReceive;

        /// <summary>
        /// Time between arrival of a new frame and its actual usage.
        /// </summary>
        /// <remarks>
        /// Gives the latency between the availability of new frame data and
        /// its actual use. This contains client-side CPU drawcall time, frame reprojection, etc.
        /// </remarks>
        public float latencyReceiveToPresent;

        /// <summary>
        /// The latency until the finished frame is displayed.
        /// </summary>
        /// <remarks>
        /// This mainly contains aspects like GPU workload and waiting for V-sync but
        /// can also encompass overhead introduced by the rendering infrastructure.
        /// For example, some game engines introduce a scheduling overhead in this phase.
        /// </remarks>
        public float latencyPresentToDisplay;

        /// <summary>
        /// The time between subsequent calls to PresentFrame on the CPU.
        /// </summary>
        /// <remarks>
        /// Values greater than the display duration (for example 16.6 ms on a 60-Hz client device)
        /// indicate issues caused by the client application not finishing its CPU workload in time.
        /// </remarks>
        public float timeSinceLastPresent;

        /// <summary>
        /// Number of received frames in the last second that were used on the device more than once.
        /// </summary>
        /// <remarks>
        /// Non-zero values indicate that frames had to be reprojected either due to network jitter or excessive server rendering time.
        /// </remarks>
        public uint videoFrameReusedCount;

        /// <summary>
        /// Number of received frames in the last second that were decoded, but not shown on display because a newer frame has arrived.
        /// </summary>
        /// <remarks>
        /// Non-zero values indicate that network jitter caused multiple frames to be delayed and then arrived on the client device together in a burst.
        /// </remarks>
        public uint videoFramesSkipped;

        /// <summary>
        /// The number of frames received from the server in the last second.
        /// </summary>
        public uint videoFramesReceived;

        /// <summary>
        /// Very similar to <see cref="FrameStatistics.videoFramesSkipped"/>, but the reason for being discarded is that a frame came in so late that it couldn't even be correlated with any pending pose anymore. If this happens, there is some severe network contention.
        /// </summary>
        public uint videoFramesDiscarded;

        /// <summary>
        /// Minimum amount of time between two consecutive frames arriving during the last second.
        /// </summary>
        /// <remarks>
        /// Together with <see cref="FrameStatistics.videoFrameMaxDelta"/> this range gives an indication of jitter caused either by the network or video codec.
        /// </remarks>
        public float videoFrameMinDelta;

        /// <summary>
        /// Maximum amount of time between two consecutive frames arriving during the last second.
        /// </summary>
        /// <remarks>
        /// Together with <see cref="FrameStatistics.videoFrameMinDelta"/> this range gives an indication of jitter caused either by the network or video codec.
        /// </remarks>
        public float videoFrameMaxDelta;

    }

    /// <summary>
    /// Describes a single performance assessment value. See <see cref="PerformanceAssessment"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PerformanceAssessment"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PerformanceInformation
    {
        /// <summary>
        /// Aggregated value to assess.
        /// </summary>
        public float aggregate;

        /// <summary>
        /// Rating for the aggregate value.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceRating rating;

    }

    /// <summary>
    /// Performance assessment of Remote Rendering statistics. See <see cref="RemoteManager.QueryServerPerformanceAssessmentAsync"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.QueryServerPerformanceAssessmentAsync"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PerformanceAssessment
    {
        /// <summary>
        /// Average CPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation timeCPU;

        /// <summary>
        /// Average GPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation timeGPU;

        /// <summary>
        /// Total CPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation utilizationCPU;

        /// <summary>
        /// Total GPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation utilizationGPU;

        /// <summary>
        /// Total main memory utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation memoryCPU;

        /// <summary>
        /// Total dedicated video memory utilization in percent of the server GPU.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation memoryGPU;

        /// <summary>
        /// Approximate average round-trip network latency in milliseconds.
        /// </summary>
        /// <remarks>
        /// The value is computed by subtracting actual server rendering time from <see cref="FrameStatistics.latencyPoseToReceive"/>.
        /// While this approximation is not accurate, it gives some indication of the network latency isolated from the latency values computed on the client.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation networkLatency;

        /// <summary>
        /// Number of triangles rendered in one frame.
        /// </summary>
        /// <remarks>
        /// This number also includes the triangles that are culled during rendering.
        /// That means, this number does not vary a lot across different camera positions, but the performance on the other hand may vary a lot,
        /// depending on the triangle culling rate.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/limits">Remote Rendering limitations</seealso>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation polygonsRendered;

    }

    /// <summary>
    /// When <see cref="GraphicsBindingSimD3d11"/> is used, this must be filled out and passed to <see cref="GraphicsBindingSimD3d11.Update(SimulationUpdate,SimulationUpdate)"/> once per frame.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11.Update(Microsoft.Azure.RemoteRendering.SimulationUpdate,Microsoft.Azure.RemoteRendering.SimulationUpdate)"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SimulationUpdate
    {
        /// <summary>
        /// Frame counter, should be incremented every frame.
        /// </summary>
        public uint frameId;

        /// <summary>
        /// Distance (in meters) to the camera's near clipping plane.
        /// </summary>
        public float nearPlaneDistance;

        /// <summary>
        /// Distance (in meters) to the camera's far clipping plane.
        /// </summary>
        public float farPlaneDistance;

        /// <summary>
        /// Horizontal resolution.
        /// </summary>
        public int renderTargetWidth;

        /// <summary>
        /// Vertical resolution.
        /// </summary>
        public int renderTargetHeight;

        /// <summary>
        /// Camera perspective projection matrix.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Matrix4x4 projection;

        /// <summary>
        /// Camera transform matrix (translation and rotation).
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Matrix4x4 viewTransform;

    }

    /// <summary>
    /// Parameters for doing a raycast.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct RayCast
    {
        /// <summary>
        /// Start position for the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 StartPos;

        /// <summary>
        /// End position of the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 EndPos;

        /// <summary>
        /// See <see cref="HitCollectionPolicy"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HitCollectionPolicy HitCollection;

        /// <summary>
        /// The maximum number of hits to collect. Only needed for <see cref="HitCollectionPolicy.AllHits"/>.
        /// </summary>
        public uint MaxHits;

        /// <summary>
        /// Reserved for future use.
        /// </summary>
        public uint CollisionMask;

    }

    /// <summary>
    /// Contains information about a single raycast hit.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RayCastHitAbi
    {
        /// <summary>
        /// The <see cref="Entity"/> that was hit with the raycast.
        /// </summary>
        public ulong HitObject;

        /// <summary>
        /// The ID or index of the part that was hit.
        /// </summary>
        /// <remarks>
        /// This can be used to get the <see cref="Material"/> at the raycast intersection.
        /// First query for the <see cref="MeshComponent"/>, then query for the material using <c>MeshComponent.UsedMaterials[SubPartId].</c>
        /// </remarks>
        public int SubPartId;

        /// <summary>
        /// The world space position where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 HitPosition;

        /// <summary>
        /// The world space normal where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float3 HitNormal;

        /// <summary>
        /// Distance along the normalized ray direction to the hit.
        /// </summary>
        /// <remarks>
        /// <see cref="RayCast.StartPos"/> + normalize(<see cref="RayCast.EndPos"/> - <see cref="RayCast.StartPos"/>) * <see cref="RayCastHit.DistanceToHit"/> == <see cref="RayCastHit.HitPosition"/>
        /// </remarks>
        public double DistanceToHit;

        public Microsoft.Azure.RemoteRendering.RayCastHit Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCastHitAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RayCastHit Convert(Microsoft.Azure.RemoteRendering.RayCastHitAbi value)
        {
            Microsoft.Azure.RemoteRendering.RayCastHit result = new Microsoft.Azure.RemoteRendering.RayCastHit();

            result.HitObject = value.HitObject != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.HitObject, false) : null;
            result.SubPartId = value.SubPartId;
            result.HitPosition = value.HitPosition;
            result.HitNormal = value.HitNormal;
            result.DistanceToHit = value.DistanceToHit;

            return result;
        }
    }

    /// <summary>
    /// Contains information about a single raycast hit.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    public partial struct RayCastHit
    {
        /// <summary>
        /// The <see cref="Entity"/> that was hit with the raycast.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity HitObject;

        /// <summary>
        /// The ID or index of the part that was hit.
        /// </summary>
        /// <remarks>
        /// This can be used to get the <see cref="Material"/> at the raycast intersection.
        /// First query for the <see cref="MeshComponent"/>, then query for the material using <c>MeshComponent.UsedMaterials[SubPartId].</c>
        /// </remarks>
        public int SubPartId;

        /// <summary>
        /// The world space position where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 HitPosition;

        /// <summary>
        /// The world space normal where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float3 HitNormal;

        /// <summary>
        /// Distance along the normalized ray direction to the hit.
        /// </summary>
        /// <remarks>
        /// <see cref="RayCast.StartPos"/> + normalize(<see cref="RayCast.EndPos"/> - <see cref="RayCast.StartPos"/>) * <see cref="RayCastHit.DistanceToHit"/> == <see cref="RayCastHit.HitPosition"/>
        /// </remarks>
        public double DistanceToHit;

        internal Microsoft.Azure.RemoteRendering.RayCastHitAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCastHit.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RayCastHitAbi Convert(Microsoft.Azure.RemoteRendering.RayCastHit value)
        {
            Microsoft.Azure.RemoteRendering.RayCastHitAbi result = new Microsoft.Azure.RemoteRendering.RayCastHitAbi();

            result.HitObject = value.HitObject?.handle ?? default(ulong);
            result.SubPartId = value.SubPartId;
            result.HitPosition = value.HitPosition;
            result.HitNormal = value.HitNormal;
            result.DistanceToHit = value.DistanceToHit;

            return result;
        }
    }

    /// <summary>
    /// Account information and domain to associate an <see cref="AzureFrontend"/> instance with.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AzureFrontendAccountInfoAbi
    {
        /// <summary>
        /// Domain that will be used to generate sessions for the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// The domain is of the form [region].mixedreality.azure.com.
        /// [region] should be selected based on the region closest to the user. For example, westus2.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountDomain;

        /// <summary>
        /// The ID of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountId;

        /// <summary>
        /// The key of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountKey;

        /// <summary>
        /// An access token for the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccessToken;

        /// <summary>
        /// An authentication token for Azure Active Directory (AAD).
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AuthenticationToken;

        public Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo Convert()
        {
            return Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo Convert(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi value)
        {
            Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo result = new Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo();

            result.AccountDomain = value.AccountDomain;
            result.AccountId = value.AccountId;
            result.AccountKey = value.AccountKey;
            result.AccessToken = value.AccessToken;
            result.AuthenticationToken = value.AuthenticationToken;

            return result;
        }
    }

    /// <summary>
    /// Account information and domain to associate an <see cref="AzureFrontend"/> instance with.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend"/>
    public partial struct AzureFrontendAccountInfo
    {
        /// <summary>
        /// Domain that will be used to generate sessions for the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// The domain is of the form [region].mixedreality.azure.com.
        /// [region] should be selected based on the region closest to the user. For example, westus2.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// </remarks>
        public string AccountDomain;

        /// <summary>
        /// The ID of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        public string AccountId;

        /// <summary>
        /// The key of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        public string AccountKey;

        /// <summary>
        /// An access token for the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        public string AccessToken;

        /// <summary>
        /// An authentication token for Azure Active Directory (AAD).
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        public string AuthenticationToken;

        internal Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi Convert(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo value)
        {
            Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi result = new Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi();

            result.AccountDomain = value.AccountDomain;
            result.AccountId = value.AccountId;
            result.AccountKey = value.AccountKey;
            result.AccessToken = value.AccessToken;
            result.AuthenticationToken = value.AuthenticationToken;

            return result;
        }
    }

    /// <summary>
    /// Parameters for connecting to the runtime of an <see cref="AzureSession"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.ConnectToRuntime(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct ConnectToRuntimeParamsAbi
    {
        /// <summary>
        /// Rendering mode to be used.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ServiceRenderMode mode;

        /// <summary>
        /// Internal flag used to ignore SSL certification. Should be set to <c>false</c> (default) for most applications.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)]
        public bool ignoreCertificateValidation;

        public Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams Convert(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams result = new Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams();

            result.mode = value.mode;
            result.ignoreCertificateValidation = value.ignoreCertificateValidation;

            return result;
        }
    }

    /// <summary>
    /// Parameters for connecting to the runtime of an <see cref="AzureSession"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.ConnectToRuntime(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    public partial struct ConnectToRuntimeParams
    {
        /// <summary>
        /// Rendering mode to be used.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ServiceRenderMode mode;

        /// <summary>
        /// Internal flag used to ignore SSL certification. Should be set to <c>false</c> (default) for most applications.
        /// </summary>
        public bool ignoreCertificateValidation;

        internal Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi Convert(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams value)
        {
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi result = new Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi();

            result.mode = value.mode;
            result.ignoreCertificateValidation = value.ignoreCertificateValidation;

            return result;
        }
    }

    /// <summary>
    /// Parameters for converting an asset.
    /// </summary>
    /// <remarks>
    /// This structure is deprecated.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend.StartAssetConversionAsync_Deprecated(Microsoft.Azure.RemoteRendering.AssetConversionParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/configure-model-conversion">Configure the model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionParamsAbi
    {
        /// <summary>
        /// Model name.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ModelName;

        /// <summary>
        /// Input container, (public) URIs or URIs with an embedded SAS token.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ModelUrl;

        /// <summary>
        /// Output container SAS URI.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AssetContainerUrl;

        /// <summary>
        /// Optional
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string RenderingSettings;

        /// <summary>
        /// Optional
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string MaterialOverrides;

        public Microsoft.Azure.RemoteRendering.AssetConversionParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionParams result = new Microsoft.Azure.RemoteRendering.AssetConversionParams();

            result.ModelName = value.ModelName;
            result.ModelUrl = value.ModelUrl;
            result.AssetContainerUrl = value.AssetContainerUrl;
            result.RenderingSettings = value.RenderingSettings;
            result.MaterialOverrides = value.MaterialOverrides;

            return result;
        }
    }

    /// <summary>
    /// Parameters for converting an asset.
    /// </summary>
    /// <remarks>
    /// This structure is deprecated.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend.StartAssetConversionAsync_Deprecated(Microsoft.Azure.RemoteRendering.AssetConversionParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/configure-model-conversion">Configure the model conversion</seealso>
    public partial struct AssetConversionParams
    {
        /// <summary>
        /// Model name.
        /// </summary>
        public string ModelName;

        /// <summary>
        /// Input container, (public) URIs or URIs with an embedded SAS token.
        /// </summary>
        public string ModelUrl;

        /// <summary>
        /// Output container SAS URI.
        /// </summary>
        public string AssetContainerUrl;

        /// <summary>
        /// Optional
        /// </summary>
        public string RenderingSettings;

        /// <summary>
        /// Optional
        /// </summary>
        public string MaterialOverrides;

        internal Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi();

            result.ModelName = value.ModelName;
            result.ModelUrl = value.ModelUrl;
            result.AssetContainerUrl = value.AssetContainerUrl;
            result.RenderingSettings = value.RenderingSettings;
            result.MaterialOverrides = value.MaterialOverrides;

            return result;
        }
    }

    /// <summary>
    /// Parameters for referencing a blob container for asset conversion.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionInputParams"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionOutputParams"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionBlobContainerAbi
    {
        /// <summary>
        /// Name of the Azure Storage account to access.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageAccountName;

        /// <summary>
        /// The blob container inside the Azure Storage account to access.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string BlobContainerName;

        /// <summary>
        /// The folder to reference inside the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string FolderPath;

        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer Convert(Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer result = new Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.FolderPath = value.FolderPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for referencing a blob container for asset conversion.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionInputParams"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionOutputParams"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionBlobContainer
    {
        /// <summary>
        /// Name of the Azure Storage account to access.
        /// </summary>
        public string StorageAccountName;

        /// <summary>
        /// The blob container inside the Azure Storage account to access.
        /// </summary>
        public string BlobContainerName;

        /// <summary>
        /// The folder to reference inside the blob container.
        /// </summary>
        public string FolderPath;

        internal Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.FolderPath = value.FolderPath;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionInputParamsAbi
    {
        /// <summary>
        /// The blob container from which to read the source asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Path to the source asset within the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string InputAssetPath;

        public Microsoft.Azure.RemoteRendering.AssetConversionInputParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionInputParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputParams result = new Microsoft.Azure.RemoteRendering.AssetConversionInputParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionInputParams
    {
        /// <summary>
        /// The blob container from which to read the source asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Path to the source asset within the blob container.
        /// </summary>
        public string InputAssetPath;

        internal Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionOutputParamsAbi
    {
        /// <summary>
        /// The blob container to which to write the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Output path for the converted asset within the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputAssetPath;

        public Microsoft.Azure.RemoteRendering.AssetConversionOutputParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionOutputParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputParams result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionOutputParams
    {
        /// <summary>
        /// The blob container to which to write the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Output path for the converted asset within the blob container.
        /// </summary>
        public string OutputAssetPath;

        internal Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionInputSasParamsAbi
    {
        /// <summary>
        /// The blob container from which to read the source asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Path to the source asset within the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string InputAssetPath;

        /// <summary>
        /// SAS token for read access to the container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ContainerReadListSas;

        public Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams result = new Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;
            result.ContainerReadListSas = value.ContainerReadListSas;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionInputSasParams
    {
        /// <summary>
        /// The blob container from which to read the source asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Path to the source asset within the blob container.
        /// </summary>
        public string InputAssetPath;

        /// <summary>
        /// SAS token for read access to the container.
        /// </summary>
        public string ContainerReadListSas;

        internal Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.InputAssetPath = value.InputAssetPath;
            result.ContainerReadListSas = value.ContainerReadListSas;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionOutputSasParamsAbi
    {
        /// <summary>
        /// The blob container to which to write the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainerAbi BlobContainerInformation;

        /// <summary>
        /// Output path for the converted asset within the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputAssetPath;

        /// <summary>
        /// SAS token granting write access to the container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ContainerWriteSas;

        public Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;
            result.ContainerWriteSas = value.ContainerWriteSas;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionOutputSasParams
    {
        /// <summary>
        /// The blob container to which to write the converted asset.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionBlobContainer BlobContainerInformation;

        /// <summary>
        /// Output path for the converted asset within the blob container.
        /// </summary>
        public string OutputAssetPath;

        /// <summary>
        /// SAS token granting write access to the container.
        /// </summary>
        public string ContainerWriteSas;

        internal Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi();

            result.BlobContainerInformation = value.BlobContainerInformation.Convert();
            result.OutputAssetPath = value.OutputAssetPath;
            result.ContainerWriteSas = value.ContainerWriteSas;

            return result;
        }
    }

    /// <summary>
    /// Parameters for creating a rendering session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend.CreateNewRenderingSessionAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct RenderingSessionCreationParams
    {
        /// <summary>
        /// Specifies how long the rendering session should be active before it is shut down.
        /// </summary>
        /// <remarks>
        /// The lease time starts the moment that the rendering server has finished booting.
        /// From that point on, it will be active for the specified lease time, unless it is either manually shut down earlier,
        /// or the lease time is extended beyond the original request.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        /// <summary>
        /// On what type of server to create the rendering session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

    }

    /// <summary>
    /// Internal struct.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionCreationParamsUnsafeAbi
    {
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        [MarshalAs(UnmanagedType.LPStr)]
        public string Size;

        public Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe();

            result.MaxLease = value.MaxLease;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Internal struct.
    /// </summary>
    public partial struct RenderingSessionCreationParamsUnsafe
    {
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        public string Size;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi();

            result.MaxLease = value.MaxLease;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Parameters for updating a rendering session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct RenderingSessionUpdateParams
    {
        /// <summary>
        /// The new lease time to use for the rendering session.
        /// </summary>
        /// <remarks>
        /// This replaces any previously set lease time. To extend the lease, pass in a larger value than before. You can also shorten the previously requested lease time by passing in a smaller value.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

    }

    /// <summary>
    /// Extended return value information for <see cref="AzureSession"/> and <see cref="AzureFrontend"/> async calls.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.BaseSessionAsync"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct SessionGeneralContextAbi
    {
        /// <summary>
        /// See <see cref="Result"/> for details in case of failure.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Result;

        /// <summary>
        /// HTTP response code.
        /// </summary>
        public uint HttpResponseCode;

        /// <summary>
        /// Depending on the type of error, this string may contain additional information.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ErrorMessage;

        /// <summary>
        /// Request correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string RequestCorrelationVector;

        /// <summary>
        /// Response correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ResponseCorrelationVector;

        public Microsoft.Azure.RemoteRendering.SessionGeneralContext Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.SessionGeneralContext Convert(Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi value)
        {
            Microsoft.Azure.RemoteRendering.SessionGeneralContext result = new Microsoft.Azure.RemoteRendering.SessionGeneralContext();

            result.Result = value.Result;
            result.HttpResponseCode = value.HttpResponseCode;
            result.ErrorMessage = value.ErrorMessage;
            result.RequestCorrelationVector = value.RequestCorrelationVector;
            result.ResponseCorrelationVector = value.ResponseCorrelationVector;

            return result;
        }
    }

    /// <summary>
    /// Extended return value information for <see cref="AzureSession"/> and <see cref="AzureFrontend"/> async calls.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.BaseSessionAsync"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend"/>
    public partial struct SessionGeneralContext
    {
        /// <summary>
        /// See <see cref="Result"/> for details in case of failure.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Result;

        /// <summary>
        /// HTTP response code.
        /// </summary>
        public uint HttpResponseCode;

        /// <summary>
        /// Depending on the type of error, this string may contain additional information.
        /// </summary>
        public string ErrorMessage;

        /// <summary>
        /// Request correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        public string RequestCorrelationVector;

        /// <summary>
        /// Response correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        public string ResponseCorrelationVector;

        internal Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionGeneralContext.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi Convert(Microsoft.Azure.RemoteRendering.SessionGeneralContext value)
        {
            Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result = new Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi();

            result.Result = value.Result;
            result.HttpResponseCode = value.HttpResponseCode;
            result.ErrorMessage = value.ErrorMessage;
            result.RequestCorrelationVector = value.RequestCorrelationVector;
            result.ResponseCorrelationVector = value.ResponseCorrelationVector;

            return result;
        }
    }

    /// <summary>
    /// Properties of a rendering session.
    /// </summary>
    /// <remarks>
    /// This information can be queried through <see cref="AzureSession.GetPropertiesAsync"/>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.GetPropertiesAsync"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SessionPropertiesAsync"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionPropertiesAbi
    {
        /// <summary>
        /// See <see cref="RenderingSessionStatus"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionStatus Status;

        /// <summary>
        /// See <see cref="RenderingSessionVmSize"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        /// <summary>
        /// The name of the host machine on which the session is running.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Hostname;

        /// <summary>
        /// Session message.
        /// </summary>
        /// <remarks>
        /// If the <see cref="RenderingSessionProperties.Status"/> is <see cref="RenderingSessionStatus.Error"/> or <see cref="RenderingSessionStatus.Expired"/>, the message may contain additional information.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Message;

        /// <summary>
        /// String representation of the server size.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
        [MarshalAs(UnmanagedType.LPStr)]
        public string SizeString;

        /// <summary>
        /// A string holding a unique ID for the session.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Id;

        /// <summary>
        /// How long the session has been active.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan ElapsedTime;

        /// <summary>
        /// The currently set lease duration for the session. If <see cref="RenderingSessionProperties.ElapsedTime"/> reaches this value, the session will be shut down automatically.
        /// </summary>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateParams)"/>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        /// <summary>
        /// Session handshake port.
        /// </summary>
        public int HandshakePort;

        /// <summary>
        /// ArrInspector port.
        /// </summary>
        public int ArrInspectorPort;

        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionProperties Convert(Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionProperties result = new Microsoft.Azure.RemoteRendering.RenderingSessionProperties();

            result.Status = value.Status;
            result.Size = value.Size;
            result.Hostname = value.Hostname;
            result.Message = value.Message;
            result.SizeString = value.SizeString;
            result.Id = value.Id;
            result.ElapsedTime = value.ElapsedTime;
            result.MaxLease = value.MaxLease;
            result.HandshakePort = value.HandshakePort;
            result.ArrInspectorPort = value.ArrInspectorPort;

            return result;
        }
    }

    /// <summary>
    /// Properties of a rendering session.
    /// </summary>
    /// <remarks>
    /// This information can be queried through <see cref="AzureSession.GetPropertiesAsync"/>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.GetPropertiesAsync"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SessionPropertiesAsync"/>
    public partial struct RenderingSessionProperties
    {
        /// <summary>
        /// See <see cref="RenderingSessionStatus"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionStatus Status;

        /// <summary>
        /// See <see cref="RenderingSessionVmSize"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        /// <summary>
        /// The name of the host machine on which the session is running.
        /// </summary>
        public string Hostname;

        /// <summary>
        /// Session message.
        /// </summary>
        /// <remarks>
        /// If the <see cref="RenderingSessionProperties.Status"/> is <see cref="RenderingSessionStatus.Error"/> or <see cref="RenderingSessionStatus.Expired"/>, the message may contain additional information.
        /// </remarks>
        public string Message;

        /// <summary>
        /// String representation of the server size.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
        public string SizeString;

        /// <summary>
        /// A string holding a unique ID for the session.
        /// </summary>
        public string Id;

        /// <summary>
        /// How long the session has been active.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan ElapsedTime;

        /// <summary>
        /// The currently set lease duration for the session. If <see cref="RenderingSessionProperties.ElapsedTime"/> reaches this value, the session will be shut down automatically.
        /// </summary>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateParams)"/>
        public Microsoft.Azure.RemoteRendering.ARRTimeSpan MaxLease;

        /// <summary>
        /// Session handshake port.
        /// </summary>
        public int HandshakePort;

        /// <summary>
        /// ArrInspector port.
        /// </summary>
        public int ArrInspectorPort;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionProperties.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionProperties value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi();

            result.Status = value.Status;
            result.Size = value.Size;
            result.Hostname = value.Hostname;
            result.Message = value.Message;
            result.SizeString = value.SizeString;
            result.Id = value.Id;
            result.ElapsedTime = value.ElapsedTime;
            result.MaxLease = value.MaxLease;
            result.HandshakePort = value.HandshakePort;
            result.ArrInspectorPort = value.ArrInspectorPort;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading data from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams)"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadFromBlobParamsAbi
    {
        /// <summary>
        /// Name of the Azure Storage account to load data from.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageAccountName;

        /// <summary>
        /// Name of the blob container in the storage account.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string BlobContainerName;

        /// <summary>
        /// Path to the asset inside the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AssetPath;

        public Microsoft.Azure.RemoteRendering.LoadFromBlobParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadFromBlobParams Convert(Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadFromBlobParams result = new Microsoft.Azure.RemoteRendering.LoadFromBlobParams();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.AssetPath = value.AssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading data from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams)"/>
    public partial struct LoadFromBlobParams
    {
        /// <summary>
        /// Name of the Azure Storage account to load data from.
        /// </summary>
        public string StorageAccountName;

        /// <summary>
        /// Name of the blob container in the storage account.
        /// </summary>
        public string BlobContainerName;

        /// <summary>
        /// Path to the asset inside the blob container.
        /// </summary>
        public string AssetPath;

        internal Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadFromBlobParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadFromBlobParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.AssetPath = value.AssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model using a URL.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelFromSASAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadModelFromSASParamsAbi
    {
        /// <summary>
        /// URL to the model.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URL pointing to a converted model. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ModelUrl;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public ulong Parent;

        public Microsoft.Azure.RemoteRendering.LoadModelFromSASParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadModelFromSASParams Convert(Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSASParams result = new Microsoft.Azure.RemoteRendering.LoadModelFromSASParams();

            result.ModelUrl = value.ModelUrl;
            result.Parent = value.Parent != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.Parent, false) : null;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model using a URL.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelFromSASAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    public partial struct LoadModelFromSASParams
    {
        /// <summary>
        /// URL to the model.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URL pointing to a converted model. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        public string ModelUrl;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Parent;

        internal Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelFromSASParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi();

            result.ModelUrl = value.ModelUrl;
            result.Parent = value.Parent?.handle ?? default(ulong);

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadModelParamsAbi
    {
        /// <summary>
        /// See <see cref="LoadFromBlobParams"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Blob;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public ulong Parent;

        public Microsoft.Azure.RemoteRendering.LoadModelParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadModelParams Convert(Microsoft.Azure.RemoteRendering.LoadModelParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelParams result = new Microsoft.Azure.RemoteRendering.LoadModelParams();

            result.Blob = value.Blob.Convert();
            result.Parent = value.Parent != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.Parent, false) : null;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    public partial struct LoadModelParams
    {
        /// <summary>
        /// See <see cref="LoadFromBlobParams"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParams Blob;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Parent;

        internal Microsoft.Azure.RemoteRendering.LoadModelParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadModelParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadModelParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadModelParamsAbi();

            result.Blob = value.Blob.Convert();
            result.Parent = value.Parent?.handle ?? default(ulong);

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture using a URL.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureFromSASAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadTextureFromSASParamsAbi
    {
        /// <summary>
        /// URL to the texture.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URL pointing to a texture. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string TextureUrl;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        public Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams Convert(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams result = new Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams();

            result.TextureUrl = value.TextureUrl;
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture using a URL.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureFromSASAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    public partial struct LoadTextureFromSASParams
    {
        /// <summary>
        /// URL to the texture.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URL pointing to a texture. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        public string TextureUrl;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        internal Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi();

            result.TextureUrl = value.TextureUrl;
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadTextureParamsAbi
    {
        /// <summary>
        /// See <see cref="LoadFromBlobParams"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParamsAbi Blob;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        public Microsoft.Azure.RemoteRendering.LoadTextureParams Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadTextureParams Convert(Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureParams result = new Microsoft.Azure.RemoteRendering.LoadTextureParams();

            result.Blob = value.Blob.Convert();
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    public partial struct LoadTextureParams
    {
        /// <summary>
        /// See <see cref="LoadFromBlobParams"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobParams Blob;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        internal Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureParams.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi Convert(Microsoft.Azure.RemoteRendering.LoadTextureParams value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi result = new Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi();

            result.Blob = value.Blob.Convert();
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Options for Remote Rendering runtime initialization.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RemoteRenderingInitializationAbi
    {
        /// <summary>
        /// Selects the <see cref="ConnectionType">connection type</see> for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectionType connectionType;

        /// <summary>
        /// Selects the <see cref="GraphicsApiType">graphics binding</see> for rendering.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType graphicsApi;

        /// <summary>
        /// Right vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis right;

        /// <summary>
        /// Up vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis up;

        /// <summary>
        /// Forward vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis forward;

        /// <summary>
        /// How many units in the client's coordinate system make up one meter.
        /// </summary>
        public float unitsPerMeter;

        /// <summary>
        /// The name (and version) of the client tool.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string toolId;

        public Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization Convert()
        {
            return Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization Convert(Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi value)
        {
            Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization result = new Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization();

            result.connectionType = value.connectionType;
            result.graphicsApi = value.graphicsApi;
            result.right = value.right;
            result.up = value.up;
            result.forward = value.forward;
            result.unitsPerMeter = value.unitsPerMeter;
            result.toolId = value.toolId;

            return result;
        }
    }

    /// <summary>
    /// Options for Remote Rendering runtime initialization.
    /// </summary>
    public partial struct RemoteRenderingInitialization
    {
        /// <summary>
        /// Selects the <see cref="ConnectionType">connection type</see> for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectionType connectionType;

        /// <summary>
        /// Selects the <see cref="GraphicsApiType">graphics binding</see> for rendering.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType graphicsApi;

        /// <summary>
        /// Right vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis right;

        /// <summary>
        /// Up vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis up;

        /// <summary>
        /// Forward vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis forward;

        /// <summary>
        /// How many units in the client's coordinate system make up one meter.
        /// </summary>
        public float unitsPerMeter;

        /// <summary>
        /// The name (and version) of the client tool.
        /// </summary>
        public string toolId;

        internal Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi Convert(Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization value)
        {
            Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi result = new Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi();

            result.connectionType = value.connectionType;
            result.graphicsApi = value.graphicsApi;
            result.right = value.right;
            result.up = value.up;
            result.forward = value.forward;
            result.unitsPerMeter = value.unitsPerMeter;
            result.toolId = value.toolId;

            return result;
        }
    }

    /// <summary>
    /// Generic result type used by the Remote Rendering API.
    /// </summary>
    public enum Result : int
    {
        /// <summary>
        /// Internal: Start of the range of core result values.
        /// </summary>
        CoreReturnValueStart = -1,
        /// <summary>
        /// Operation completed successfully.
        /// </summary>
        Success = 0,
        /// <summary>
        /// General failure.
        /// </summary>
        Fail = 1,
        /// <summary>
        /// The user canceled the operation.
        /// </summary>
        Cancelled = 2,
        /// <summary>
        /// Incorrect user input for the operation.
        /// </summary>
        InvalidParam = 3,
        /// <summary>
        /// An object with incorrect type was passed in.
        /// </summary>
        InvalidType = 4,
        /// <summary>
        /// Not used.
        /// </summary>
        BufferTooSmall_Deprecated = 5,
        /// <summary>
        /// Operation requires an active connection.
        /// </summary>
        /// <remarks>
        /// If the connection to the server has been lost, this error can occur for most operations,
        /// since only few operations are possible without a connection.
        /// </remarks>
        NoConnection = 6,
        /// <summary>
        /// Internal.
        /// </summary>
        ApiUnavailable = 7,
        /// <summary>
        /// Static initialization of remote rendering has been called multiple times.
        /// </summary>
        AlreadyInitialized = 8,
        /// <summary>
        /// Static de-initialization of remote rendering has already been performed.
        /// </summary>
        AlreadyDeinitialized = 9,
        /// <summary>
        /// The string passed into the API is longer than allowed.
        /// </summary>
        StringTooLong = 10,
        /// <summary>
        /// The index passed into the API is outside the valid range.
        /// </summary>
        IndexOutOfRange = 11,
        /// <summary>
        /// An async operation has not yet finished.
        /// </summary>
        InProgress = 12,
        /// <summary>
        /// Static initialization of remote rendering hasn't been done yet.
        /// </summary>
        NotInitialized = 13,
        /// <summary>
        /// Internal: Last used value of the range of core result values.
        /// </summary>
        CoreReturnValueLast = 14,
        /// <summary>
        /// Internal: Maximum value of the range of core result values.
        /// </summary>
        CoreReturnValueEnd = 200,
        /// <summary>
        /// Internal: Start of the range of file load result values.
        /// </summary>
        LoadFileReturnValueStart = 299,
        /// <summary>
        /// The requested file did not exist.
        /// </summary>
        FileNotFound = 300,
        /// <summary>
        /// The requested file is either corrupt or uses an old version that is not supported anymore.
        /// </summary>
        InvalidVersion = 301,
        /// <summary>
        /// Not used.
        /// </summary>
        IncompatibleVersion_Deprecated = 302,
        /// <summary>
        /// The requested file is either corrupt or not recognized.
        /// </summary>
        FailedToOpenFile = 303,
        /// <summary>
        /// Downloading the file from the provided URL failed.
        /// </summary>
        FileDownloadFailed = 304,
        /// <summary>
        /// Loading this model would exceed GPU memory limits. Request a larger server, or reduce the amount of loaded models.
        /// </summary>
        ExceedsMemoryLimit = 305,
        /// <summary>
        /// The target file cannot be written
        /// </summary>
        CannotWriteTargetFile = 306,
        /// <summary>
        /// The target file is corrupt or in an unsupported format
        /// </summary>
        FileCorrupt = 307,
        /// <summary>
        /// Internal: Last used value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueLast = 308,
        /// <summary>
        /// Internal: Maximum value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueEnd = 500,
        /// <summary>
        /// Internal: Start of the range of object result values.
        /// </summary>
        ObjectReturnValueStart = 599,
        /// <summary>
        /// The provided object ID is not valid (anymore).
        /// </summary>
        InvalidId = 600,
        /// <summary>
        /// The parent entity with the provided ID does not exist.
        /// </summary>
        InvalidParentId = 601,
        /// <summary>
        /// An object of the same type already exists on the target.
        /// </summary>
        AlreadyExists = 602,
        /// <summary>
        /// Re-parenting this entity to the target entity would create a cycle in the entity hierarchy.
        /// </summary>
        CyclicReference = 603,
        /// <summary>
        /// Not used.
        /// </summary>
        ObjectLocked_Deprecated = 604,
        /// <summary>
        /// Internal: Last used value of the range of object result values.
        /// </summary>
        ObjectReturnValueLast = 605,
        /// <summary>
        /// Internal: Maximum value of the range of object result values.
        /// </summary>
        ObjectReturnValueEnd = 800,
        /// <summary>
        /// Internal: Start of the range of connection result values.
        /// </summary>
        ConnectionReturnValueStart = 899,
        /// <summary>
        /// Internal: Secure connection enabled, but certificate was missing, invalid, or not usable.
        /// </summary>
        NoServerCertificate = 900,
        /// <summary>
        /// Internal: Handshake port could not be opened for accepting connections.
        /// </summary>
        HandshakePortBusy = 901,
        /// <summary>
        /// Handshake server is unreachable.
        /// </summary>
        HandshakeUnreachable = 902,
        /// <summary>
        /// Handshake server closed the connection prematurely; likely due to TLS/Plain mismatch or invalid certificate.
        /// </summary>
        HandshakeConnectionFailed = 903,
        /// <summary>
        /// Authentication with the handshake server failed.
        /// </summary>
        AuthenticationFailed = 904,
        /// <summary>
        /// No common compatible remoting version could be determined during handshake.
        /// </summary>
        RemotingVersionMismatch = 905,
        /// <summary>
        /// No common transport protocol could be determined during handshake.
        /// </summary>
        IncompatibleTransportProtocols = 906,
        /// <summary>
        /// Handshake failed. Reason not further specified.
        /// </summary>
        HandshakeFailed = 907,
        /// <summary>
        /// Internal: Transport port could not be opened for accepting connections.
        /// </summary>
        TransportPortBusy = 908,
        /// <summary>
        /// Transport server is unreachable.
        /// </summary>
        TransportUnreachable = 909,
        /// <summary>
        /// Transport connection was closed before all communication channels had been set up.
        /// </summary>
        TransportConnectionFailed = 910,
        /// <summary>
        /// Transport connection was closed due to protocol version mismatch.
        /// </summary>
        ProtocolVersionMismatch = 911,
        /// <summary>
        /// A protocol error occurred that was severe enough to invalidate the current connection or connection attempt.
        /// </summary>
        ProtocolError = 912,
        /// <summary>
        /// Transport connection was closed due to the requested video codec not being available.
        /// </summary>
        VideoCodecNotAvailable = 913,
        /// <summary>
        /// Connection has been closed by peer.
        /// </summary>
        ConnectionLost = 914,
        /// <summary>
        /// Connection has been closed due to graphics device loss.
        /// </summary>
        DeviceLost = 915,
        /// <summary>
        /// Connection has been closed by request.
        /// </summary>
        DisconnectRequest = 916,
        /// <summary>
        /// Internal.
        /// </summary>
        Timeout = 917,
        /// <summary>
        /// A connection has been established before.
        /// </summary>
        AlreadyConnected = 918,
        /// <summary>
        /// The client SDK version is not supported anymore. Please update.
        /// </summary>
        ArrVersionMismatch = 919,
        /// <summary>
        /// Network is unreachable. This usually means the client knows no route to reach the remote host.
        /// </summary>
        HandshakeNetworkUnreachable = 920,
        /// <summary>
        /// No connection could be made because the remote side actively refused it. Usually this means that no host application is running.
        /// </summary>
        HandshakeConnectionRefused = 921,
        /// <summary>
        /// Transport connection was closed due to the requested video format not being available.
        /// </summary>
        VideoFormatNotAvailable = 922,
        /// <summary>
        /// Disconnecting after receiving a disconnect request from the peer.
        /// </summary>
        PeerDisconnectRequest = 923,
        /// <summary>
        /// Timed out while waiting for peer to close connection.
        /// </summary>
        PeerDisconnectTimeout = 924,
        /// <summary>
        /// Internal: Last used value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueLast = 925,
        /// <summary>
        /// Internal: Maximum value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueEnd = 1100,
        /// <summary>
        /// Internal: Start of the range of manager result values.
        /// </summary>
        ManagerReturnValueStart = 1199,
        /// <summary>
        /// Internal: Invalid tool ID.
        /// </summary>
        InvalidToolId = 1200,
        /// <summary>
        /// The remote rendering manager has already been created.
        /// </summary>
        ManagerAlreadyCreated = 1201,
        /// <summary>
        /// The remote rendering manager has not been created yet.
        /// </summary>
        ManagerNotCreatedYet = 1202,
        /// <summary>
        /// Another session is already connected to this runtime.
        /// </summary>
        OtherSessionConnected = 1203,
        /// <summary>
        /// Internal.
        /// </summary>
        BadStateTransition = 1204,
        /// <summary>
        /// An internal tool failed to start
        /// </summary>
        FailedToStartTool = 1205,
        /// <summary>
        /// Internal: Last used value of the range of manager result values.
        /// </summary>
        ManagerReturnValueLast = 1206,
        /// <summary>
        /// Internal: Maximum value of the range of manager result values.
        /// </summary>
        ManagerReturnValueEnd = 1400,
        /// <summary>
        /// Internal: Start of the range of session result values.
        /// </summary>
        SessionReturnValueStart = 1499,
        /// <summary>
        /// The secure connection failed. Check the account settings.
        /// </summary>
        InvalidToken = 1500,
        /// <summary>
        /// The user provided URL is malformed.
        /// </summary>
        InvalidUrl = 1501,
        /// <summary>
        /// Internal: Last used value of the range of session result values.
        /// </summary>
        SessionReturnValueLast = 1502,
        /// <summary>
        /// Internal: Maximum value of the range of session result values.
        /// </summary>
        SessionReturnValueEnd = 1700,
    }

    /// <summary>
    /// Supported graphics APIs.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingWmrD3d11"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/graphics-bindings">Graphics binding (Remote Rendering docs)</seealso>
    public enum GraphicsApiType : int
    {
        /// <summary>
        /// Disables the graphics interface (headless mode).
        /// </summary>
        Headless = 0,
        /// <summary>
        /// Creates a graphics binding for local simulation (monoscopic rendering, typically in editor).
        /// </summary>
        SimD3D11 = 1,
        /// <summary>
        /// Creates a graphics binding for Windows Mixed Reality. This must be used when working on a HoloLens device.
        /// </summary>
        WmrD3D11 = 2,
        /// <summary>
        /// internal
        /// </summary>
        Count = 3,
    }

    /// <summary>
    /// Supported material types.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials (Remote Rendering docs)</seealso>
    public enum MaterialType : int
    {
        /// <summary>
        /// Physically-Based Rendering (PBR)
        /// </summary>
        /// <remarks>
        /// PBR materials support lighting and advanced properties such as roughness and metalness.
        /// </remarks>
        Pbr = 0,
        /// <summary>
        /// A fixed color material, optionally multiplied with a texture.
        /// </summary>
        /// <remarks>
        /// This material receives no lighting, it is always fully bright.
        /// </remarks>
        Color = 1,
    }

    /// <summary>
    /// Logging severity levels.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LogLevel"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend.LogLevel"/>
    public enum LogLevel : int
    {
        /// <summary>
        /// Used to disable logging.
        /// </summary>
        None = 0,
        /// <summary>
        /// The log message represents an error.
        /// </summary>
        Error = 1,
        /// <summary>
        /// The log message represents a warning.
        /// </summary>
        Warning = 2,
        /// <summary>
        /// The log message represents somewhat important information.
        /// </summary>
        Information = 3,
        /// <summary>
        /// The log message represents verbose information typically only useful for debugging.
        /// </summary>
        Debug = 4,
        /// <summary>
        /// internal
        /// </summary>
        Count = 5,
    }

    /// <summary>
    /// Coordinate system axis definitions.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.CutPlaneComponent"/>
    public enum Axis : int
    {
        /// <summary>
        /// Positive X axis
        /// </summary>
        X = 0,
        /// <summary>
        /// Negative X axis
        /// </summary>
        X_Neg = 1,
        /// <summary>
        /// Positive Y axis
        /// </summary>
        Y = 2,
        /// <summary>
        /// Negative Y axis
        /// </summary>
        Y_Neg = 3,
        /// <summary>
        /// Positive Z axis
        /// </summary>
        Z = 4,
        /// <summary>
        /// Negative Z axis
        /// </summary>
        Z_Neg = 5,
    }

    /// <summary>
    /// The state of the remote focus point in the current frame.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/late-stage-reprojection">Late stage reprojection</seealso>
    public enum FocusPointResult : int
    {
        /// <summary>
        /// No valid focus point data available.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// The data is valid but has been computed through a fallback.
        /// </summary>
        Fallback = 1,
        /// <summary>
        /// The data represents a valid focus point.
        /// </summary>
        Valid = 2,
    }

    /// <summary>
    /// Options for rendering single-sided geometry.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SingleSidedSettings"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    public enum SingleSidedMode : int
    {
        /// <summary>
        /// Back faces of single-sided geometry will be invisible.
        /// </summary>
        /// <remarks>
        /// When moving the viewpoint inside single sided geometry, or cutting it open with a <see cref="CutPlaneComponent"/>,
        /// back-facing geometry will not be visible, which may be undesirable. This mode has the least performance impact.
        /// </remarks>
        Normal = 0,
        /// <summary>
        /// Dynamically switch to double-sided rendering when geometry is cut open through a <see cref="CutPlaneComponent"/>.
        /// </summary>
        /// <remarks>
        /// This mode only incurs additional performance cost for geometry that is cut open with a cut plane. Moving the camera
        /// inside geometry doesn't enable double-sided rendering. This mode is most useful for applications that doe use cut planes,
        /// but where it is rare for users to move their head inside of geometry.
        /// </remarks>
        DynamicDoubleSiding = 1,
        /// <summary>
        /// Force single-sided geometry to be rendered double-sided.
        /// </summary>
        /// <remarks>
        /// This mode is useful when it is expected for users to move inside geometry. It does incur more performance overhead, though.
        /// </remarks>
        AlwaysDoubleSided = 2,
    }

    /// <summary>
    /// Enum that describes the three enabled states in a hierarchical context. HierarchicalEnableState is used in conjunction with <see cref="HierarchicalStates"/>
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStates"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/override-hierarchical-state">Hierarchical state override</seealso>
    public enum HierarchicalEnableState : int
    {
        /// <summary>
        /// The feature is disabled on this hierarchy level and further below.
        /// </summary>
        ForceOff = 0,
        /// <summary>
        /// The feature is enabled on this hierarchy level and further below.
        /// </summary>
        ForceOn = 1,
        /// <summary>
        /// The feature's enabled state is inherited from the parent.
        /// </summary>
        InheritFromParent = 2,
    }

    /// <summary>
    /// Status of the connection to the server.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering sessions</seealso>
    public enum ConnectionStatus : int
    {
        /// <summary>
        /// No connection to the server.
        /// </summary>
        Disconnected = 0,
        /// <summary>
        /// The client is currently connecting to the server.
        /// </summary>
        Connecting = 1,
        /// <summary>
        /// The client is currently connected to the server.
        /// </summary>
        Connected = 2,
    }

    /// <summary>
    /// Status of an asset conversion session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ConversionStatusAsync"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/model-conversion">Model conversion</seealso>
    public enum ConversionSessionStatus : int
    {
        /// <summary>
        /// The session status is unknown.
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// The session has been created successfully.
        /// </summary>
        Created = 1,
        /// <summary>
        /// The conversion is currently running.
        /// </summary>
        Running = 2,
        /// <summary>
        /// The conversion has been aborted.
        /// </summary>
        Aborted = 3,
        /// <summary>
        /// The conversion was stopped due to an error.
        /// </summary>
        Failure = 4,
        /// <summary>
        /// The conversion finished successfully.
        /// </summary>
        Success = 5,
    }

    /// <summary>
    /// Status of a rendering session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSessionProperties"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering sessions</seealso>
    public enum RenderingSessionStatus : int
    {
        /// <summary>
        /// The session status is unknown.
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// The session is currently starting.
        /// </summary>
        Starting = 1,
        /// <summary>
        /// The session is ready for rendering.
        /// </summary>
        Ready = 2,
        /// <summary>
        /// The session has been stopped by the user.
        /// </summary>
        Stopped = 3,
        /// <summary>
        /// The session has been stopped because its lease time expired.
        /// </summary>
        Expired = 4,
        /// <summary>
        /// The session has been stopped because it encountered an error.
        /// </summary>
        Error = 5,
    }

    /// <summary>
    /// The different types of objects used by ARR.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ObjectBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ResourceBase"/>
    public enum ObjectType : int
    {
        /// <summary>
        /// Invalid object type.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// internal
        /// </summary>
        FirstBasicObject = 1,
        /// <summary>
        /// Object is an <see cref="Entity"/>
        /// </summary>
        Entity = 1,
        /// <summary>
        /// Object is a <see cref="Mesh"/>
        /// </summary>
        Mesh = 2,
        /// <summary>
        /// Object is a <see cref="Material"/>
        /// </summary>
        Material = 3,
        /// <summary>
        /// Object is a <see cref="Texture"/>
        /// </summary>
        Texture = 4,
        /// <summary>
        /// internal
        /// </summary>
        LastBasicObject = 4,
        /// <summary>
        /// internal
        /// </summary>
        FirstComponent = 200,
        /// <summary>
        /// Object is a <see cref="MeshComponent"/>
        /// </summary>
        MeshComponent = 200,
        /// <summary>
        /// Object is a <see cref="CutPlaneComponent"/>
        /// </summary>
        CutPlaneComponent = 201,
        /// <summary>
        /// Object is a <see cref="HierarchicalStateOverrideComponent"/>
        /// </summary>
        HierarchicalStateOverrideComponent = 202,
        /// <summary>
        /// Object is a <see cref="PointLightComponent"/>
        /// </summary>
        PointLightComponent = 203,
        /// <summary>
        /// Object is a <see cref="SpotLightComponent"/>
        /// </summary>
        SpotLightComponent = 204,
        /// <summary>
        /// Object is a <see cref="DirectionalLightComponent"/>
        /// </summary>
        DirectionalLightComponent = 205,
        /// <summary>
        /// internal
        /// </summary>
        LastComponent = 205,
    }

    /// <summary>
    /// Size of the server used for the rendering session.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
    public enum RenderingSessionVmSize : int
    {
        /// <summary>
        /// internal
        /// </summary>
        None = 0,
        /// <summary>
        /// Premium size servers support the largest amounts of data.
        /// </summary>
        Premium = 1,
        /// <summary>
        /// Standard size servers may impose restrictions on the allowed rendering data.
        /// </summary>
        Standard = 2,
    }

    /// <summary>
    /// The type of connection to use.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization"/>
    public enum ConnectionType : int
    {
        /// <summary>
        /// General purpose connection.
        /// </summary>
        General = 0,
        /// <summary>
        /// Game engine specific connection.
        /// </summary>
        Engine = 1,
        /// <summary>
        /// internal
        /// </summary>
        Count = 2,
    }

    /// <summary>
    /// Defines how the alpha portion of a mesh's vertex color contributes to the final color.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial.PbrVertexAlphaMode"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/pbr-materials">PBR materials</seealso>
    public enum PbrVertexAlphaMode : int
    {
        /// <summary>
        /// The alpha value represents an ambient occlusion value and therefore only affects the indirect lighting from the skybox.
        /// </summary>
        Occlusion = 0,
        /// <summary>
        /// The alpha value serves as scale factor for the overall amount of lighting applied, meaning the alpha can be used to darken areas. This affects both indirect as well as direct lighting.
        /// </summary>
        LightMask = 1,
        /// <summary>
        /// The alpha represents how opaque (1.0) or transparent (0.0) the material is.
        /// </summary>
        /// <remarks>
        /// This only has an effect if the used <see cref="PbrMaterial"/> has transparency enabled.
        /// </remarks>
        Opacity = 2,
    }

    /// <summary>
    /// Defines whether the <see cref="ColorMaterial"/> is transparent and how it blends with the background.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial.ColorTransparencyMode"/>
    public enum ColorTransparencyMode : int
    {
        /// <summary>
        /// The material is opaque, but still allows for hard cutouts when the flag <see cref="ColorMaterialFeatures.AlphaClipped"/> is specified.
        /// </summary>
        Opaque = 0,
        /// <summary>
        /// The material is semi-transparent through alpha-blending, using the combined albedo's alpha for opacity.
        /// </summary>
        AlphaBlend = 1,
        /// <summary>
        /// The material uses additive blending.
        /// </summary>
        Additive = 2,
    }

    /// <summary>
    /// The supported texture types.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LoadTextureParams"/>
    public enum TextureType : int
    {
        /// <summary>
        /// The texture is a 2D texture.
        /// </summary>
        Texture2D = 0,
        /// <summary>
        /// The texture is a cubemap.
        /// </summary>
        CubeMap = 1,
    }

    /// <summary>
    /// The possible modes for the server side rendering.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.ConnectToRuntime(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/rendering-modes">Rendering modes</seealso>
    public enum ServiceRenderMode : int
    {
        /// <summary>
        /// The multi-GPU result is composed from distinct meshes by merging depth buffers. Suitable for most scene types; balances rendering quality with resource consumption.
        /// </summary>
        /// <remarks>
        /// This mode does NOT support dynamically switching transparency such as see-through effects via the <see cref="HierarchicalStateOverrideComponent"/>.
        /// </remarks>
        DepthBasedComposition = 0,
        /// <summary>
        /// The multi-GPU result is composed from tiles. This mode has slightly better rendering quality but also higher server resource consumption. Not suitable for very large scenes.
        /// </summary>
        TileBasedComposition = 1,
        /// <summary>
        /// The recommended render mode.
        /// </summary>
        Default = 0,
    }

    /// <summary>
    /// Specifies broad categories for assessing the meaning of a performance measurement.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PerformanceInformation"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PerformanceAssessment"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.QueryServerPerformanceAssessmentAsync"/>
    public enum PerformanceRating : int
    {
        Great = 0,
        Good = 1,
        Mediocre = 2,
        Bad = 3,
    }

    /// <summary>
    /// Render properties that can be overridden by the <see cref="HierarchicalStateOverrideComponent"/>
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/override-hierarchical-state">Hierarchical state override</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial queries</seealso>
    public enum HierarchicalStates : int
    {
        /// <summary>
        /// No state is overridden.
        /// </summary>
        None = 0,
        /// <summary>
        /// The visible flag is overridden.
        /// </summary>
        Hidden = 1,
        /// <summary>
        /// The selected state is overridden.
        /// </summary>
        Selected = 2,
        /// <summary>
        /// The see-through opacity is overridden.
        /// </summary>
        SeeThrough = 4,
        /// <summary>
        /// The use tint color state is overridden. This flag enables individual tint color per object.
        /// </summary>
        /// <remarks>
        /// This flag enables an individual tint color per object.
        /// </remarks>
        UseTintColor = 8,
        /// <summary>
        /// The disable collision flag is overridden.
        /// </summary>
        /// <remarks>
        /// Parts with this flag will be ignored by <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">spatial queries</see>.
        /// </remarks>
        DisableCollision = 16,
        /// <summary>
        /// The use cut plane filter mask state is overridden. This flag enables individual cut plane filter masks per object.
        /// </summary>
        UseCutPlaneFilterMask = 64,
        /// <summary>
        /// Renders the scene sub-tree as a transparent shell.
        /// </summary>
        /// <remarks>
        /// The effect's appearance can be globally configured using the <see cref="ShellRenderingSettings"/> state of the <see cref="RemoteManager"/>.
        /// </remarks>
        Shell = 128,
        /// <summary>
        /// Combination of all flags.
        /// </summary>
        AllValidFlags = 223,
    }

    /// <summary>
    /// Flags specific to the <see cref="PbrMaterial"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial.PbrFlags"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/pbr-materials">PBR materials</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    public enum PbrMaterialFeatures : int
    {
        None = 0,
        /// <summary>
        /// The material is transparent.
        /// </summary>
        /// <remarks>
        /// The amount of transparency is defined by the alpha value of the albedo color and optionally the alpha of the vertex color. See <see cref="PbrVertexAlphaMode"/> for how the vertex color can affect transparency.
        /// </remarks>
        TransparentMaterial = 1,
        /// <summary>
        /// Use the vertex color (if provided by the mesh).
        /// </summary>
        /// <remarks>
        /// This has to be enabled for the <see cref="PbrMaterial.PbrVertexAlphaMode"/> to take effect.
        /// </remarks>
        UseVertexColor = 2,
        /// <summary>
        /// The material is rendered double-sided. Otherwise back-faces may be culled, depending on the selected <see cref="SingleSidedMode"/>.
        /// </summary>
        DoubleSided = 4,
        /// <summary>
        /// Enables specular highlights for this material.
        /// </summary>
        SpecularHighlights = 8,
        /// <summary>
        /// Enables hard cut-outs on a per-pixel basis based on the alpha value being below <see cref="PbrMaterial.AlphaClipThreshold"/>. This works for opaque materials as well.
        /// </summary>
        AlphaClipped = 16,
        /// <summary>
        /// If enabled, this material fades to black as opposed to fading to transparent when using <see cref="PbrMaterial.FadeOut"/>. Fading to black has the same effect on see-through devices like HoloLens but has significantly lower rendering cost.
        /// </summary>
        FadeToBlack = 32,
        /// <summary>
        /// If enabled this material will have a Fresnel effect additively added to the rendering of the base material. Use the FresnelEffectExponent and FresnelEffectColor to control the effect visuals.
        /// </summary>
        FresnelEffect = 64,
        /// <summary>
        /// Toggles transparency depth writes. Objects rendered transparently do not contribute to the depth buffer as a default. Set this to true if objects associated with this material should write depth.
        /// </summary>
        /// <remarks>
        /// Enabling this on transparent materials can improve the re-projection behavior of transparent objects, and hologram stability by consequence. See the respective <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/late-stage-reprojection">LSR documentation</see> for details.
        /// </remarks>
        TransparencyWritesDepth = 128,
    }

    /// <summary>
    /// Flags specific to the <see cref="ColorMaterial"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial.ColorFlags"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/color-materials">Color materials</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    public enum ColorMaterialFeatures : int
    {
        None = 0,
        /// <summary>
        /// Use the vertex color (if provided by the mesh).
        /// </summary>
        UseVertexColor = 1,
        /// <summary>
        /// The material is rendered double-sided. Otherwise back-faces may be culled, depending on the selected <see cref="SingleSidedMode"/>.
        /// </summary>
        DoubleSided = 2,
        /// <summary>
        /// If enabled, this material fades to black as opposed to fading to transparent when using <see cref="ColorMaterial.FadeOut"/>. Fading to black has the same effect on see-through devices like HoloLens but has significantly lower rendering cost.
        /// </summary>
        FadeToBlack = 4,
        /// <summary>
        /// Enables hard cut-outs on a per-pixel basis based on the alpha value being below <see cref="ColorMaterial.AlphaClipThreshold"/>. This works for opaque materials as well.
        /// </summary>
        AlphaClipped = 8,
        /// <summary>
        /// Toggles transparency depth writes. Objects rendered transparently do not contribute to the depth buffer as a default. Set this to true if objects associated with this material should write depth.
        /// </summary>
        /// <remarks>
        /// Enabling this on transparent materials can improve the re-projection behavior of transparent objects, and hologram stability by consequence. See the respective <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/late-stage-reprojection">LSR documentation</see> for details.
        /// </remarks>
        TransparencyWritesDepth = 16,
        /// <summary>
        /// If enabled this material will have a Fresnel effect additively added to the rendering of the base material. Use the FresnelEffectExponent and FresnelEffectColor to control the effect visuals.
        /// </summary>
        FresnelEffect = 32,
    }

    /// <summary>
    /// Specifies the type of a metadata value.
    /// </summary>
    public enum MetadataValueType : int
    {
        /// <summary>
        /// Invalid meta data type.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// Bool.
        /// </summary>
        Bool = 1,
        /// <summary>
        /// 32 bit signed integer.
        /// </summary>
        Int32 = 2,
        /// <summary>
        /// 64 bit signed integer.
        /// </summary>
        Int64 = 3,
        /// <summary>
        /// 64 bit unsigned integer.
        /// </summary>
        UInt64 = 4,
        /// <summary>
        /// Double precision floating point.
        /// </summary>
        Double = 5,
        /// <summary>
        /// String.
        /// </summary>
        String = 6,
        /// <summary>
        /// internal
        /// </summary>
        MetadataValueTypeCount = 7,
    }

    /// <summary>
    /// Determines which hits a raycast query returns.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    public enum HitCollectionPolicy : int
    {
        /// <summary>
        /// Return all hits along the ray, sorted by distance.
        /// </summary>
        /// <remarks>
        /// This is the least efficient method but it is also rarely needed.
        /// </remarks>
        AllHits = 0,
        /// <summary>
        /// Return the closest hit.
        /// </summary>
        ClosestHit = 1,
        /// <summary>
        /// Return any hit along the ray.
        /// </summary>
        /// <remarks>
        /// This is the most efficient option, to answer 'is B visible from A'?
        /// </remarks>
        AnyHit = 2,
    }

    public enum HandleType : int
    {
        Unknown = 0,
        AsyncBase = 1,
        BoundsQueryAsync = 2,
        MetadataQueryAsync = 3,
        LoadModelAsync = 4,
        LoadTextureAsync = 5,
        RaycastQueryAsync = 6,
        PerformanceAssessmentAsync = 7,
        BaseSessionAsync = 8,
        SessionAsync = 9,
        CreateSessionAsync = 10,
        ConnectToRuntimeAsync = 11,
        ArrInspectorAsync = 12,
        SessionPropertiesAsync = 13,
        SessionPropertiesArrayAsync = 14,
        StartAssetConversionAsync = 15,
        ConversionStatusAsync = 16,
        ObjectBase = 17,
        ComponentBase = 18,
        LightComponentBase = 19,
        CutPlaneComponent = 20,
        HierarchicalStateOverrideComponent = 21,
        PointLightComponent = 22,
        SpotLightComponent = 23,
        DirectionalLightComponent = 24,
        MeshComponent = 25,
        ResourceBase = 26,
        Material = 27,
        PbrMaterial = 28,
        ColorMaterial = 29,
        Mesh = 30,
        Texture = 31,
        Entity = 32,
        GraphicsBinding = 33,
        GraphicsBindingSimD3d11 = 34,
        GraphicsBindingWmrD3d11 = 35,
    }

    internal delegate void DestructorHookDelegate();

    /// <summary>
    /// Delegate for monitoring the progress of an asynchronous operation.
    /// </summary>
    /// <param name="progress">
    /// Progress fraction between 0 and 1 for how close the operation is to finishing.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LoadModelAsync"/>
    public delegate void ProgressHandler(float progress);

    /// <summary>
    /// Delegate for receiving log messages.
    /// </summary>
    /// <param name="level">
    /// Level of the log message.
    /// </param>
    /// <param name="message">
    /// Message as an IntPtr to the underlying UTF-8 char array.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager"/>
    public delegate void LogHandler(Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message);

    /// <summary>
    /// Delegate for receiving connection status updates.
    /// </summary>
    /// <param name="status">
    /// The new connection status.
    /// </param>
    /// <param name="error">
    /// Additional error information in case of an unintended disconnect.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession"/>
    public delegate void ConnectionStatusHandler(Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error);

    /// <summary>
    /// Delegate for receiving notification when an update tick has completed on a <see cref="Microsoft.Azure.RemoteRendering.RemoteManager"/>.
    /// </summary>
    public delegate void UpdatedHandler();

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.BoundsQueryAsync"/> operation.
    /// </summary>
    public delegate void BoundsQueryHandler(Microsoft.Azure.RemoteRendering.BoundsQueryAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.MetadataQueryAsync"/> operation.
    /// </summary>
    public delegate void MetadataHandler(Microsoft.Azure.RemoteRendering.MetadataQueryAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.LoadModelAsync"/> operation.
    /// </summary>
    public delegate void LoadModelHandler(Microsoft.Azure.RemoteRendering.LoadModelAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.LoadTextureAsync"/> operation.
    /// </summary>
    public delegate void LoadTextureHandler(Microsoft.Azure.RemoteRendering.LoadTextureAsync async);

    /// <summary>
    /// Event handler for the completion of <see cref="Microsoft.Azure.RemoteRendering.RaycastQueryAsync"/> operation.
    /// </summary>
    public delegate void RaycastQueryHandler(Microsoft.Azure.RemoteRendering.RaycastQueryAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync"/> operation.
    /// </summary>
    public delegate void PerformanceAssessmentHandler(Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.SessionAsync"/> operation.
    /// </summary>
    public delegate void SessionHandler(Microsoft.Azure.RemoteRendering.SessionAsync async);

    /// <summary>
    /// Event handler for the completion of a async <see cref="Microsoft.Azure.RemoteRendering.CreateSessionAsync"/> operation.
    /// </summary>
    public delegate void CreateSessionHandler(Microsoft.Azure.RemoteRendering.CreateSessionAsync async);

    /// <summary>
    /// Informs the application that a frontend requires an updated access token or authentication token.
    /// </summary>
    /// <param name="sender">
    /// The frontend that requires an updated access token or authentication token.
    /// </param>
    /// <param name="args">
    /// The event arguments that require an AccessToken property or an AuthenticationToken property to be set.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureFrontend.TokenRequired"/>
    public delegate void TokenRequiredDelegate(object sender, Microsoft.Azure.RemoteRendering.TokenRequiredEventArgs args);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync"/> operation.
    /// </summary>
    public delegate void SessionPropertiesArrayHandler(Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.StartAssetConversionAsync"/> operation.
    /// </summary>
    public delegate void StartAssetConversionHandler(Microsoft.Azure.RemoteRendering.StartAssetConversionAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.ConversionStatusAsync"/> operation.
    /// </summary>
    public delegate void ConversionStatusHandler(Microsoft.Azure.RemoteRendering.ConversionStatusAsync async);

    /// <summary>
    /// Event handler for the completion of an <see cref="Microsoft.Azure.RemoteRendering.ArrInspectorAsync"/> operation.
    /// </summary>
    public delegate void ArrInspectorHandler(Microsoft.Azure.RemoteRendering.ArrInspectorAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.SessionPropertiesAsync"/> operation.
    /// </summary>
    public delegate void SessionPropertiesHandler(Microsoft.Azure.RemoteRendering.SessionPropertiesAsync async);

    /// <summary>
    /// Event handler for the completion of a <see cref="Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync"/> operation.
    /// </summary>
    public delegate void ConnectToRuntimeHandler(Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync result);

    /// <summary>
    /// Base class for all Remote Rendering API exceptions.
    /// </summary>
    public class RRException : Exception
    {
        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        public RRException()
        {
            this.ErrorCode = default(Result);
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        public RRException(Result code)
        {
            this.ErrorCode = code;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        public RRException(Result code, string message) : base(message)
        {
            this.ErrorCode = code;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        /// <param name='requestCorrelationVector'>Request correlation vector for this exception.</param>
        /// <param name='responseCorrelationVector'>Response correlation vector for this exception.</param>
        public RRException(Result code, string message, string requestCorrelationVector, string responseCorrelationVector) : base(message)
        {
            this.ErrorCode = code;
            this.RequestCorrelationVector = requestCorrelationVector;
            this.ResponseCorrelationVector = responseCorrelationVector;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        /// <param name='requestCorrelationVector'>Request correlation vector for this exception.</param>
        /// <param name='responseCorrelationVector'>Response correlation vector for this exception.</param>
        /// <param name='inner'>Exception that caused this exception to be thrown.</param>
        public RRException(Result code, string message, string requestCorrelationVector, string responseCorrelationVector, Exception inner) : base(message, inner)
        {
            this.ErrorCode = code;
            this.RequestCorrelationVector = requestCorrelationVector;
            this.ResponseCorrelationVector = responseCorrelationVector;
        }

        public Result ErrorCode { get; }

        public string RequestCorrelationVector { get; }

        public string ResponseCorrelationVector { get; }

    }

    /// <summary>
    /// Result type for async inspector website query functions.
    /// </summary>
    public partial class ArrInspectorAsync : AsyncBase, ICookie
    {
        internal ArrInspectorAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ArrInspectorAsync>.Add(this);
        }
        /// <summary>
        /// Get the URI of the generated web page.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public string Result
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_arr_inspector_async_get_result(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ArrInspectorHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ArrInspectorAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ArrInspectorHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.ArrInspectorAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ArrInspectorHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ArrInspectorHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_arr_inspector_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Base class for asynchronous results.
    /// </summary>
    public partial class AsyncBase : IDisposable
    {
        internal IntPtr handle;
        internal AsyncBase(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_addref(ahandle);
        }
        protected AsyncBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="AsyncBase"/> class.
        /// </summary>
        ~AsyncBase()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_async_base_release(this.handle));
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_async_base_dispose (this.handle));
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the current status of the operation.
        /// </summary>
        /// <remarks>
        /// Returns <see cref="Result.Success"/> or <see cref="Result.InProgress"/> for finished and ongoing operations.
        /// If this object is not <see cref="AsyncBase.Valid">valid</see>, <see cref="Result.AlreadyDeinitialized"/> is returned.
        /// In all other cases the result is an error code for what went wrong. See derived classes for additional information.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result Status
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Result result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_status(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns <c>true</c> once the operation has either succeeded or failed.
        /// </summary>
        /// <remarks>
        /// See <see cref="AsyncBase.IsRanToCompletion"/> and <see cref="AsyncBase.IsFaulted"/> to differentiate whether the operation succeeded or failed.
        /// </remarks>
        public bool IsCompleted
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_is_completed(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns <c>true</c> when the task has finished successfully.
        /// </summary>
        public bool IsRanToCompletion
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_is_ran_to_completion(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns <c>true</c> when the task has finished, but failed.
        /// </summary>
        public bool IsFaulted
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_async_base_get_is_faulted(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// AzureFrontend is an authorized connection to the Azure APIs for Remote Rendering.
    /// </summary>
    /// <remarks>
    /// Use this to create <see cref="AzureSession"/> instances and to convert assets.
    /// </remarks>
    public partial class AzureFrontend : IDisposable, ICookie
    {
        internal ulong handle;
        internal AzureFrontend(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_addref(ahandle);
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Add(this);
        }
        public AzureFrontend(Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo init)
        {
            Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi init_converted = init.Convert();
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_create_azure_frontend_account_info_init(init_converted, out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="AzureFrontend"/> class.
        /// </summary>
        ~AzureFrontend()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_azure_frontend_release(this.handle));
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_azure_frontend_dispose (this.handle));
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Only messages at this <see cref="LogLevel">log level</see> or below will be delivered through <see cref="AzureFrontend.MessageLogged"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LogLevel LogLevel
        {
            get
            {
                Microsoft.Azure.RemoteRendering.LogLevel result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_log_level(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_set_log_level(this.handle, value));
            }
        }

        /// <summary>
        /// Parameters with which this instance was initialized.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfo Configuration
        {
            get
            {
                Microsoft.Azure.RemoteRendering.AzureFrontendAccountInfoAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_configuration(this.handle, out result));
                return result.Convert();
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LogHandler _MessageLogged;
        /// <summary>Static handler.</summary>
        private static void MessageLoggedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LogHandler handler = (instance == null) ? null : instance._MessageLogged;
            if (handler != null)
            {
                handler(level, message);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LogHandlerNative MessageLoggedStaticHandlerDelegate = MessageLoggedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LogHandler MessageLogged
        {
            add
            {
                this._MessageLogged += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_set_message_logged(this.handle, this.cookie, MessageLoggedStaticHandlerDelegate));
            }
            remove
            {
                this._MessageLogged -= value;
            }
        }

        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.TokenRequiredDelegate _TokenRequired;
        /// <summary>Static handler.</summary>
        private static void TokenRequiredStaticHandler(ulong cookie, IntPtr args)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureFrontend>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.TokenRequiredDelegate handler = (instance == null) ? null : instance._TokenRequired;
            if (handler != null)
            {
                handler(instance, new Microsoft.Azure.RemoteRendering.TokenRequiredEventArgs(args, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.TokenRequiredDelegateNative TokenRequiredStaticHandlerDelegate = TokenRequiredStaticHandler;
        public event Microsoft.Azure.RemoteRendering.TokenRequiredDelegate TokenRequired
        {
            add
            {
                this._TokenRequired += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_set_token_required(this.handle, this.cookie, TokenRequiredStaticHandlerDelegate));
            }
            remove
            {
                this._TokenRequired -= value;
            }
        }

        /// <summary>
        /// Queries for all existing rendering sessions for the account associated with this frontend.
        /// </summary>
        /// <remarks>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// The returned async will complete in an arbitrary thread.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync GetCurrentRenderingSessionsAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_current_rendering_sessions_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Opens an existing rendering session.
        /// </summary>
        /// <param name="sessionId">
        /// The UUID of a rendering session.
        /// </param>
        /// <remarks>
        /// The session id can be created through <see cref="AzureFrontend.CreateNewRenderingSessionAsync(RenderingSessionCreationParams)"/>, as well as through external tooling such as PowerShell.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.AzureSession OpenRenderingSession(string sessionId)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.AzureSession result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_open_rendering_session(this.handle, sessionId, out result_handle));
            result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.AzureSession(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a new rendering session.
        /// </summary>
        /// <param name="paramsIn">
        /// Session creation parameters
        /// </param>
        /// <remarks>
        /// This spins up a new server in the Azure cloud.
        /// Once ready, CreateSessionAsync returns the created AzureSession object or an error context.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.CreateSessionAsync CreateNewRenderingSessionAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParams paramsIn)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.CreateSessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_create_new_rendering_session_async(this.handle, paramsIn, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.CreateSessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Internal.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.CreateSessionAsync CreateNewRenderingSessionUnsafeAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafe paramsIn)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationParamsUnsafeAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.CreateSessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_create_new_rendering_session_unsafe_async(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.CreateSessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Deprecated.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.StartAssetConversionAsync StartAssetConversionAsync_Deprecated(Microsoft.Azure.RemoteRendering.AssetConversionParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.StartAssetConversionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_start_asset_conversion_async_deprecated(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Starts converting an asset.
        /// </summary>
        /// <param name="inputLocation">
        /// Where to find the asset.
        /// </param>
        /// <param name="outputLocation">
        /// Where to place the converted asset.
        /// </param>
        public Microsoft.Azure.RemoteRendering.StartAssetConversionAsync StartAssetConversionAsync(Microsoft.Azure.RemoteRendering.AssetConversionInputParams inputLocation, Microsoft.Azure.RemoteRendering.AssetConversionOutputParams outputLocation)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputParamsAbi inputLocation_converted = inputLocation.Convert();
            Microsoft.Azure.RemoteRendering.AssetConversionOutputParamsAbi outputLocation_converted = outputLocation.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.StartAssetConversionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_start_asset_conversion_async(this.handle, inputLocation_converted, outputLocation_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Starts converting an asset using SAS access to the input and output containers.
        /// </summary>
        /// <param name="inputLocation">
        /// Where to find the asset.
        /// </param>
        /// <param name="outputLocation">
        /// Where to place the converted asset.
        /// </param>
        public Microsoft.Azure.RemoteRendering.StartAssetConversionAsync StartAssetConversionSasAsync(Microsoft.Azure.RemoteRendering.AssetConversionInputSasParams inputLocation, Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParams outputLocation)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputSasParamsAbi inputLocation_converted = inputLocation.Convert();
            Microsoft.Azure.RemoteRendering.AssetConversionOutputSasParamsAbi outputLocation_converted = outputLocation.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.StartAssetConversionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_start_asset_conversion_sas_async(this.handle, inputLocation_converted, outputLocation_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Queries the state of the current asset conversion.
        /// </summary>
        /// <param name="paramsIn">
        /// The conversion token returned by StartAssetConversionAsync.
        /// </param>
        /// <remarks>
        /// <para>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if no conversionId is provided.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ConversionStatusAsync GetAssetConversionStatusAsync(string conversionId)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ConversionStatusAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_frontend_get_asset_conversion_status_async(this.handle, conversionId, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(result_handle, transfer:true) : null;
            return result_object;
        }

    }

    /// <summary>
    /// Each Azure session is running on a dedicated server, providing the Azure Remote Rendering functionality.
    /// </summary>
    /// <remarks>
    /// An application can manage multiple AzureSession objects.
    /// However, each application can only connect a single AzureSession for rendering.
    /// </remarks>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    public partial class AzureSession : ICookie
    {
        internal ulong handle;
        internal AzureSession(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_addref(ahandle);
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureSession>.Add(this);
        }
        ~AzureSession()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_release(this.handle));
            this.handle = default(ulong);
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Retrieves the associated <see cref="AzureSession.AzureFrontend"/>
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AzureFrontend AzureFrontend
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.AzureFrontend result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_azure_frontend(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.AzureFrontend(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// String UUID of this session.
        /// </summary>
        /// <remarks>
        /// This can be used to connect to the session later or perform independent REST calls, for example with PowerShell.
        /// </remarks>
        public string SessionUUID
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_session_uuid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Last connection parameters used in a call to <see cref="AzureSession.ConnectToRuntime(ConnectToRuntimeParams)"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams ConnectToRuntimeParams
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_connect_to_runtime_params(this.handle, out result));
                return result.Convert();
            }
        }

        /// <summary>
        /// Connection status of this session.
        /// </summary>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession.ConnectionStatusChanged"/>
        public Microsoft.Azure.RemoteRendering.ConnectionStatus ConnectionStatus
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConnectionStatus result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_connection_status(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Utility function to query whether this session is connected.
        /// </summary>
        public bool IsConnected
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_is_connected(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ConnectionStatusHandler _ConnectionStatusChanged;
        /// <summary>Static handler.</summary>
        private static void ConnectionStatusChangedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.AzureSession>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ConnectionStatusHandler handler = (instance == null) ? null : instance._ConnectionStatusChanged;
            if (handler != null)
            {
                handler(status, error);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ConnectionStatusHandlerNative ConnectionStatusChangedStaticHandlerDelegate = ConnectionStatusChangedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ConnectionStatusHandler ConnectionStatusChanged
        {
            add
            {
                this._ConnectionStatusChanged += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_set_connection_status_changed(this.handle, this.cookie, ConnectionStatusChangedStaticHandlerDelegate));
            }
            remove
            {
                this._ConnectionStatusChanged -= value;
            }
        }

        /// <summary>
        /// Gets a filepath pointing to an HTML file to connect to the ArrInspector website.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The ArrInspector provides introspection and service status updates.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if no hostname is provided.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/resources/tools/arr-inspector">The ArrInspector inspection tool</seealso>
        public Microsoft.Azure.RemoteRendering.ArrInspectorAsync ConnectToArrInspectorAsync(string hostname)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ArrInspectorAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_connect_to_arr_inspector_async(this.handle, hostname, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ArrInspectorAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Queries the properties of the session (hostname, lease time, size, etc).
        /// </summary>
        /// <remarks>
        /// <para>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.SessionPropertiesAsync GetPropertiesAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionPropertiesAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_get_properties_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Stops the Azure session. It is not possible to connect to this session again.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SessionAsync StopAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_stop_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Updates the session parameters for this rendering session.
        /// </summary>
        /// <param name="updateParams">
        /// The new parameters to use
        /// </param>
        /// <remarks>
        /// <para>
        /// See <see cref="RenderingSessionUpdateParams"/> for details.
        /// </para>
        /// <para>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.SessionAsync RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateParams updateParams)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.SessionAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_renew_async(this.handle, updateParams, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.SessionAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Connect to the runtime on the server associated with this session.
        /// </summary>
        /// <param name="inputParams">
        /// Connection parameters.
        /// </param>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.AlreadyConnected"/> error occurs, if another session in the same process is already connected to its runtime.
        /// * A <see cref="Result.InProgress"/> error occurs, if ConnectToRuntime has been called before.
        /// * A <see cref="Result.OtherSessionConnected"/> error occurs, if another session is already connected to this runtime.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync ConnectToRuntime(Microsoft.Azure.RemoteRendering.ConnectToRuntimeParams inputParams)
        {
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeParamsAbi inputParams_converted = inputParams.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_connect_to_runtime(this.handle, inputParams_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Disconnect this session if connected to the runtime.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result DisconnectFromRuntime()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_azure_session_disconnect_from_runtime(this.handle, out result));
            return result;
        }

    }

    /// <summary>
    /// Base class for session related async query functions.
    /// </summary>
    public partial class BaseSessionAsync : AsyncBase
    {
        internal BaseSessionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Returns the context for the call result.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.SessionGeneralContext Context
        {
            get
            {
                Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_base_session_async_get_context(this.handle, out result));
                return result.Convert();
            }
        }

    }

    /// <summary>
    /// Result type for async object bounds query functions.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity.QueryLocalBoundsAsync"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity.QueryWorldBoundsAsync"/>
    public partial class BoundsQueryAsync : AsyncBase, ICookie
    {
        internal BoundsQueryAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.BoundsQueryAsync>.Add(this);
        }
        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the query is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.AABB3D Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.AABB3D result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_bounds_query_async_get_result(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.BoundsQueryHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.BoundsQueryAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.BoundsQueryHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.BoundsQueryHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.BoundsQueryHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_bounds_query_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Camera settings.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/camera">Camera</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CameraSettings"/>
    public partial class CameraSettings
    {
        internal ulong handle;
        internal CameraSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The near plane distance.
        /// </summary>
        public float NearPlane
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_near_plane(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The far plane distance.
        /// </summary>
        public float FarPlane
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_far_plane(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Enables depth composition with locally rendered content.
        /// </summary>
        /// <remarks>
        /// This is needed, if you want locally rendered content to intersect properly with remotely rendered content.
        /// On the other hand, if you render only UI elements locally that don't need to be occluded by remote content,
        /// turn this off to save performance and bandwidth.
        /// </remarks>
        public bool EnableDepth
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_enable_depth(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_enable_depth(this.handle, value));
            }
        }

        /// <summary>
        /// Sets the near and far plane of the camera.
        /// </summary>
        /// <param name="nearPlane">
        /// The distance to the near plane. Must be larger than zero.
        /// </param>
        /// <param name="farPlane">
        /// The distance to the far plane. Must be larger than zero.
        /// </param>
        /// <remarks>
        /// For best quality, keep the ratio of farPlane/nearPlane low. For Augmented Reality use cases the far plane doesn't need to be very far away,
        /// 20 to 100 meters should be sufficient.
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs, if near and far plane distances are identical.
        /// </para>
        /// </remarks>
        public void SetNearAndFarPlane(float nearPlane, float farPlane)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_near_and_far_plane(this.handle, nearPlane, farPlane));
        }

    }

    /// <summary>
    /// A material that doesn't get any lighting applied.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/color-materials">Color materials</seealso>
    public partial class ColorMaterial : Material
    {
        internal ColorMaterial(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The <see cref="ColorMaterialFeatures">color material flags</see>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid bitmask is passed in.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ColorMaterialFeatures ColorFlags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ColorMaterialFeatures result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_color_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_color_flags(this.handle, value));
            }
        }

        /// <summary>
        /// Constant albedo color.
        /// </summary>
        /// <remarks>
        /// This color is modulated with the color from the <see cref="ColorMaterial.AlbedoTexture"/>.
        /// The alpha channel represents the opacity, in case the material is flagged as transparent (<see cref="ColorMaterial.ColorTransparencyMode"/>).
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 AlbedoColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_albedo_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_albedo_color(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for the albedo color. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture AlbedoTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_albedo_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_albedo_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Scaling factors for texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Used to repeat/tile textures. For instance passing (4, 2) will repeat the texture 4 times along the U texture coordinate, and 2 times along V.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial.TexCoordOffset"/>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordScale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_tex_coord_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_tex_coord_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Constant offset added to texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// An offset is normalized to [0..1] range, regardless of texture size, so (0.5, 0.5) always points to the middle of a texture.
        /// The offset can be changed over time to scroll the texture.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordOffset
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_tex_coord_offset(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_tex_coord_offset(this.handle, value));
            }
        }

        /// <summary>
        /// Transparency mode for this material. See <see cref="ColorTransparencyMode"/> for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid mode is passed in.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ColorTransparencyMode ColorTransparencyMode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ColorTransparencyMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_color_transparency_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_color_transparency_mode(this.handle, value));
            }
        }

        /// <summary>
        /// Fade-out value in the [0..1] range, where 0.0 means fully faded out and 1.0 means fully opaque.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is very similar to changing the albedo's alpha on a transparent material, however, this function automatically manages the transparency flag for values of 1.0 (fully opaque) and smaller than 1.0 (semi-transparent).
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float FadeOut
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_fade_out(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_fade_out(this.handle, value));
            }
        }

        /// <summary>
        /// How much the vertex color is mixed into the final color. In [0..1] range.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the mesh has vertex colors, those colors can be multiplied into the final color.
        /// This option defines how much influence the vertex colors will have.
        /// A value of 0.0 means that the vertex color doesn't contribute to the output at all.
        /// At 1.0 the vertex colors are fully multiplied into the albedo color.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float VertexMix
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_vertex_mix(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_vertex_mix(this.handle, value));
            }
        }

        /// <summary>
        /// Threshold that is used for alpha cutouts.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If a pixel's final alpha value [0..1] falls below this threshold, the pixel is clipped, creating a hard cutout.
        /// Note that the material's <see cref="PbrMaterialFeatures.AlphaClipped"/> flag has to be set, for this threshold to have an effect.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float AlphaClipThreshold
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_alpha_clip_threshold(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_alpha_clip_threshold(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect color used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="ColorMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// Only the rgb channels of the color are used for the Fresnel effect, while the alpha value will be ignored.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 FresnelEffectColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_fresnel_effect_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_fresnel_effect_color(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect exponent used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="ColorMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// The valid range for the exponent is [0.01, 10].
        /// </remarks>
        public float FresnelEffectExponent
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_fresnel_effect_exponent(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_fresnel_effect_exponent(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Base class for all components.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Components add functionality to <see cref="Entity">entities</see>.
    /// For example, a <see cref="CutPlaneComponent"/> turns an entity into an object that cuts meshes open.
    /// </para>
    /// <para>
    /// An entity can only have one instance of each component type attached at any given time.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/components">Components</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class ComponentBase : ObjectBase
    {
        internal ComponentBase(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Whether this component is still valid.
        /// </summary>
        /// <remarks>
        /// A component is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The <see cref="Entity"/> that this component is attached to.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity Owner
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_owner(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Enabled state of this component.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Disabled components have no effect. This is usually the same, as if the component wasn't attached at all,
        /// except that the enabled state can be toggled at any time, and any other state (for instance, the color of a light source)
        /// is preserved. It is therefore often easier to disable a component, and enable it later again, rather than to delete it and
        /// create a new component later.
        /// </para>
        /// <para>
        /// However, an entity may only have one instance of each component type attached, even if a component is disabled.
        /// </para>
        /// </remarks>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this component.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Destroys the component in the runtime.
        /// </summary>
        /// <remarks>
        /// Once Destroy() has been called on a component, subsequent calls to <see cref="ComponentBase.Valid"/> will return <c>false</c>.
        /// </remarks>
        public void Destroy()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_destroy(this.handle));
        }

    }

    /// <summary>
    /// Result type for async runtime connection query functions.
    /// </summary>
    /// <remarks>
    /// The inherited function <see cref="AsyncBase.Status"/> may additionally return any of these values:
    /// * All values between <see cref="Result.ConnectionReturnValueStart"/> and <see cref="Result.ConnectionReturnValueLast"/>
    /// </remarks>
    public partial class ConnectToRuntimeAsync : AsyncBase, ICookie
    {
        internal ConnectToRuntimeAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync>.Add(this);
        }
        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr result)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.ConnectToRuntimeAsync(result, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ConnectToRuntimeHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_connect_to_runtime_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Result type for async asset conversion status query functions.
    /// </summary>
    public partial class ConversionStatusAsync : BaseSessionAsync, ICookie
    {
        internal ConversionStatusAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConversionStatusAsync>.Add(this);
        }
        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ConversionSessionStatus Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConversionSessionStatus result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_status_async_get_result(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get additional information about the result.
        /// </summary>
        public string ErrorMessage
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_status_async_get_error_message(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ConversionStatusHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.ConversionStatusAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ConversionStatusHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.ConversionStatusAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ConversionStatusHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ConversionStatusHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_status_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Result type for async session creation query functions.
    /// </summary>
    public partial class CreateSessionAsync : BaseSessionAsync, ICookie
    {
        internal CreateSessionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.CreateSessionAsync>.Add(this);
        }
        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.AzureSession Result
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.AzureSession result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_create_session_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.AzureSession(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.CreateSessionHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.CreateSessionAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.CreateSessionHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.CreateSessionAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.CreateSessionHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.CreateSessionHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_create_session_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Cut planes are used to cut away parts of meshes to be able to peek inside.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Once a cut plane is part of the scene, all rendered pixels that are on the back side of the plane will be discarded.
    /// By moving the cut plane around or changing its orientation, one can adjust which parts of the scene are visible.
    /// </para>
    /// <para>
    /// The position of the cut plane is specified through the position of the owning <see cref="Entity"/>.
    /// The orientation is specified through the <see cref="CutPlaneComponent.Normal"/> and the rotation of the entity.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/cut-planes">Cut planes</seealso>
    public partial class CutPlaneComponent : ComponentBase
    {
        internal CutPlaneComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The main axis of the cut plane when the owning <see cref="Entity"/> has an identity rotation.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Pixels that end up behind the cut plane will be discarded by the renderer.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs, if the passed in axis is out of range.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Axis Normal
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Axis result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_normal(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_normal(this.handle, value));
            }
        }

        /// <summary>
        /// The color towards which pixels that are closer than <see cref="CutPlaneComponent.FadeLength"/> will be faded.
        /// </summary>
        /// <remarks>
        /// If the alpha value is non-zero, pixels close to the cut plane will fade towards the RGB part of FadeColor. The strength of the alpha channel determines whether it will fade fully towards the fade color or only partially.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4Ub FadeColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_fade_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_fade_color(this.handle, value));
            }
        }

        /// <summary>
        /// The distance over which the cut plane fades the original pixel color towards the <see cref="CutPlaneComponent.FadeColor"/>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if a negative length is set.
        /// </para>
        /// </remarks>
        public float FadeLength
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_fade_length(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_fade_length(this.handle, value));
            }
        }

        /// <summary>
        /// Sets the bit mask that can be used to perform per-object cut plane filtering.
        /// </summary>
        public byte CutPlaneFilterMask
        {
            get
            {
                byte result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_cut_plane_filter_mask(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_cut_plane_filter_mask(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Options for debug rendering features
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.DebugRenderingSettings"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/debug-rendering">Debug Rendering</seealso>
    public partial class DebugRenderingSettings
    {
        internal ulong handle;
        internal DebugRenderingSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Controls the server-side overlay to render a frame counter.
        /// </summary>
        public bool RenderFrameCount
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_frame_count(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_frame_count(this.handle, value));
            }
        }

        /// <summary>
        /// Controls the server-side overlay to render the polygon count.
        /// </summary>
        public bool RenderPolygonCount
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_polygon_count(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_polygon_count(this.handle, value));
            }
        }

        /// <summary>
        /// Controls whether geometry should be rendered as wireframe.
        /// </summary>
        public bool RenderWireframe
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_wireframe(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_wireframe(this.handle, value));
            }
        }

    }

    /// <summary>
    /// A light source that emits light globally into a fixed direction.
    /// </summary>
    /// <remarks>
    /// This component simulates a light source that is very far away, such as the sun or the moon.
    /// Consequently, the owner's position is ignored and only the orientation is used. The light shines into the direction of the negative z-axis of the owner <see cref="Entity"/>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LightComponentBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SpotLightComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class DirectionalLightComponent : LightComponentBase
    {
        internal DirectionalLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
    }

    /// <summary>
    /// An entity represents an object in space.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Entities have a transform, meaning a position, rotation and scale.
    /// By themselves entities don't have any observable functionality. Instead behavior is added through components (see <see cref="ComponentBase"/>),
    /// which are attached to entities. For instance attaching a <see cref="MeshComponent"/> will make a mesh appear at the position of the entity.
    /// </para>
    /// <para>
    /// The most important aspect of the entity itself is the hierarchy and the resulting hierarchical transform. For example, when
    /// multiple entities are attached as children to a shared parent entity, all of these entities can be moved, rotated and scaled in unison by
    /// changing the transform of the parent entity.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateEntity"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/entities">Entities</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/components">Components</seealso>
    public partial class Entity : ObjectBase
    {
        internal Entity(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this object.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this entity is still valid.
        /// </summary>
        /// <remarks>
        /// An entity is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The entity that acts as this entity's parent.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Top level entities don't have a parent, in which case this returns <c>null</c>.
        /// Setting a new parent automatically adds this entity to the list of children of the provided parent.
        /// </para>
        /// <para>
        /// * A <see cref="Result.CyclicReference"/> error occurs, if the new parent is a descendant of this object.
        /// * A <see cref="Result.InvalidId"/> error occurs, if an invalid entity is set as the parent.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Parent
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_parent(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_parent(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Read-only list of all the entities that are attached as children to this one.
        /// </summary>
        /// <remarks>
        /// To make an entity the child of another entity, use the <see cref="Entity.Parent"/> property.
        /// </remarks>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Entity> Children
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Entity> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_children(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => new Microsoft.Azure.RemoteRendering.Entity(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Read-only list of all the components that are attached to this entity.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ComponentBase> Components
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ComponentBase> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_components(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.ComponentBaseFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Enables or disables the entity and all its components and children.
        /// </summary>
        /// <remarks>
        /// Disabling an entity is similar to deleting it, except that it can be enabled again easily.
        /// All components on a disabled entity are disabled as well, and so are all child entities.
        /// </remarks>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// Position, relative to the parent node.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidParam"/> error occurs if the given value is NaN or infinite.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Double3 Position
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Double3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_position(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_position(this.handle, value));
            }
        }

        /// <summary>
        /// Rotation, relative to the parent node.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidParam"/> error occurs if the given value is NaN or infinite.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Quaternion Rotation
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Quaternion result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_rotation(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_rotation(this.handle, value));
            }
        }

        /// <summary>
        /// Scale, relative to the parent node.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidParam"/> error occurs if the given value is NaN or infinite.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float3 Scale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Optional name property.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.StringTooLong"/> error occurs if the given string is excessively long.
        /// </para>
        /// </remarks>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_name(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_name(this.handle, value));
            }
        }

        /// <summary>
        /// Tries to find a component of the given type.
        /// </summary>
        /// <param name="type">
        /// Component type to search for.
        /// </param>
        /// <remarks>
        /// Only one instance of each component type can be attached to each entity. Therefore this function either returns a single result, or <c>null</c>, if none is found.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ComponentBase FindComponentOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_find_component_of_type(this.handle, type, out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.ComponentBaseFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Destroys the entity.
        /// </summary>
        /// <remarks>
        /// Destroying an entity will also destroy all of its components and child entities.
        /// Once Destroy() has been called, <see cref="Entity.Valid"/> returns <c>false</c>.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity.Valid"/>
        public void Destroy()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_destroy(this.handle));
        }

        /// <summary>
        /// Queries the world-space bounding box from the server.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The bounding box represents the volume that this entity, all its child entities, and attached meshes take up.
        /// </para>
        /// <para>
        /// QueryWorldBoundsAsync is an asynchronous call. The computation of the bounds is performed on the server and returned when available.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.Mesh.Bounds"/>
        public Microsoft.Azure.RemoteRendering.BoundsQueryAsync QueryWorldBoundsAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.BoundsQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_world_bounds_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Queries the local-space bounding box from the server.
        /// </summary>
        /// <remarks>
        /// QueryLocalBoundsAsync is an asynchronous call. The computation of the bounds is performed on the server and returned when available.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.BoundsQueryAsync QueryLocalBoundsAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.BoundsQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_local_bounds_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.BoundsQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Queries for any available metadata.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.MetadataQueryAsync QueryMetaDataAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.MetadataQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_meta_data_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.MetadataQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

    }

    /// <summary>
    /// Base class for graphics bindings.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/graphics-bindings">Graphics binding</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingWmrD3d11"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11"/>
    public partial class GraphicsBinding
    {
        internal ulong handle;
        internal GraphicsBinding(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        protected GraphicsBinding()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// The derived graphics binding that this instance can be cast to.
        /// </summary>
        /// <remarks>
        /// This may only be called when the <see cref="AzureFrontend"/> is initialized.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType Api
        {
            get
            {
                Microsoft.Azure.RemoteRendering.GraphicsApiType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_api(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Retrieves the remote focus point.
        /// </summary>
        /// <param name="coordinateSystem">
        /// The coordinate frame in which the focus point should be expressed. Passing an invalid coordinate system will result in invalid focus points.
        /// </param>
        /// <param name="position">
        /// The focus point's position in world-space.
        /// </param>
        /// <param name="normal">
        /// The focus point's normal in world-space.
        /// </param>
        /// <param name="velocity">
        /// The focus point's velocity measured in units per second, in world-space.
        /// </param>
        /// <remarks>
        /// <para>
        /// This focus point must be explicitly set as the focus point to be used.
        /// </para>
        /// <para>
        /// A <see cref="Result.NoConnection"/> error occurs if this is called while there is no connection to the server.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.FocusPointResult GetRemoteFocusPoint(System.IntPtr coordinateSystem, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity)
        {
            Microsoft.Azure.RemoteRendering.FocusPointResult result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_remote_focus_point(this.handle, coordinateSystem, out position, out normal, out velocity, out result));
            return result;
        }

        /// <summary>
        /// Retrieves the last frame's statistics.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.NoConnection"/> error occurs if this is called while there is no connection to the server.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
        public Microsoft.Azure.RemoteRendering.Result GetLastFrameStatistics(out Microsoft.Azure.RemoteRendering.FrameStatistics stats)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_last_frame_statistics(this.handle, out stats, out result));
            return result;
        }

    }

    /// <summary>
    /// Graphics API binding for local simulation.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This graphics binding is used to render a monoscopic remote image on a normal desktop application.
    /// With no sensors to provide head movement available, this binding requires the user to provide a current
    /// camera update each frame. The basic setup works as follow:
    /// </para>
    /// <para>
    /// 1. Remote and local content is rendered onto an off-screen color / depth render target called 'proxy' using the proxy camera provided by the Update function.
    /// The proxy needs to be created matching the resolution of the back-buffer.
    /// Before any rendering takes place, InitSimulation() needs to be called with the proxy texture handles, as well as a D3D device to fully initialize the simulation.
    /// </para>
    /// <para>
    /// 2. Each frame, before any rendering takes place, Update is called with the current camera transform and the returned proxy transform is applied to the proxy camera.
    /// </para>
    /// <para>
    /// 3. At the start of rendering into the proxy, <see cref="GraphicsBindingSimD3d11.BlitRemoteFrameToProxy"/> needs to be called, this fills the remote color and depth information into the proxy render targets.
    /// Any local content can now be rendered onto the proxy using the proxy camera.
    /// </para>
    /// <para>
    /// 4. Once the back-buffer is bound, only <see cref="GraphicsBindingSimD3d11.ReprojectProxy"/> needs to be called and no other rendering should take place.
    /// </para>
    /// <para>
    /// 5. Repeat with step 2 until session ends.
    /// </para>
    /// <para>
    /// 6. Call <see cref="GraphicsBindingSimD3d11.DeinitSimulation"/> after the remote session has ended.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    public partial class GraphicsBindingSimD3d11 : GraphicsBinding
    {
        internal GraphicsBindingSimD3d11(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Initializes the simulation. Needs to be called before a remote rendering session is started.
        /// </summary>
        /// <param name="d3dDevice">
        /// The d3d device that will be used to render the remote image.
        /// </param>
        /// <param name="proxyDepth">
        /// Depth texture of the proxy render-target.
        /// </param>
        /// <param name="proxyColor">
        /// Color texture of the proxy render-target. The minimum dimension of the texture is 256x256.
        /// </param>
        /// <param name="refreshRate">
        /// Target refresh rate at which the remote runtime should render.
        /// </param>
        /// <param name="flipBlitRemoteFrameTextureVertically">
        /// If set, <see cref="GraphicsBindingSimD3d11.BlitRemoteFrameToProxy"/> will flip the rendered image vertically.
        /// </param>
        /// <param name="flipReprojectTextureVertically">
        /// If set, <see cref="GraphicsBindingSimD3d11.ReprojectProxy"/> will flip the rendered image vertically.
        /// </param>
        public Microsoft.Azure.RemoteRendering.Result InitSimulation(System.IntPtr d3dDevice, System.IntPtr proxyDepth, System.IntPtr proxyColor, float refreshRate, bool flipBlitRemoteFrameTextureVertically, bool flipReprojectTextureVertically)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_init_simulation(this.handle, d3dDevice, proxyDepth, proxyColor, refreshRate, flipBlitRemoteFrameTextureVertically, flipReprojectTextureVertically, out result));
            return result;
        }

        /// <summary>
        /// Deinitializes the simulation. Needs to be called after a remote rendering session has ended.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result DeinitSimulation()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_deinit_simulation(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Needs to be called every frame.
        /// </summary>
        /// <param name="update">
        /// The update of the main camera. This information will be sent to the server for rendering.
        /// </param>
        /// <param name="proxyFrameUpdate">
        /// The camera update for the proxy. Matches the current remote frame and needs to be applied locally.
        /// </param>
        /// <remarks>
        /// Typically there are multiple frames in flight. The frame data that is received and rendered locally, is always lagging behind a bit. Therefore, when calling Update() you need to specify the latest matrices with which the server should render that frame, but the matrices that you need to use for rendering local contant have to match the ones that were used for the currently arriving video frame. Therefore ARR provides you with that information through the proxyFrameUpdate parameter, so that you don't need to keep track of old rendering matrices yourself.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result Update(Microsoft.Azure.RemoteRendering.SimulationUpdate update, out Microsoft.Azure.RemoteRendering.SimulationUpdate proxyFrameUpdate)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_update(this.handle, update, out proxyFrameUpdate, out result));
            return result;
        }

        /// <summary>
        /// Blits the current remote frame to the currently bound render target.
        /// </summary>
        /// <remarks>
        /// When this function is executed it is assumed that the proxy color and depth buffers are bound as the current render target.
        /// This should be done as the very first thing in each frame as this function will overwrite all content in the target buffers.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result BlitRemoteFrameToProxy()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_blit_remote_frame_to_proxy(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Reprojects the proxy color texture onto the back-buffer.
        /// </summary>
        /// <remarks>
        /// When this function is executed it is assumed that the back-buffer color and depth buffers are bound as the current render target.
        /// This should be done as the very last thing in each frame.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result ReprojectProxy()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_reproject_proxy(this.handle, out result));
            return result;
        }

    }

    /// <summary>
    /// D3D11 binding for Windows Mixed Reality.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Important: <c>RemoteManagerStatic.StartupRemoteRendering</c> must be called before any Holographic space is created
    /// and before any Mirage API is called.
    /// </para>
    /// <para>
    /// At runtime the only thing that needs to be done by the user is to call <see cref="GraphicsBindingWmrD3d11.BlitRemoteFrame"/> to render the remote frame to the current render target.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    public partial class GraphicsBindingWmrD3d11 : GraphicsBinding
    {
        internal GraphicsBindingWmrD3d11(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Blits the current remote frame to the bound render target.
        /// </summary>
        /// <remarks>
        /// When this function is executed it is assumed that the color and depth buffers provided by Mirage are bound as the render target.
        /// This should be done as the very first thing in each frame as this function will overwrite all content in the target buffers.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result BlitRemoteFrame()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_wmr_d3d11_blit_remote_frame(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Informs ARR of a new frame of reference.
        /// </summary>
        /// <param name="coordinateSystem">
        /// Pointer to ABI::Windows::Perception::Spatial::ISpatialCoordinateSystem.
        /// </param>
        /// <remarks>
        /// ARR must be informed whenever a new frame of reference is created and used as the new user coordinate system.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result UpdateUserCoordinateSystem(System.IntPtr coordinateSystem)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_wmr_d3d11_update_user_coordinate_system(this.handle, coordinateSystem, out result));
            return result;
        }

    }

    /// <summary>
    /// Controls the visualization of sub-hierarchies of <see cref="Entity">entities</see>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStates"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/override-hierarchical-state"/>
    public partial class HierarchicalStateOverrideComponent : ComponentBase
    {
        internal HierarchicalStateOverrideComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The color to use for tinting the meshes below this node.
        /// </summary>
        /// <remarks>
        /// The tint color is only used if the <see cref="HierarchicalStateOverrideComponent.UseTintColorState"/> is set to <see cref="HierarchicalEnableState.ForceOn"/>.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4Ub TintColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_tint_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_tint_color(this.handle, value));
            }
        }

        /// <summary>
        /// The cut plane filter mask of this component.
        /// </summary>
        public byte CutPlaneFilterMask
        {
            get
            {
                byte result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_cut_plane_filter_mask(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_cut_plane_filter_mask(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.Hidden"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState HiddenState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_hidden_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_hidden_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.Selected"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState SelectedState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_selected_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_selected_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.SeeThrough"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState SeeThroughState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_see_through_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_see_through_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.UseTintColor"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState UseTintColorState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_use_tint_color_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_use_tint_color_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the HierarchicalStateFlags.UseCutPlaneFilterMask feature
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState UseCutPlaneFilterMaskState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_use_cut_plane_filter_mask_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_use_cut_plane_filter_mask_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.DisableCollision"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState DisableCollisionState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_disable_collision_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_disable_collision_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.Shell"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState ShellState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_shell_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_shell_state(this.handle, value));
            }
        }

        /// <summary>
        /// Sets specific features to a new state of type <see cref="HierarchicalEnableState"/>.
        /// </summary>
        /// <param name="feature">
        /// The feature(s) to modify. A bitwise combination of features can be passed here to modify multiple features simultaneously.
        /// </param>
        /// <param name="enabledState">
        /// The new state.
        /// </param>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'feature' is an invalid bitmask.
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'enabledState' is an invalid value.
        /// </para>
        /// </remarks>
        public void SetState(Microsoft.Azure.RemoteRendering.HierarchicalStates feature, Microsoft.Azure.RemoteRendering.HierarchicalEnableState enabledState)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_state(this.handle, feature, enabledState));
        }

        /// <summary>
        /// Returns the current <see cref="HierarchicalEnableState">enabled state</see> of a feature.
        /// </summary>
        /// <param name="feature">
        /// A single feature to query the current status on. Unlike SetState, multiple feature bits cannot be combined here.
        /// </param>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'feature' is an invalid bitmask.
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'enabledState' is an invalid value.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState GetState(Microsoft.Azure.RemoteRendering.HierarchicalStates feature)
        {
            Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_state(this.handle, feature, out result));
            return result;
        }

    }

    /// <summary>
    /// Base class for all light components.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Attaching a light component to an <see cref="Entity"/> turns it into a dynamic light source that illuminates the geometry
    /// in addition to the <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/sky">global sky light</see>. The position and orientation of the entity determines the location and direction of the light.
    /// </para>
    /// <para>
    /// Only geometry that uses a <see cref="PbrMaterial"/> will be affected by this light. Geometry that has a <see cref="ColorMaterial"/> assigned generally receives no lighting.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SpotLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.DirectionalLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class LightComponentBase : ComponentBase
    {
        internal LightComponentBase(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The overall brightness and range of the light.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This value has no physical unit, however, it can be considered to be proportional to the physical power of the light source.
        /// </para>
        /// <para>
        /// For lights that have a falloff (<see cref="SpotLightComponent"/> and <see cref="PointLightComponent"/>), the intensity determines both brightness and range of influence. For infinite light sources (<see cref="DirectionalLightComponent"/>) it only determines the brightness.
        /// </para>
        /// <para>
        /// At an intensity of 1000 a point light roughly has a range of 100 world units. However, note that this doesn't scale linearly.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public float Intensity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_get_intensity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_set_intensity(this.handle, value));
            }
        }

        /// <summary>
        /// The color of the light in Gamma color space.
        /// </summary>
        /// <remarks>
        /// The color's alpha channel is ignored.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.Color4Ub"/>
        public Microsoft.Azure.RemoteRendering.Color4Ub Color
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_get_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_set_color(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Result type for async model loading functions.
    /// </summary>
    /// <remarks>
    /// The inherited function <see cref="AsyncBase.Status"/> may additionally return any of these values:
    /// * <see cref="Result.InvalidParentId"/>
    /// * <see cref="Result.Cancelled"/>
    /// * <see cref="Result.InvalidUrl"/>
    /// * All values between <see cref="Result.LoadFileReturnValueStart"/> and <see cref="Result.LoadFileReturnValueLast"/>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelFromSASAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams)"/>
    public partial class LoadModelAsync : AsyncBase, ICookie
    {
        internal LoadModelAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadModelAsync>.Add(this);
        }
        /// <summary>
        /// The result of the loading operation.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.LoadModelResult Result
        {
            get
            {
                IntPtr result_handle;
                Microsoft.Azure.RemoteRendering.LoadModelResult result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadModelResult(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// The current loading progress as a fraction in range 0 to 1.
        /// </summary>
        public float Progress
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_get_progress(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LoadModelHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadModelAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LoadModelHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.LoadModelAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LoadModelHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LoadModelHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.ProgressHandler _ProgressUpdated;
        /// <summary>Static handler.</summary>
        private static void ProgressUpdatedStaticHandler(ulong cookie, float progress)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadModelAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.ProgressHandler handler = (instance == null) ? null : instance._ProgressUpdated;
            if (handler != null)
            {
                handler(progress);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ProgressHandlerNative ProgressUpdatedStaticHandlerDelegate = ProgressUpdatedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ProgressHandler ProgressUpdated
        {
            add
            {
                this._ProgressUpdated += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_async_set_progress_updated(this.handle, this.cookie, ProgressUpdatedStaticHandlerDelegate));
            }
            remove
            {
                this._ProgressUpdated -= value;
            }
        }

    }

    /// <summary>
    /// Result data for a load model request.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadModelFromSASAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    public partial class LoadModelResult
    {
        internal IntPtr handle;
        internal LoadModelResult(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_addref(ahandle);
        }
        ~LoadModelResult()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Root <see cref="Entity"/> of the loaded model.
        /// </summary>
        /// <remarks>
        /// This is the top most <see cref="Entity"/> node in the model structure. You can place the model by setting this node's transform (see <see cref="Entity.Position"/>, <see cref="Entity.Rotation"/>, <see cref="Entity.Scale"/>).
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Root
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_root(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Retrieves all objects of the given type that were loaded as part of this model.
        /// </summary>
        /// <param name="type">
        /// The requested type must specify a valid object type such as <see cref="ObjectType.Entity"/> or <see cref="ObjectType.MeshComponent"/>.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if 'type' is outside the specified range.
        /// </para>
        /// </remarks>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectBase> GetLoadedObjectsOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectBase> result;
            ulong[] result_array;
            int result_length;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_loaded_objects_of_type(this.handle, type, out result_array, out result_length));
            result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.ObjectBaseFactory(handle, transfer:true)).ToArray();
            return result;
        }

        /// <summary>
        /// Retrieves all resources of the given type that were loaded as part of this model.
        /// </summary>
        /// <param name="type">
        /// The requested type must specify a valid resource type such as <see cref="ObjectType.Mesh"/> or <see cref="ObjectType.Material"/>.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if 'type' is outside the specified range.
        /// </para>
        /// </remarks>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ResourceBase> GetLoadedResourceOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ResourceBase> result;
            ulong[] result_array;
            int result_length;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_loaded_resource_of_type(this.handle, type, out result_array, out result_length));
            result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.ResourceBaseFactory(handle, transfer:true)).ToArray();
            return result;
        }

    }

    /// <summary>
    /// Result type for async texture loading functions.
    /// </summary>
    /// <remarks>
    /// The inherited function <see cref="AsyncBase.Status"/> may additionally return any of these values:
    /// * <see cref="Result.InvalidParam"/> if a 2D or cube texture is requested, but the referenced file contains a different kind of texture.
    /// * <see cref="Result.InvalidUrl"/> if the provided URL is malformed.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureFromSASAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams)"/>
    public partial class LoadTextureAsync : AsyncBase, ICookie
    {
        internal LoadTextureAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadTextureAsync>.Add(this);
        }
        /// <summary>
        /// The result of the loading operation.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture Result
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_texture_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LoadTextureHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.LoadTextureAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LoadTextureHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.LoadTextureAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LoadTextureHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LoadTextureHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_texture_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Materials are shared resources used to describe the rendering properties of a <see cref="Mesh"/>.
    /// </summary>
    /// <remarks>
    /// <para>
    /// A material specifies which <see cref="Texture">textures</see> to use and how to apply lighting to geometry. This class is the base class for all material resources. Derived classes determine the exact appearance.
    /// </para>
    /// <para>
    /// If a material is modified, all meshes that reference the material will be affected. To modify only the material of a specific object
    /// you need to create a dedicated material and replace the material reference on the <see cref="MeshComponent"/> to point to the custom material.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class Material : ResourceBase
    {
        internal Material(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The name of this material.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.StringTooLong"/> error occurs if the given string is excessively long.
        /// </para>
        /// </remarks>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_name(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_set_name(this.handle, value));
            }
        }

        public Microsoft.Azure.RemoteRendering.MaterialType MaterialSubType
        {
            get
            {
                Microsoft.Azure.RemoteRendering.MaterialType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_material_sub_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Copies material properties from another material.
        /// </summary>
        /// <param name="other">
        /// The material from which to copy properties.
        /// </param>
        /// <remarks>
        /// <para>
        /// If the material types don't match, only common properties such as albedo color and texture are copied.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if 'other' is an invalid material.
        /// </para>
        /// </remarks>
        public void CopyFrom(Microsoft.Azure.RemoteRendering.Material other)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_copy_from(this.handle, other != null ? other.handle : default(ulong)));
        }

    }

    /// <summary>
    /// Renders a mesh at the position of the <see cref="Entity"/>.
    /// </summary>
    /// <remarks>
    /// The referenced <see cref="MeshComponent.Mesh"/> is rendered at the location of the owner entity. The mesh component also allows to override the <see cref="Material">materials</see> that are used for rendering. If the mesh has been converted with collision information, it will also participate in <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">spatial queries</see>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent.Mesh"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/meshes">Meshes</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial queries</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials</seealso>
    public partial class MeshComponent : ComponentBase
    {
        internal MeshComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// Returns the list of materials set on this component.
        /// </summary>
        /// <remarks>
        /// These are materials that were specifically set to override the default mesh materials, through SetMaterial().
        /// The array will always be the same size as <see cref="Mesh.Materials"/>, however, entries for which no override is set, will be <c>null</c>.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent.UsedMaterials"/>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> Materials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_materials(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Returns the list of actually used materials for rendering the mesh.
        /// </summary>
        /// <remarks>
        /// The array will either contain the override material (<see cref="MeshComponent.Materials"/>) or, if no override was set,
        /// the default material of the referenced <see cref="MeshComponent.Mesh"/>.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent.Materials"/>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> UsedMaterials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_used_materials(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// The <see cref="Mesh"/> used for rendering and spatial queries.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Mesh Mesh
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Mesh result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_mesh(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Mesh(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_set_mesh(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Sets an override material for a given material slot.
        /// </summary>
        /// <param name="idx">
        /// A valid index into the <see cref="MeshComponent.Materials"/> array.
        /// </param>
        /// <param name="material">
        /// The material to set as the override. Passing <c>null</c> clears any previous override, such that the mesh's default material is used again.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.IndexOutOfRange"/> error occurs if 'idx' is outside the valid range.
        /// </para>
        /// </remarks>
        public void SetMaterial(int idx, Microsoft.Azure.RemoteRendering.Material material)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_set_material(this.handle, idx, material != null ? material.handle : default(ulong)));
        }

    }

    /// <summary>
    /// Meshes contain geometry data and <see cref="Material"/> references for rendering.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Meshes can't be loaded directly, instead when a model is loaded, for instance through <see cref="RemoteManager.LoadModelAsync(LoadModelParams)"/>, the loaded model contains at least one <see cref="Entity"/> which has a <see cref="MeshComponent"/> which in turn references a mesh. Once a model is loaded, you can get the mesh reference and also assign it to other objects.
    /// </para>
    /// <para>
    /// Mesh data can't be modified at runtime. It is possible to modify the materials that a mesh references, however, that would affect all entities which use that mesh. Instead, the preferred method is to specify override materials on a <see cref="MeshComponent"/> to change which materials are used for rendering.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/meshes">Meshes</seealso>
    public partial class Mesh : ResourceBase
    {
        internal Mesh(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The list of materials used for rendering the mesh, unless overridden by a <see cref="MeshComponent"/>.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> Materials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_materials(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<ulong>()).Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Returns the local-space bounding box of the mesh.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AABB3D Bounds
        {
            get
            {
                Microsoft.Azure.RemoteRendering.AABB3D result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_bounds(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Result type for async metadata query functions.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity.QueryMetaDataAsync"/>
    public partial class MetadataQueryAsync : AsyncBase, ICookie
    {
        internal MetadataQueryAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.MetadataQueryAsync>.Add(this);
        }
        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the query is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ObjectMetaData Result
        {
            get
            {
                IntPtr result_handle;
                Microsoft.Azure.RemoteRendering.ObjectMetaData result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_metadata_query_async_get_result(this.handle, out result_handle));
                result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ObjectMetaData(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.MetadataHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.MetadataQueryAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.MetadataHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.MetadataQueryAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.MetadataHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.MetadataHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_metadata_query_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Base class for <see cref="Entity">entities</see> and <see cref="ComponentBase">components</see>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ComponentBase"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class ObjectBase
    {
        internal ulong handle;
        internal ObjectBase(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        protected ObjectBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this object.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_get_type(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// A single metadata entry for an object.
    /// </summary>
    /// <remarks>
    /// Lifetime is managed by the owning metadata container (<see cref="ObjectMetaData"/>).
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ObjectMetaData"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MetadataValueType"/>
    public partial class ObjectMetaDataEntry
    {
        internal IntPtr handle;
        internal ObjectMetaDataEntry(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Name of this metadata entry.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_name(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Type of this metadata. See <see cref="MetadataValueType"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.MetadataValueType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.MetadataValueType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a bool.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetaDataEntry.Type"/> doesn't match.
        /// </remarks>
        public bool AsBool
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_bool(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as an Int32.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetaDataEntry.Type"/> doesn't match.
        /// </remarks>
        public int AsInt
        {
            get
            {
                int result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_int(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as an Int64.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetaDataEntry.Type"/> doesn't match.
        /// </remarks>
        public long AsInt64
        {
            get
            {
                long result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_int64(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a UInt64.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetaDataEntry.Type"/> doesn't match.
        /// </remarks>
        public ulong AsUInt64
        {
            get
            {
                ulong result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_uint64(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a double.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetaDataEntry.Type"/> doesn't match.
        /// </remarks>
        public double AsDouble
        {
            get
            {
                double result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_double(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a string.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetaDataEntry.Type"/> doesn't match.
        /// </remarks>
        public string AsString
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_entry_get_as_string(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// A collection of metadata values for an object.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry"/>
    public partial class ObjectMetaData
    {
        internal IntPtr handle;
        internal ObjectMetaData(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_addref(ahandle);
        }
        ~ObjectMetaData()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Provides read-only access to all entries in this collection.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry> Metadata
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry> result;
                IntPtr[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_get_metadata(this.handle, out result_array, out result_length));
                result = (result_array ?? Enumerable.Empty<IntPtr>()).Select(handle => new Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry(handle, transfer:true)).ToArray();
                return result;
            }
        }

        /// <summary>
        /// Query for an entry by name.
        /// </summary>
        /// <param name="name">
        /// The name of the entry to search.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if no meta data of the requested name exists.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry GetMetadataByName(string name)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_meta_data_get_metadata_by_name(this.handle, name, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ObjectMetaDataEntry(result_handle, transfer:true) : null;
            return result_object;
        }

    }

    /// <summary>
    /// Global settings for outline rendering.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/outlines">Outline rendering</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.OutlineSettings"/>
    public partial class OutlineSettings
    {
        internal ulong handle;
        internal OutlineSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The color of the outlines.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4Ub Color
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_color(this.handle, value));
            }
        }

        /// <summary>
        /// The rate (in Hz) at which the outline intensity oscillates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public float PulseRateHz
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_pulse_rate_hz(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_pulse_rate_hz(this.handle, value));
            }
        }

        /// <summary>
        /// The intensity with which the outline pulses.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This value must be in (0..1) range with 0=no pulsing effect and 1=full amplitude.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float PulseIntensity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_pulse_intensity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_pulse_intensity(this.handle, value));
            }
        }

    }

    /// <summary>
    /// A material for Physically Based Rendering.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/pbr-materials">PBR materials</seealso>
    public partial class PbrMaterial : Material
    {
        internal PbrMaterial(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The <see cref="PbrMaterialFeatures">PBR material flags</see>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid flags bitmask is set.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.PbrMaterialFeatures PbrFlags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PbrMaterialFeatures result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_pbr_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_pbr_flags(this.handle, value));
            }
        }

        /// <summary>
        /// Scaling factors for texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Used to repeat/tile textures. For instance passing (4, 2) will repeat the texture 4 times along the U texture coordinate, and 2 times along V.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial.TexCoordOffset"/>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordScale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_tex_coord_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_tex_coord_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Constant offset added to texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// An offset is normalized to [0..1] range, regardless of texture size, so (0.5, 0.5) always points to the middle of a texture.
        /// The offset can be changed over time to scroll the texture.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordOffset
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_tex_coord_offset(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_tex_coord_offset(this.handle, value));
            }
        }

        /// <summary>
        /// Constant albedo color.
        /// </summary>
        /// <remarks>
        /// This color is modulated with the color from the <see cref="PbrMaterial.AlbedoTexture"/>.
        /// The alpha channel represents the opacity, in case the material is flagged as transparent (<see cref="PbrMaterialFeatures.TransparentMaterial"/>).
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 AlbedoColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_albedo_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_albedo_color(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for the albedo color. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture AlbedoTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_albedo_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_albedo_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Determines how the alpha channel of vertex colors is used. See <see cref="PbrVertexAlphaMode"/> for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This mode has no effect if the mesh doesn't provide vertex colors or if the flag <see cref="PbrMaterialFeatures.UseVertexColor"/> is not set.
        /// The default value is <see cref="PbrVertexAlphaMode.Occlusion"/>.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an unknown mode is passed in.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode PbrVertexAlphaMode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_pbr_vertex_alpha_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_pbr_vertex_alpha_mode(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used as the normal map. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Although any texture can be used, note that a valid normalmap encodes the normal vector into RGB portions, rather than being a grayscale heightmap.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture NormalMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_normal_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_normal_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// How strongly to apply ambient occlusion to this material. [0..1] range.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float AOScale
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_aoscale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_aoscale(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for ambient occlusion. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A valid AO texture is a grayscale texture that defines which areas are occluded (dark/black) and which ones aren't (bright/white).
        /// The AO value from the texture will be modulated with the <see cref="PbrMaterial.AOScale"/> property.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture AOMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_aomap(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_aomap(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// A constant roughness value.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Roughness is a scalar in the [0..1] range. 
        /// The roughness constant is only used if no <see cref="PbrMaterial.RoughnessMap"/> is provided.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float Roughness
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_roughness(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_roughness(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for roughness. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A valid roughness texture is a grayscale texture that defines which areas are rough (values close to 1.0) and which are smooth (values close to 0.0).
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture RoughnessMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_roughness_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_roughness_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// A constant metalness value.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Metalness is a scalar in the [0..1] range, which in most of the use cases is either 0.0 (non-metallic) or 1.0 (metallic).
        /// The metalness constant is only used if no <see cref="PbrMaterial.MetalnessMap"/> is provided.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float Metalness
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_metalness(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_metalness(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for metalness. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A valid metalness texture is a grayscale texture that defines which areas should be considered metal (1.0) and which areas are non-metals (0.0). Values in between are possible, but are not physically plausible.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture MetalnessMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_metalness_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_metalness_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Threshold that is used for alpha cutouts.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If a pixel's final alpha value falls below this threshold, the pixel is clipped, creating a hard cutout.
        /// Note that the material's <see cref="PbrMaterialFeatures.AlphaClipped"/> flag has to be set, for this threshold to have an effect.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float AlphaClipThreshold
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_alpha_clip_threshold(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_alpha_clip_threshold(this.handle, value));
            }
        }

        /// <summary>
        /// Fade-out value in the [0..1] range, where 0.0 means fully faded out and 1.0 means fully opaque.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is very similar to changing the albedo's alpha on a transparent material, however, this function automatically manages the transparency flag for values of 1.0 (fully opaque) and smaller than 1.0 (semi-transparent).
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float FadeOut
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_fade_out(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_fade_out(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect color used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="PbrMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// Only the rgb channels of the color are used for the Fresnel effect, while the alpha value will be ignored.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 FresnelEffectColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_fresnel_effect_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_fresnel_effect_color(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect exponent used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="PbrMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// The valid range for the exponent is [0.01, 10].
        /// </remarks>
        public float FresnelEffectExponent
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_fresnel_effect_exponent(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_fresnel_effect_exponent(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Result type for async performance assessment query functions.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.QueryServerPerformanceAssessmentAsync"/>
    public partial class PerformanceAssessmentAsync : AsyncBase, ICookie
    {
        internal PerformanceAssessmentAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync>.Add(this);
        }
        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.PerformanceAssessment Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PerformanceAssessment result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_performance_assessment_async_get_result(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.PerformanceAssessmentHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_performance_assessment_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// A light source that emits light uniformly into all directions.
    /// </summary>
    /// <remarks>
    /// Point lights are used for local lights such as light bulbs.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LightComponentBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SpotLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.DirectionalLightComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class PointLightComponent : LightComponentBase
    {
        internal PointLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The radius of the light emitting shape.
        /// </summary>
        /// <remarks>
        /// <para>
        /// By default the radius is zero and the emitting shape is just a point.
        /// If the radius is set to a larger value, the shape becomes a sphere or even a tube, if <see cref="PointLightComponent.Length"/> is also set.
        /// </para>
        /// <para>
        /// A non-zero radius yields more realistic lighting for light bulbs and other objects that have a glowing
        /// surface. However, for performance reasons the computation is only an approximation of an area light. If such a light source comes too close to geometry or even intersects with it, the resulting lighting won't be physically correct.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public float Radius
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_radius(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_radius(this.handle, value));
            }
        }

        /// <summary>
        /// The length of the light emitting shape.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent.Radius"/>
        public float Length
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_length(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_length(this.handle, value));
            }
        }

        /// <summary>
        /// Custom interval of min/max distances over which the light's attenuated intensity is scaled down to zero.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This option can be used to enforce a smaller range of influence.
        /// By default these values are implicitly derived from the light's <see cref="LightComponentBase.Intensity">intensity</see>.
        /// Use this option if you want to create a light source that should be bright, but with a relatively small area of influence.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 AttenuationCutoff
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_attenuation_cutoff(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_attenuation_cutoff(this.handle, value));
            }
        }

        /// <summary>
        /// Optional cubemap <see cref="Texture"/> to be projected onto surrounding geometry.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The orientation of the owner <see cref="Entity"/> determines how the cubemap is projected onto surrounding geometry.
        /// The color from the cubemap is used to modulate the light's color.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a cubemap.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture ProjectedCubeMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_projected_cube_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_projected_cube_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// Result type for async ray cast query functions.
    /// </summary>
    /// <remarks>
    /// The inherited function <see cref="AsyncBase.Status"/> may additionally return any of these values:
    /// * <see cref="Result.InvalidParam"/>, if the ray start and end point are identicaly.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast)"/>
    public partial class RaycastQueryAsync : AsyncBase, ICookie
    {
        internal RaycastQueryAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RaycastQueryAsync>.Add(this);
        }
        /// <summary>
        /// A (potentially empty) array of <see cref="RayCastHit">intersections</see> that the raycast encountered.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the query is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.RayCastHit[] Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RayCastHitAbi[] result;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_raycast_query_async_get_result(this.handle, out result, out result_length));
                return result?.Select(x => x.Convert()).ToArray() ?? null;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.RaycastQueryHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RaycastQueryAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.RaycastQueryHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.RaycastQueryAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.RaycastQueryHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.RaycastQueryHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_raycast_query_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Main entry point for Remote Rendering specific actions. See AzureSession.Actions.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.AzureSession"/>
    public partial class RemoteManager : ICookie
    {
        internal ulong handle;
        internal RemoteManager(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RemoteManager>.Add(this);
        }
        /// <summary>
        /// Only messages at this <see cref="LogLevel">log level</see> or below will be delivered through <see cref="RemoteManager.MessageLogged"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LogLevel LogLevel
        {
            get
            {
                Microsoft.Azure.RemoteRendering.LogLevel result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_log_level(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_set_log_level(this.handle, value));
            }
        }

        /// <summary>
        /// Global <see cref="CameraSettings">camera settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/camera">Camera</seealso>
        public Microsoft.Azure.RemoteRendering.CameraSettings CameraSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.CameraSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_camera_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.CameraSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="StageSpaceSettings">stage space settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/stage-space">Stage space</seealso>
        public Microsoft.Azure.RemoteRendering.StageSpaceSettings StageSpaceSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.StageSpaceSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_stage_space_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.StageSpaceSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="SkyReflectionSettings">sky reflection settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/sky">Sky reflections</seealso>
        public Microsoft.Azure.RemoteRendering.SkyReflectionSettings SkyReflectionSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.SkyReflectionSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_sky_reflection_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.SkyReflectionSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="OutlineSettings">outline settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/outlines">Outline rendering</seealso>
        public Microsoft.Azure.RemoteRendering.OutlineSettings OutlineSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.OutlineSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_outline_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.OutlineSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="ZFightingMitigationSettings">z-fighting mitigation state</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/z-fighting-mitigation">Z-fighting mitigation</seealso>
        public Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings ZFightingMitigationSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_zfighting_mitigation_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global shell rendering settings.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/shell-rendering">Shell rendering</seealso>
        public Microsoft.Azure.RemoteRendering.ShellRenderingSettings ShellRenderingSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.ShellRenderingSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_shell_rendering_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.ShellRenderingSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="SingleSidedSettings">single-sided rendering settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
        public Microsoft.Azure.RemoteRendering.SingleSidedSettings SingleSidedSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.SingleSidedSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_single_sided_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.SingleSidedSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="DebugRenderingSettings">debug rendering settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/debug-rendering">Debug rendering</seealso>
        public Microsoft.Azure.RemoteRendering.DebugRenderingSettings DebugRenderingSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.DebugRenderingSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_get_debug_rendering_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.DebugRenderingSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.LogHandler _MessageLogged;
        /// <summary>Static handler.</summary>
        private static void MessageLoggedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RemoteManager>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.LogHandler handler = (instance == null) ? null : instance._MessageLogged;
            if (handler != null)
            {
                handler(level, message);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LogHandlerNative MessageLoggedStaticHandlerDelegate = MessageLoggedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LogHandler MessageLogged
        {
            add
            {
                this._MessageLogged += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_set_message_logged(this.handle, this.cookie, MessageLoggedStaticHandlerDelegate));
            }
            remove
            {
                this._MessageLogged -= value;
            }
        }

        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.UpdatedHandler _Updated;
        /// <summary>Static handler.</summary>
        private static void UpdatedStaticHandler(ulong cookie)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.RemoteManager>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.UpdatedHandler handler = (instance == null) ? null : instance._Updated;
            if (handler != null)
            {
                handler();
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.UpdatedHandlerNative UpdatedStaticHandlerDelegate = UpdatedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.UpdatedHandler Updated
        {
            add
            {
                this._Updated += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_set_updated(this.handle, this.cookie, UpdatedStaticHandlerDelegate));
            }
            remove
            {
                this._Updated -= value;
            }
        }

        /// <summary>
        /// Initiates the loading of a model.
        /// </summary>
        /// <param name="paramsIn">
        /// Parameters for loading the model.
        /// </param>
        /// <remarks>
        /// This call immediately returns an object that will emit an event when the model load has finished.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
        public Microsoft.Azure.RemoteRendering.LoadModelAsync LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadModelParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadModelAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_model_async(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadModelAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Initiates the loading of a model.
        /// </summary>
        /// <param name="paramsIn">
        /// Parameters for loading the model.
        /// </param>
        /// <remarks>
        /// This call immediately returns an object that will emit an event when the model load has finished.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
        public Microsoft.Azure.RemoteRendering.LoadModelAsync LoadModelFromSASAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSASParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSASParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadModelAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_model_from_sasasync(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadModelAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Initiates the loading of a texture.
        /// </summary>
        /// <param name="paramsIn">
        /// Parameters for loading the texture.
        /// </param>
        /// <remarks>
        /// This call immediately returns an object that will emit an event when the texture load has finished.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
        public Microsoft.Azure.RemoteRendering.LoadTextureAsync LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadTextureAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_texture_async(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadTextureAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Initiates the loading of a texture.
        /// </summary>
        /// <param name="paramsIn">
        /// Parameters for loading the texture.
        /// </param>
        /// <remarks>
        /// This call immediately returns an object that will emit an event when the texture load has finished.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
        public Microsoft.Azure.RemoteRendering.LoadTextureAsync LoadTextureFromSASAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams paramsIn)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSASParamsAbi paramsIn_converted = paramsIn.Convert();
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.LoadTextureAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_load_texture_from_sasasync(this.handle, paramsIn_converted, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.LoadTextureAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Performs a raycast query on the remote scene.
        /// </summary>
        /// <param name="cast">
        /// Raycast description.
        /// </param>
        /// <remarks>
        /// This call immediately returns an object that will emit an event when the raycast result has arrived.
        /// The raycast will be performed on the server against the state of the world on the frame that the raycast was issued on.
        /// Results will be sorted by distance, with the closest intersection to the user being the first item in the array.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial queries</seealso>
        public Microsoft.Azure.RemoteRendering.RaycastQueryAsync RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast cast)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.RaycastQueryAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_ray_cast_query_async(this.handle, cast, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.RaycastQueryAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Performs a performance assessment query on the server.
        /// </summary>
        /// <remarks>
        /// This call immediately returns an object that will emit an event when the query result has arrived.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
        public Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync QueryServerPerformanceAssessmentAsync()
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_query_server_performance_assessment_async(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.PerformanceAssessmentAsync(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a new entity.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/entities">Entities</seealso>
        public Microsoft.Azure.RemoteRendering.Entity CreateEntity()
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.Entity result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_create_entity(this.handle, out result_handle));
            result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a new <see cref="Material"/>.
        /// </summary>
        /// <param name="type">
        /// Material type to create.
        /// </param>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials</seealso>
        public Microsoft.Azure.RemoteRendering.Material CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType type)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.Material result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_create_material(this.handle, type, out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.MaterialFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a new component.
        /// </summary>
        /// <param name="componentType">
        /// Component type to create.
        /// </param>
        /// <param name="owner">
        /// Owner entity for the component.
        /// </param>
        /// <remarks>
        /// A <see cref="Result.AlreadyExists"/> error occurs, if the entity already has a component of the requested type.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/components">Components</seealso>
        public Microsoft.Azure.RemoteRendering.ComponentBase CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType componentType, Microsoft.Azure.RemoteRendering.Entity owner)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_create_component(this.handle, componentType, owner != null ? owner.handle : default(ulong), out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.ComponentBaseFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Pushes all client updates to the server and dispatches all messages received from the server.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Client updates such as entity and component state changes, raycast requests, and other async operations are queued on the client side
        /// and only sent to the server during a call to Update().
        /// </para>
        /// <para>
        /// Similarly, results from the server that arrived in the mean time, for example for raycasts and model loads, have been queued and will be dispatched to the client code only during Update().
        /// </para>
        /// <para>
        /// Consequently, Update() must be called once every frame.
        /// Calls to Update() invoke the <see cref="RemoteManager.Updated"/> event.
        /// </para>
        /// </remarks>
        public void Update()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_manager_update(this.handle));
        }

    }

    /// <summary>
    /// Base class for all resources.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Mesh"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Texture"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class ResourceBase
    {
        internal ulong handle;
        internal ResourceBase(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_addref(ahandle);
        }
        protected ResourceBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        ~ResourceBase()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_release(this.handle));
            this.handle = default(ulong);
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_get_type(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Result type for async session query functions.
    /// </summary>
    public partial class SessionAsync : BaseSessionAsync, ICookie
    {
        internal SessionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionAsync>.Add(this);
        }
        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.SessionHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.SessionHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.SessionAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.SessionHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.SessionHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Result type for async session property array query functions.
    /// </summary>
    public partial class SessionPropertiesArrayAsync : BaseSessionAsync, ICookie
    {
        internal SessionPropertiesArrayAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync>.Add(this);
        }
        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties[] Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi[] result;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_array_async_get_result(this.handle, out result, out result_length));
                return result?.Select(x => x.Convert()).ToArray() ?? null;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.SessionPropertiesArrayAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.SessionPropertiesArrayHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_array_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Result type for async session properties query functions.
    /// </summary>
    public partial class SessionPropertiesAsync : BaseSessionAsync, ICookie
    {
        internal SessionPropertiesAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesAsync>.Add(this);
        }
        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_async_get_result(this.handle, out result));
                return result.Convert();
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.SessionPropertiesHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.SessionPropertiesAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.SessionPropertiesHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.SessionPropertiesAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.SessionPropertiesHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.SessionPropertiesHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_properties_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Global settings for objects rendered using the <see cref="HierarchicalStates.Shell">hierarchical override shell effect</see>.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/shell-rendering">Shell rendering</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.ShellRenderingSettings"/>
    public partial class ShellRenderingSettings
    {
        internal ulong handle;
        internal ShellRenderingSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The opacity of shell-rendered geometry. Ranges from 0 (invisible) to 1 (fully opaque).
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if a value outside the [0;1] range is passed in.
        /// </para>
        /// </remarks>
        public float Opacity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_get_opacity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_set_opacity(this.handle, value));
            }
        }

        /// <summary>
        /// Amount of color desaturation to apply to the shell-rendered objects. Ranges from 0 (original color) to 1 (greyscale).
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if a value outside the [0;1] range is passed in.
        /// </para>
        /// </remarks>
        public float Desaturation
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_get_desaturation(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_set_desaturation(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Settings for single-sided geometry rendering.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.SingleSidedSettings"/>
    public partial class SingleSidedSettings
    {
        internal ulong handle;
        internal SingleSidedSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// What mode to use for rendering single-sided geometry.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid mode value is passed in.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.SingleSidedMode"/>
        public Microsoft.Azure.RemoteRendering.SingleSidedMode Mode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.SingleSidedMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_get_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_set_mode(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Settings for the global sky reflections.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/sky">Sky reflections</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.SkyReflectionSettings"/>
    public partial class SkyReflectionSettings
    {
        internal ulong handle;
        internal SkyReflectionSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The sky <see cref="Texture"/> used for reflections.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This can be either a cubemap or a 2D texture in spherical coordinates.
        /// </para>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if the provided texture is invalid.
        /// * A <see cref="Result.InvalidType"/> error occurs if the provided texture is not a 2D or cube texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture SkyReflectionTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_get_sky_reflection_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_set_sky_reflection_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// A light source that emits light within a directed cone.
    /// </summary>
    /// <remarks>
    /// In contrast to the <see cref="PointLightComponent"/>, this component only emits light within a cone shape.
    /// The main direction of the cone is along the owner's negative z-axis.
    /// Typical use cases for spotlights are flashlights.
    /// However, they can also be used to emulate the shadow of point lights that are encased in a hull.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LightComponentBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.DirectionalLightComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class SpotLightComponent : LightComponentBase
    {
        internal SpotLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The radius of the light emitting shape.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent.Radius"/>
        public float Radius
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_radius(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_radius(this.handle, value));
            }
        }

        /// <summary>
        /// The inner and outer angle (in degree) of the spot light cone.
        /// </summary>
        /// <remarks>
        /// <para>
        /// * Everything within the inner angle is illuminated with full brightness.
        /// * Everything outside the outer angle won't be illuminated at all.
        /// * Between the inner and outer angle a falloff that creates a penumbra-like effect is applied.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if x or y is outside the range [0; 89] or if x is >= y.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 SpotAngleDeg
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_spot_angle_deg(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_spot_angle_deg(this.handle, value));
            }
        }

        /// <summary>
        /// The strength of the light falloff between the inner and outer cone angle.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The larger the value, the sharper the transition.
        /// The default value of 1.0 results in a linear transition.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside the range [0.01; 256].
        /// </para>
        /// </remarks>
        public float FalloffExponent
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_falloff_exponent(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_falloff_exponent(this.handle, value));
            }
        }

        /// <summary>
        /// Custom interval of min/max distances over which the light's attenuated intensity is scaled down to zero.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent.AttenuationCutoff"/>
        public Microsoft.Azure.RemoteRendering.Float2 AttenuationCutoff
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_attenuation_cutoff(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_attenuation_cutoff(this.handle, value));
            }
        }

        /// <summary>
        /// Optional 2D <see cref="Texture"/> to be projected onto geometry.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The color from the texture is used to modulate the light's color.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture Projected2dTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_projected2d_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_projected2d_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// Options for changing the stage-space origin.
    /// </summary>
    /// <remarks>
    /// To make sure that local and remote content align correctly, any additional transform that is applied on top of the camera transform needs to be set here as well to inform the server.
    /// WARNING: This feature is experimental and changing the origin will break local/remote content alignment for a brief moment.
    /// Thus, it is currently only intended to be used for world locking purposes like anchors that exhibit only very small changes over time.
    /// </remarks>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/stage-space">Stage space</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.StageSpaceSettings"/>
    public partial class StageSpaceSettings
    {
        internal ulong handle;
        internal StageSpaceSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Stage space origin position.
        /// </summary>
        /// <remarks>
        /// This should be set at the end of each frame to the world-space position of the camera's parent.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Double3 Position
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Double3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_get_position(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_set_position(this.handle, value));
            }
        }

        /// <summary>
        /// Stage space origin rotation.
        /// </summary>
        /// <remarks>
        /// This should be set at the end of each frame to the world-space rotation of the camera's parent.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Quaternion Rotation
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Quaternion result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_get_rotation(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_set_rotation(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Result type for async asset conversion query functions.
    /// </summary>
    public partial class StartAssetConversionAsync : BaseSessionAsync, ICookie
    {
        internal StartAssetConversionAsync(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
            Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.StartAssetConversionAsync>.Add(this);
        }
        /// <summary>
        /// Get the uuid for the ingestion operation.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public string Result
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_start_asset_conversion_async_get_result(this.handle, out result));
                return result;
            }
        }

        private ulong cookie;
        ulong ICookie.Cookie { get { return this.cookie; } set { this.cookie = value; } }
        /// <summary>Registered callbacks on this instance.</summary>
        private event Microsoft.Azure.RemoteRendering.StartAssetConversionHandler _Completed;
        /// <summary>Static handler.</summary>
        private static void CompletedStaticHandler(ulong cookie, IntPtr async)
        {
            var instance = Microsoft.Azure.RemoteRendering.CookieTracker<Microsoft.Azure.RemoteRendering.StartAssetConversionAsync>.Lookup(cookie);
            Microsoft.Azure.RemoteRendering.StartAssetConversionHandler handler = (instance == null) ? null : instance._Completed;
            if (handler != null)
            {
                handler(new Microsoft.Azure.RemoteRendering.StartAssetConversionAsync(async, transfer:false));
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.StartAssetConversionHandlerNative CompletedStaticHandlerDelegate = CompletedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.StartAssetConversionHandler Completed
        {
            add
            {
                this._Completed += value;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_start_asset_conversion_async_set_completed(this.handle, this.cookie, CompletedStaticHandlerDelegate));
            }
            remove
            {
                this._Completed -= value;
            }
        }

    }

    /// <summary>
    /// Textures represent images that can be applied to geometry.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Textures are immutable, shared resources, loaded through the <see cref="RemoteManager"/>.
    /// Attempting to load the same texture twice, will return the same object.
    /// </para>
    /// <para>
    /// To apply a texture to geometry, set it on a <see cref="Material"/> and assign the material to a <see cref="Mesh"/>. Textures can also be used in the <see cref="SkyReflectionSettings"/>.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureParams)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.LoadTextureFromSASAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSASParams)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures (Remote Rendering documentation)</seealso>
    public partial class Texture : ResourceBase
    {
        internal Texture(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }
        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the name of the texture.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_name(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Informs the application that the service requires an updated access token or authentication token.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/frontend-apis">Use the Azure Frontend APIs for authentication</seealso>
    public partial class TokenRequiredEventArgs : EventArgs
    {
        internal IntPtr handle;
        internal TokenRequiredEventArgs(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_addref(ahandle);
        }
        ~TokenRequiredEventArgs()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// The access token to be used by the operation that requires it.
        /// </summary>
        public string AccessToken
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_get_access_token(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_set_access_token(this.handle, value));
            }
        }

        /// <summary>
        /// The authentication token to be used by the operation that requires it.
        /// </summary>
        public string AuthenticationToken
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_get_authentication_token(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_set_authentication_token(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Settings for z-fighting mitigation.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/z-fighting-mitigation">Z-fighting mitigation</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteManager.ZFightingMitigationSettings"/>
    public partial class ZFightingMitigationSettings
    {
        internal ulong handle;
        internal ZFightingMitigationSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }
        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether z-fighting mitigation is used.
        /// </summary>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// Activates checkerboard highlighting of potential z-fighting. For debugging purposes.
        /// </summary>
        public bool Highlighting
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_highlighting(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_set_highlighting(this.handle, value));
            }
        }

    }

}
